
citacka_fun.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00003564  0800013c  0800013c  0001013c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000008b8  080036a0  080036a0  000136a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08003f58  08003f58  00013f58  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08003f5c  08003f5c  00013f5c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000001c  20000000  08003f60  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000084  2000001c  08003f7c  0002001c  2**2
                  ALLOC
  7 ._user_heap_stack 00000400  200000a0  08003f7c  000200a0  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  0002001c  2**0
                  CONTENTS, READONLY
  9 .debug_info   000070a9  00000000  00000000  00020045  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001634  00000000  00000000  000270ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000910  00000000  00000000  00028728  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000868  00000000  00000000  00029038  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00003397  00000000  00000000  000298a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00002a65  00000000  00000000  0002cc37  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007e  00000000  00000000  0002f69c  2**0
                  CONTENTS, READONLY
 16 .debug_frame  0000255c  00000000  00000000  0002f71c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .stabstr      0000003f  00000000  00000000  00031c78  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800013c <__do_global_dtors_aux>:
 800013c:	b510      	push	{r4, lr}
 800013e:	4c05      	ldr	r4, [pc, #20]	; (8000154 <__do_global_dtors_aux+0x18>)
 8000140:	7823      	ldrb	r3, [r4, #0]
 8000142:	b933      	cbnz	r3, 8000152 <__do_global_dtors_aux+0x16>
 8000144:	4b04      	ldr	r3, [pc, #16]	; (8000158 <__do_global_dtors_aux+0x1c>)
 8000146:	b113      	cbz	r3, 800014e <__do_global_dtors_aux+0x12>
 8000148:	4804      	ldr	r0, [pc, #16]	; (800015c <__do_global_dtors_aux+0x20>)
 800014a:	f3af 8000 	nop.w
 800014e:	2301      	movs	r3, #1
 8000150:	7023      	strb	r3, [r4, #0]
 8000152:	bd10      	pop	{r4, pc}
 8000154:	2000001c 	.word	0x2000001c
 8000158:	00000000 	.word	0x00000000
 800015c:	08003688 	.word	0x08003688

08000160 <frame_dummy>:
 8000160:	b508      	push	{r3, lr}
 8000162:	4b03      	ldr	r3, [pc, #12]	; (8000170 <frame_dummy+0x10>)
 8000164:	b11b      	cbz	r3, 800016e <frame_dummy+0xe>
 8000166:	4903      	ldr	r1, [pc, #12]	; (8000174 <frame_dummy+0x14>)
 8000168:	4803      	ldr	r0, [pc, #12]	; (8000178 <frame_dummy+0x18>)
 800016a:	f3af 8000 	nop.w
 800016e:	bd08      	pop	{r3, pc}
 8000170:	00000000 	.word	0x00000000
 8000174:	20000020 	.word	0x20000020
 8000178:	08003688 	.word	0x08003688

0800017c <strlen>:
 800017c:	4603      	mov	r3, r0
 800017e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000182:	2a00      	cmp	r2, #0
 8000184:	d1fb      	bne.n	800017e <strlen+0x2>
 8000186:	1a18      	subs	r0, r3, r0
 8000188:	3801      	subs	r0, #1
 800018a:	4770      	bx	lr

0800018c <NVIC_PriorityGroupConfig>:
  *     @arg NVIC_PriorityGroup_4: 4 bits for preemption priority.
  *                                0 bits for subpriority.
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 800018c:	b480      	push	{r7}
 800018e:	b083      	sub	sp, #12
 8000190:	af00      	add	r7, sp, #0
 8000192:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8000194:	4a05      	ldr	r2, [pc, #20]	; (80001ac <NVIC_PriorityGroupConfig+0x20>)
 8000196:	687b      	ldr	r3, [r7, #4]
 8000198:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800019c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80001a0:	60d3      	str	r3, [r2, #12]
}
 80001a2:	bf00      	nop
 80001a4:	370c      	adds	r7, #12
 80001a6:	46bd      	mov	sp, r7
 80001a8:	bc80      	pop	{r7}
 80001aa:	4770      	bx	lr
 80001ac:	e000ed00 	.word	0xe000ed00

080001b0 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 80001b0:	b480      	push	{r7}
 80001b2:	b085      	sub	sp, #20
 80001b4:	af00      	add	r7, sp, #0
 80001b6:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 80001b8:	2300      	movs	r3, #0
 80001ba:	73fb      	strb	r3, [r7, #15]
 80001bc:	2300      	movs	r3, #0
 80001be:	73bb      	strb	r3, [r7, #14]
 80001c0:	230f      	movs	r3, #15
 80001c2:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 80001c4:	687b      	ldr	r3, [r7, #4]
 80001c6:	78db      	ldrb	r3, [r3, #3]
 80001c8:	2b00      	cmp	r3, #0
 80001ca:	d038      	beq.n	800023e <NVIC_Init+0x8e>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80001cc:	4b26      	ldr	r3, [pc, #152]	; (8000268 <NVIC_Init+0xb8>)
 80001ce:	68db      	ldr	r3, [r3, #12]
 80001d0:	43db      	mvns	r3, r3
 80001d2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80001d6:	0a1b      	lsrs	r3, r3, #8
 80001d8:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 80001da:	7bfb      	ldrb	r3, [r7, #15]
 80001dc:	f1c3 0304 	rsb	r3, r3, #4
 80001e0:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 80001e2:	7b7a      	ldrb	r2, [r7, #13]
 80001e4:	7bfb      	ldrb	r3, [r7, #15]
 80001e6:	fa42 f303 	asr.w	r3, r2, r3
 80001ea:	737b      	strb	r3, [r7, #13]

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 80001ec:	687b      	ldr	r3, [r7, #4]
 80001ee:	785b      	ldrb	r3, [r3, #1]
 80001f0:	461a      	mov	r2, r3
 80001f2:	7bbb      	ldrb	r3, [r7, #14]
 80001f4:	fa02 f303 	lsl.w	r3, r2, r3
 80001f8:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 80001fa:	687b      	ldr	r3, [r7, #4]
 80001fc:	789a      	ldrb	r2, [r3, #2]
 80001fe:	7b7b      	ldrb	r3, [r7, #13]
 8000200:	4013      	ands	r3, r2
 8000202:	b2da      	uxtb	r2, r3
 8000204:	7bfb      	ldrb	r3, [r7, #15]
 8000206:	4313      	orrs	r3, r2
 8000208:	73fb      	strb	r3, [r7, #15]
    tmppriority = tmppriority << 0x04;
 800020a:	7bfb      	ldrb	r3, [r7, #15]
 800020c:	011b      	lsls	r3, r3, #4
 800020e:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000210:	4a16      	ldr	r2, [pc, #88]	; (800026c <NVIC_Init+0xbc>)
 8000212:	687b      	ldr	r3, [r7, #4]
 8000214:	781b      	ldrb	r3, [r3, #0]
 8000216:	4413      	add	r3, r2
 8000218:	7bfa      	ldrb	r2, [r7, #15]
 800021a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800021e:	4a13      	ldr	r2, [pc, #76]	; (800026c <NVIC_Init+0xbc>)
 8000220:	687b      	ldr	r3, [r7, #4]
 8000222:	781b      	ldrb	r3, [r3, #0]
 8000224:	095b      	lsrs	r3, r3, #5
 8000226:	b2db      	uxtb	r3, r3
 8000228:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800022a:	687b      	ldr	r3, [r7, #4]
 800022c:	781b      	ldrb	r3, [r3, #0]
 800022e:	f003 031f 	and.w	r3, r3, #31
 8000232:	2101      	movs	r1, #1
 8000234:	fa01 f303 	lsl.w	r3, r1, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000238:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 800023c:	e00f      	b.n	800025e <NVIC_Init+0xae>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800023e:	490b      	ldr	r1, [pc, #44]	; (800026c <NVIC_Init+0xbc>)
 8000240:	687b      	ldr	r3, [r7, #4]
 8000242:	781b      	ldrb	r3, [r3, #0]
 8000244:	095b      	lsrs	r3, r3, #5
 8000246:	b2db      	uxtb	r3, r3
 8000248:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800024a:	687b      	ldr	r3, [r7, #4]
 800024c:	781b      	ldrb	r3, [r3, #0]
 800024e:	f003 031f 	and.w	r3, r3, #31
 8000252:	2201      	movs	r2, #1
 8000254:	409a      	lsls	r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000256:	f100 0320 	add.w	r3, r0, #32
 800025a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 800025e:	bf00      	nop
 8000260:	3714      	adds	r7, #20
 8000262:	46bd      	mov	sp, r7
 8000264:	bc80      	pop	{r7}
 8000266:	4770      	bx	lr
 8000268:	e000ed00 	.word	0xe000ed00
 800026c:	e000e100 	.word	0xe000e100

08000270 <FLASH_Unlock>:
  * @brief  Unlocks the FLASH control register and program memory access.
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
 8000270:	b580      	push	{r7, lr}
 8000272:	af00      	add	r7, sp, #0
  if((FLASH->PECR & FLASH_PECR_PRGLOCK) != RESET)
 8000274:	4b07      	ldr	r3, [pc, #28]	; (8000294 <FLASH_Unlock+0x24>)
 8000276:	685b      	ldr	r3, [r3, #4]
 8000278:	f003 0302 	and.w	r3, r3, #2
 800027c:	2b00      	cmp	r3, #0
 800027e:	d007      	beq.n	8000290 <FLASH_Unlock+0x20>
  {
    /* Unlocking the data memory and FLASH_PECR register access */
    DATA_EEPROM_Unlock();
 8000280:	f000 f81c 	bl	80002bc <DATA_EEPROM_Unlock>
  
    /* Unlocking the program memory access */
    FLASH->PRGKEYR = FLASH_PRGKEY1;
 8000284:	4b03      	ldr	r3, [pc, #12]	; (8000294 <FLASH_Unlock+0x24>)
 8000286:	4a04      	ldr	r2, [pc, #16]	; (8000298 <FLASH_Unlock+0x28>)
 8000288:	611a      	str	r2, [r3, #16]
    FLASH->PRGKEYR = FLASH_PRGKEY2;  
 800028a:	4b02      	ldr	r3, [pc, #8]	; (8000294 <FLASH_Unlock+0x24>)
 800028c:	4a03      	ldr	r2, [pc, #12]	; (800029c <FLASH_Unlock+0x2c>)
 800028e:	611a      	str	r2, [r3, #16]
  }
}
 8000290:	bf00      	nop
 8000292:	bd80      	pop	{r7, pc}
 8000294:	40023c00 	.word	0x40023c00
 8000298:	8c9daebf 	.word	0x8c9daebf
 800029c:	13141516 	.word	0x13141516

080002a0 <FLASH_Lock>:
  * @brief  Locks the Program memory access.
  * @param  None
  * @retval None
  */
void FLASH_Lock(void)
{
 80002a0:	b480      	push	{r7}
 80002a2:	af00      	add	r7, sp, #0
  /* Set the PRGLOCK Bit to lock the program memory access */
  FLASH->PECR |= FLASH_PECR_PRGLOCK;
 80002a4:	4a04      	ldr	r2, [pc, #16]	; (80002b8 <FLASH_Lock+0x18>)
 80002a6:	4b04      	ldr	r3, [pc, #16]	; (80002b8 <FLASH_Lock+0x18>)
 80002a8:	685b      	ldr	r3, [r3, #4]
 80002aa:	f043 0302 	orr.w	r3, r3, #2
 80002ae:	6053      	str	r3, [r2, #4]
}
 80002b0:	bf00      	nop
 80002b2:	46bd      	mov	sp, r7
 80002b4:	bc80      	pop	{r7}
 80002b6:	4770      	bx	lr
 80002b8:	40023c00 	.word	0x40023c00

080002bc <DATA_EEPROM_Unlock>:
  * @brief  Unlocks the data memory and FLASH_PECR register access.
  * @param  None
  * @retval None
  */
void DATA_EEPROM_Unlock(void)
{
 80002bc:	b480      	push	{r7}
 80002be:	af00      	add	r7, sp, #0
  if((FLASH->PECR & FLASH_PECR_PELOCK) != RESET)
 80002c0:	4b07      	ldr	r3, [pc, #28]	; (80002e0 <DATA_EEPROM_Unlock+0x24>)
 80002c2:	685b      	ldr	r3, [r3, #4]
 80002c4:	f003 0301 	and.w	r3, r3, #1
 80002c8:	2b00      	cmp	r3, #0
 80002ca:	d005      	beq.n	80002d8 <DATA_EEPROM_Unlock+0x1c>
  {  
    /* Unlocking the Data memory and FLASH_PECR register access*/
    FLASH->PEKEYR = FLASH_PEKEY1;
 80002cc:	4b04      	ldr	r3, [pc, #16]	; (80002e0 <DATA_EEPROM_Unlock+0x24>)
 80002ce:	4a05      	ldr	r2, [pc, #20]	; (80002e4 <DATA_EEPROM_Unlock+0x28>)
 80002d0:	60da      	str	r2, [r3, #12]
    FLASH->PEKEYR = FLASH_PEKEY2;
 80002d2:	4b03      	ldr	r3, [pc, #12]	; (80002e0 <DATA_EEPROM_Unlock+0x24>)
 80002d4:	4a04      	ldr	r2, [pc, #16]	; (80002e8 <DATA_EEPROM_Unlock+0x2c>)
 80002d6:	60da      	str	r2, [r3, #12]
  }
}
 80002d8:	bf00      	nop
 80002da:	46bd      	mov	sp, r7
 80002dc:	bc80      	pop	{r7}
 80002de:	4770      	bx	lr
 80002e0:	40023c00 	.word	0x40023c00
 80002e4:	89abcdef 	.word	0x89abcdef
 80002e8:	02030405 	.word	0x02030405

080002ec <DATA_EEPROM_EraseByte>:
  *         the DATA_EEPROM against possible unwanted operation).
  * @retval FLASH Status: The returned value can be: 
  *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status DATA_EEPROM_EraseByte(uint32_t Address)
{
 80002ec:	b580      	push	{r7, lr}
 80002ee:	b084      	sub	sp, #16
 80002f0:	af00      	add	r7, sp, #0
 80002f2:	6078      	str	r0, [r7, #4]
  FLASH_Status status = FLASH_COMPLETE;
 80002f4:	2304      	movs	r3, #4
 80002f6:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_FLASH_DATA_ADDRESS(Address));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 80002f8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80002fc:	f000 f858 	bl	80003b0 <FLASH_WaitForLastOperation>
 8000300:	4603      	mov	r3, r0
 8000302:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 8000304:	7bfb      	ldrb	r3, [r7, #15]
 8000306:	2b04      	cmp	r3, #4
 8000308:	d102      	bne.n	8000310 <DATA_EEPROM_EraseByte+0x24>
  {
    /* Write "00h" to valid address in the data memory" */
    *(__IO uint8_t *) Address = (uint8_t)0x00;
 800030a:	687b      	ldr	r3, [r7, #4]
 800030c:	2200      	movs	r2, #0
 800030e:	701a      	strb	r2, [r3, #0]
  }
   
  /* Return the erase status */
  return status;
 8000310:	7bfb      	ldrb	r3, [r7, #15]
}
 8000312:	4618      	mov	r0, r3
 8000314:	3710      	adds	r7, #16
 8000316:	46bd      	mov	sp, r7
 8000318:	bd80      	pop	{r7, pc}
 800031a:	bf00      	nop

0800031c <DATA_EEPROM_ProgramByte>:
  * @param  Data: specifies the data to be written.
  * @retval FLASH Status: The returned value can be: 
  *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
  */
FLASH_Status DATA_EEPROM_ProgramByte(uint32_t Address, uint8_t Data)
{
 800031c:	b580      	push	{r7, lr}
 800031e:	b084      	sub	sp, #16
 8000320:	af00      	add	r7, sp, #0
 8000322:	6078      	str	r0, [r7, #4]
 8000324:	460b      	mov	r3, r1
 8000326:	70fb      	strb	r3, [r7, #3]
  FLASH_Status status = FLASH_COMPLETE;
 8000328:	2304      	movs	r3, #4
 800032a:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_FLASH_DATA_ADDRESS(Address)); 

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 800032c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8000330:	f000 f83e 	bl	80003b0 <FLASH_WaitForLastOperation>
 8000334:	4603      	mov	r3, r0
 8000336:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 8000338:	7bfb      	ldrb	r3, [r7, #15]
 800033a:	2b04      	cmp	r3, #4
 800033c:	d108      	bne.n	8000350 <DATA_EEPROM_ProgramByte+0x34>
      tmp &= ~tmpaddr;        
      status = DATA_EEPROM_EraseWord(Address & 0xFFFFFFFC);
      status = DATA_EEPROM_FastProgramWord((Address & 0xFFFFFFFC), tmp);
    }
#elif defined (STM32L1XX_HD) || defined (STM32L1XX_MDP)
    *(__IO uint8_t *)Address = Data;
 800033e:	687b      	ldr	r3, [r7, #4]
 8000340:	78fa      	ldrb	r2, [r7, #3]
 8000342:	701a      	strb	r2, [r3, #0]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
 8000344:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8000348:	f000 f832 	bl	80003b0 <FLASH_WaitForLastOperation>
 800034c:	4603      	mov	r3, r0
 800034e:	73fb      	strb	r3, [r7, #15]
#endif
  }
  /* Return the Write Status */
  return status;
 8000350:	7bfb      	ldrb	r3, [r7, #15]
}
 8000352:	4618      	mov	r0, r3
 8000354:	3710      	adds	r7, #16
 8000356:	46bd      	mov	sp, r7
 8000358:	bd80      	pop	{r7, pc}
 800035a:	bf00      	nop

0800035c <FLASH_GetStatus>:
  * @param  None
  * @retval FLASH Status: The returned value can be: 
  *   FLASH_BUSY, FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP or FLASH_COMPLETE.
  */
FLASH_Status FLASH_GetStatus(void)
{
 800035c:	b480      	push	{r7}
 800035e:	b083      	sub	sp, #12
 8000360:	af00      	add	r7, sp, #0
  FLASH_Status FLASHstatus = FLASH_COMPLETE;
 8000362:	2304      	movs	r3, #4
 8000364:	71fb      	strb	r3, [r7, #7]
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8000366:	4b11      	ldr	r3, [pc, #68]	; (80003ac <FLASH_GetStatus+0x50>)
 8000368:	699b      	ldr	r3, [r3, #24]
 800036a:	f003 0301 	and.w	r3, r3, #1
 800036e:	2b00      	cmp	r3, #0
 8000370:	d002      	beq.n	8000378 <FLASH_GetStatus+0x1c>
  {
    FLASHstatus = FLASH_BUSY;
 8000372:	2301      	movs	r3, #1
 8000374:	71fb      	strb	r3, [r7, #7]
 8000376:	e013      	b.n	80003a0 <FLASH_GetStatus+0x44>
  }
  else 
  {  
    if((FLASH->SR & (uint32_t)FLASH_FLAG_WRPERR)!= (uint32_t)0x00)
 8000378:	4b0c      	ldr	r3, [pc, #48]	; (80003ac <FLASH_GetStatus+0x50>)
 800037a:	699b      	ldr	r3, [r3, #24]
 800037c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8000380:	2b00      	cmp	r3, #0
 8000382:	d002      	beq.n	800038a <FLASH_GetStatus+0x2e>
    { 
      FLASHstatus = FLASH_ERROR_WRP;
 8000384:	2302      	movs	r3, #2
 8000386:	71fb      	strb	r3, [r7, #7]
 8000388:	e00a      	b.n	80003a0 <FLASH_GetStatus+0x44>
    }
    else 
    {
      if((FLASH->SR & (uint32_t)0x1E00) != (uint32_t)0x00)
 800038a:	4b08      	ldr	r3, [pc, #32]	; (80003ac <FLASH_GetStatus+0x50>)
 800038c:	699b      	ldr	r3, [r3, #24]
 800038e:	f403 53f0 	and.w	r3, r3, #7680	; 0x1e00
 8000392:	2b00      	cmp	r3, #0
 8000394:	d002      	beq.n	800039c <FLASH_GetStatus+0x40>
      {
        FLASHstatus = FLASH_ERROR_PROGRAM; 
 8000396:	2303      	movs	r3, #3
 8000398:	71fb      	strb	r3, [r7, #7]
 800039a:	e001      	b.n	80003a0 <FLASH_GetStatus+0x44>
      }
      else
      {
        FLASHstatus = FLASH_COMPLETE;
 800039c:	2304      	movs	r3, #4
 800039e:	71fb      	strb	r3, [r7, #7]
      }
    }
  }
  /* Return the FLASH Status */
  return FLASHstatus;
 80003a0:	79fb      	ldrb	r3, [r7, #7]
}
 80003a2:	4618      	mov	r0, r3
 80003a4:	370c      	adds	r7, #12
 80003a6:	46bd      	mov	sp, r7
 80003a8:	bc80      	pop	{r7}
 80003aa:	4770      	bx	lr
 80003ac:	40023c00 	.word	0x40023c00

080003b0 <FLASH_WaitForLastOperation>:
  * @param  Timeout: FLASH programming Timeout.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, 
  *   FLASH_ERROR_PROGRAM, FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 80003b0:	b580      	push	{r7, lr}
 80003b2:	b084      	sub	sp, #16
 80003b4:	af00      	add	r7, sp, #0
 80003b6:	6078      	str	r0, [r7, #4]
  __IO FLASH_Status status = FLASH_COMPLETE;
 80003b8:	2304      	movs	r3, #4
 80003ba:	73fb      	strb	r3, [r7, #15]
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
 80003bc:	f7ff ffce 	bl	800035c <FLASH_GetStatus>
 80003c0:	4603      	mov	r3, r0
 80003c2:	73fb      	strb	r3, [r7, #15]
  
  /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80003c4:	e006      	b.n	80003d4 <FLASH_WaitForLastOperation+0x24>
  {
    status = FLASH_GetStatus();
 80003c6:	f7ff ffc9 	bl	800035c <FLASH_GetStatus>
 80003ca:	4603      	mov	r3, r0
 80003cc:	73fb      	strb	r3, [r7, #15]
    Timeout--;
 80003ce:	687b      	ldr	r3, [r7, #4]
 80003d0:	3b01      	subs	r3, #1
 80003d2:	607b      	str	r3, [r7, #4]
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
  
  /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 80003d4:	7bfb      	ldrb	r3, [r7, #15]
 80003d6:	b2db      	uxtb	r3, r3
 80003d8:	2b01      	cmp	r3, #1
 80003da:	d102      	bne.n	80003e2 <FLASH_WaitForLastOperation+0x32>
 80003dc:	687b      	ldr	r3, [r7, #4]
 80003de:	2b00      	cmp	r3, #0
 80003e0:	d1f1      	bne.n	80003c6 <FLASH_WaitForLastOperation+0x16>
  {
    status = FLASH_GetStatus();
    Timeout--;
  }
  
  if(Timeout == 0x00 )
 80003e2:	687b      	ldr	r3, [r7, #4]
 80003e4:	2b00      	cmp	r3, #0
 80003e6:	d101      	bne.n	80003ec <FLASH_WaitForLastOperation+0x3c>
  {
    status = FLASH_TIMEOUT;
 80003e8:	2305      	movs	r3, #5
 80003ea:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the operation status */
  return status;
 80003ec:	7bfb      	ldrb	r3, [r7, #15]
 80003ee:	b2db      	uxtb	r3, r3
}
 80003f0:	4618      	mov	r0, r3
 80003f2:	3710      	adds	r7, #16
 80003f4:	46bd      	mov	sp, r7
 80003f6:	bd80      	pop	{r7, pc}

080003f8 <GPIO_Init>:
  *         peripheral.

  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80003f8:	b480      	push	{r7}
 80003fa:	b087      	sub	sp, #28
 80003fc:	af00      	add	r7, sp, #0
 80003fe:	6078      	str	r0, [r7, #4]
 8000400:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 8000402:	2300      	movs	r3, #0
 8000404:	617b      	str	r3, [r7, #20]
 8000406:	2300      	movs	r3, #0
 8000408:	613b      	str	r3, [r7, #16]
 800040a:	2300      	movs	r3, #0
 800040c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800040e:	2300      	movs	r3, #0
 8000410:	617b      	str	r3, [r7, #20]
 8000412:	e07e      	b.n	8000512 <GPIO_Init+0x11a>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8000414:	2201      	movs	r2, #1
 8000416:	697b      	ldr	r3, [r7, #20]
 8000418:	fa02 f303 	lsl.w	r3, r2, r3
 800041c:	613b      	str	r3, [r7, #16]

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800041e:	683b      	ldr	r3, [r7, #0]
 8000420:	681a      	ldr	r2, [r3, #0]
 8000422:	693b      	ldr	r3, [r7, #16]
 8000424:	4013      	ands	r3, r2
 8000426:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 8000428:	68fa      	ldr	r2, [r7, #12]
 800042a:	693b      	ldr	r3, [r7, #16]
 800042c:	429a      	cmp	r2, r3
 800042e:	d16d      	bne.n	800050c <GPIO_Init+0x114>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8000430:	687b      	ldr	r3, [r7, #4]
 8000432:	681a      	ldr	r2, [r3, #0]
 8000434:	697b      	ldr	r3, [r7, #20]
 8000436:	005b      	lsls	r3, r3, #1
 8000438:	2103      	movs	r1, #3
 800043a:	fa01 f303 	lsl.w	r3, r1, r3
 800043e:	43db      	mvns	r3, r3
 8000440:	401a      	ands	r2, r3
 8000442:	687b      	ldr	r3, [r7, #4]
 8000444:	601a      	str	r2, [r3, #0]

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8000446:	687b      	ldr	r3, [r7, #4]
 8000448:	681a      	ldr	r2, [r3, #0]
 800044a:	683b      	ldr	r3, [r7, #0]
 800044c:	791b      	ldrb	r3, [r3, #4]
 800044e:	4619      	mov	r1, r3
 8000450:	697b      	ldr	r3, [r7, #20]
 8000452:	005b      	lsls	r3, r3, #1
 8000454:	fa01 f303 	lsl.w	r3, r1, r3
 8000458:	431a      	orrs	r2, r3
 800045a:	687b      	ldr	r3, [r7, #4]
 800045c:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800045e:	683b      	ldr	r3, [r7, #0]
 8000460:	791b      	ldrb	r3, [r3, #4]
 8000462:	2b01      	cmp	r3, #1
 8000464:	d003      	beq.n	800046e <GPIO_Init+0x76>
 8000466:	683b      	ldr	r3, [r7, #0]
 8000468:	791b      	ldrb	r3, [r3, #4]
 800046a:	2b02      	cmp	r3, #2
 800046c:	d136      	bne.n	80004dc <GPIO_Init+0xe4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800046e:	687b      	ldr	r3, [r7, #4]
 8000470:	689a      	ldr	r2, [r3, #8]
 8000472:	697b      	ldr	r3, [r7, #20]
 8000474:	005b      	lsls	r3, r3, #1
 8000476:	2103      	movs	r1, #3
 8000478:	fa01 f303 	lsl.w	r3, r1, r3
 800047c:	43db      	mvns	r3, r3
 800047e:	401a      	ands	r2, r3
 8000480:	687b      	ldr	r3, [r7, #4]
 8000482:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8000484:	687b      	ldr	r3, [r7, #4]
 8000486:	689a      	ldr	r2, [r3, #8]
 8000488:	683b      	ldr	r3, [r7, #0]
 800048a:	795b      	ldrb	r3, [r3, #5]
 800048c:	4619      	mov	r1, r3
 800048e:	697b      	ldr	r3, [r7, #20]
 8000490:	005b      	lsls	r3, r3, #1
 8000492:	fa01 f303 	lsl.w	r3, r1, r3
 8000496:	431a      	orrs	r2, r3
 8000498:	687b      	ldr	r3, [r7, #4]
 800049a:	609a      	str	r2, [r3, #8]

        /*Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration */
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800049c:	687b      	ldr	r3, [r7, #4]
 800049e:	889b      	ldrh	r3, [r3, #4]
 80004a0:	b29a      	uxth	r2, r3
 80004a2:	697b      	ldr	r3, [r7, #20]
 80004a4:	b29b      	uxth	r3, r3
 80004a6:	2101      	movs	r1, #1
 80004a8:	fa01 f303 	lsl.w	r3, r1, r3
 80004ac:	b29b      	uxth	r3, r3
 80004ae:	43db      	mvns	r3, r3
 80004b0:	b29b      	uxth	r3, r3
 80004b2:	4013      	ands	r3, r2
 80004b4:	b29a      	uxth	r2, r3
 80004b6:	687b      	ldr	r3, [r7, #4]
 80004b8:	809a      	strh	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80004ba:	687b      	ldr	r3, [r7, #4]
 80004bc:	889b      	ldrh	r3, [r3, #4]
 80004be:	b29b      	uxth	r3, r3
 80004c0:	b21a      	sxth	r2, r3
 80004c2:	683b      	ldr	r3, [r7, #0]
 80004c4:	799b      	ldrb	r3, [r3, #6]
 80004c6:	4619      	mov	r1, r3
 80004c8:	697b      	ldr	r3, [r7, #20]
 80004ca:	b29b      	uxth	r3, r3
 80004cc:	fa01 f303 	lsl.w	r3, r1, r3
 80004d0:	b21b      	sxth	r3, r3
 80004d2:	4313      	orrs	r3, r2
 80004d4:	b21b      	sxth	r3, r3
 80004d6:	b29a      	uxth	r2, r3
 80004d8:	687b      	ldr	r3, [r7, #4]
 80004da:	809a      	strh	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80004dc:	687b      	ldr	r3, [r7, #4]
 80004de:	68da      	ldr	r2, [r3, #12]
 80004e0:	697b      	ldr	r3, [r7, #20]
 80004e2:	b29b      	uxth	r3, r3
 80004e4:	005b      	lsls	r3, r3, #1
 80004e6:	2103      	movs	r1, #3
 80004e8:	fa01 f303 	lsl.w	r3, r1, r3
 80004ec:	43db      	mvns	r3, r3
 80004ee:	401a      	ands	r2, r3
 80004f0:	687b      	ldr	r3, [r7, #4]
 80004f2:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80004f4:	687b      	ldr	r3, [r7, #4]
 80004f6:	68da      	ldr	r2, [r3, #12]
 80004f8:	683b      	ldr	r3, [r7, #0]
 80004fa:	79db      	ldrb	r3, [r3, #7]
 80004fc:	4619      	mov	r1, r3
 80004fe:	697b      	ldr	r3, [r7, #20]
 8000500:	005b      	lsls	r3, r3, #1
 8000502:	fa01 f303 	lsl.w	r3, r1, r3
 8000506:	431a      	orrs	r2, r3
 8000508:	687b      	ldr	r3, [r7, #4]
 800050a:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800050c:	697b      	ldr	r3, [r7, #20]
 800050e:	3301      	adds	r3, #1
 8000510:	617b      	str	r3, [r7, #20]
 8000512:	697b      	ldr	r3, [r7, #20]
 8000514:	2b0f      	cmp	r3, #15
 8000516:	f67f af7d 	bls.w	8000414 <GPIO_Init+0x1c>
      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 800051a:	bf00      	nop
 800051c:	371c      	adds	r7, #28
 800051e:	46bd      	mov	sp, r7
 8000520:	bc80      	pop	{r7}
 8000522:	4770      	bx	lr

08000524 <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *   This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000524:	b480      	push	{r7}
 8000526:	b085      	sub	sp, #20
 8000528:	af00      	add	r7, sp, #0
 800052a:	6078      	str	r0, [r7, #4]
 800052c:	460b      	mov	r3, r1
 800052e:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 8000530:	2300      	movs	r3, #0
 8000532:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8000534:	687b      	ldr	r3, [r7, #4]
 8000536:	8a1b      	ldrh	r3, [r3, #16]
 8000538:	b29a      	uxth	r2, r3
 800053a:	887b      	ldrh	r3, [r7, #2]
 800053c:	4013      	ands	r3, r2
 800053e:	b29b      	uxth	r3, r3
 8000540:	2b00      	cmp	r3, #0
 8000542:	d002      	beq.n	800054a <GPIO_ReadInputDataBit+0x26>
  {
    bitstatus = (uint8_t)Bit_SET;
 8000544:	2301      	movs	r3, #1
 8000546:	73fb      	strb	r3, [r7, #15]
 8000548:	e001      	b.n	800054e <GPIO_ReadInputDataBit+0x2a>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 800054a:	2300      	movs	r3, #0
 800054c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800054e:	7bfb      	ldrb	r3, [r7, #15]
}
 8000550:	4618      	mov	r0, r3
 8000552:	3714      	adds	r7, #20
 8000554:	46bd      	mov	sp, r7
 8000556:	bc80      	pop	{r7}
 8000558:	4770      	bx	lr
 800055a:	bf00      	nop

0800055c <GPIO_SetBits>:
  *        accesses. In this way, there is no risk of an IRQ occurring between
  *        the read and the modify access.
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800055c:	b480      	push	{r7}
 800055e:	b083      	sub	sp, #12
 8000560:	af00      	add	r7, sp, #0
 8000562:	6078      	str	r0, [r7, #4]
 8000564:	460b      	mov	r3, r1
 8000566:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRRL = GPIO_Pin;
 8000568:	687b      	ldr	r3, [r7, #4]
 800056a:	887a      	ldrh	r2, [r7, #2]
 800056c:	831a      	strh	r2, [r3, #24]
}
 800056e:	bf00      	nop
 8000570:	370c      	adds	r7, #12
 8000572:	46bd      	mov	sp, r7
 8000574:	bc80      	pop	{r7}
 8000576:	4770      	bx	lr

08000578 <GPIO_ResetBits>:
  *        accesses. In this way, there is no risk of an IRQ occurring between
  *        the read and the modify access.
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000578:	b480      	push	{r7}
 800057a:	b083      	sub	sp, #12
 800057c:	af00      	add	r7, sp, #0
 800057e:	6078      	str	r0, [r7, #4]
 8000580:	460b      	mov	r3, r1
 8000582:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRRH = GPIO_Pin;
 8000584:	687b      	ldr	r3, [r7, #4]
 8000586:	887a      	ldrh	r2, [r7, #2]
 8000588:	835a      	strh	r2, [r3, #26]
}
 800058a:	bf00      	nop
 800058c:	370c      	adds	r7, #12
 800058e:	46bd      	mov	sp, r7
 8000590:	bc80      	pop	{r7}
 8000592:	4770      	bx	lr

08000594 <GPIO_ToggleBits>:
  * @param  GPIOx: where x can be (A..H) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000594:	b480      	push	{r7}
 8000596:	b083      	sub	sp, #12
 8000598:	af00      	add	r7, sp, #0
 800059a:	6078      	str	r0, [r7, #4]
 800059c:	460b      	mov	r3, r1
 800059e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 80005a0:	687b      	ldr	r3, [r7, #4]
 80005a2:	8a9b      	ldrh	r3, [r3, #20]
 80005a4:	b29a      	uxth	r2, r3
 80005a6:	887b      	ldrh	r3, [r7, #2]
 80005a8:	4053      	eors	r3, r2
 80005aa:	b29a      	uxth	r2, r3
 80005ac:	687b      	ldr	r3, [r7, #4]
 80005ae:	829a      	strh	r2, [r3, #20]
}
 80005b0:	bf00      	nop
 80005b2:	370c      	adds	r7, #12
 80005b4:	46bd      	mov	sp, r7
 80005b6:	bc80      	pop	{r7}
 80005b8:	4770      	bx	lr
 80005ba:	bf00      	nop

080005bc <GPIO_PinAFConfig>:
  *        alternate function I/O pins.  
  * @note EVENTOUT is not mapped on PH0, PH1 and PH2.  
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 80005bc:	b480      	push	{r7}
 80005be:	b085      	sub	sp, #20
 80005c0:	af00      	add	r7, sp, #0
 80005c2:	6078      	str	r0, [r7, #4]
 80005c4:	460b      	mov	r3, r1
 80005c6:	807b      	strh	r3, [r7, #2]
 80005c8:	4613      	mov	r3, r2
 80005ca:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 80005cc:	2300      	movs	r3, #0
 80005ce:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 80005d0:	2300      	movs	r3, #0
 80005d2:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80005d4:	787a      	ldrb	r2, [r7, #1]
 80005d6:	887b      	ldrh	r3, [r7, #2]
 80005d8:	f003 0307 	and.w	r3, r3, #7
 80005dc:	009b      	lsls	r3, r3, #2
 80005de:	fa02 f303 	lsl.w	r3, r2, r3
 80005e2:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80005e4:	887b      	ldrh	r3, [r7, #2]
 80005e6:	08db      	lsrs	r3, r3, #3
 80005e8:	b29b      	uxth	r3, r3
 80005ea:	4618      	mov	r0, r3
 80005ec:	887b      	ldrh	r3, [r7, #2]
 80005ee:	08db      	lsrs	r3, r3, #3
 80005f0:	b29b      	uxth	r3, r3
 80005f2:	461a      	mov	r2, r3
 80005f4:	687b      	ldr	r3, [r7, #4]
 80005f6:	3208      	adds	r2, #8
 80005f8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80005fc:	887b      	ldrh	r3, [r7, #2]
 80005fe:	f003 0307 	and.w	r3, r3, #7
 8000602:	009b      	lsls	r3, r3, #2
 8000604:	210f      	movs	r1, #15
 8000606:	fa01 f303 	lsl.w	r3, r1, r3
 800060a:	43db      	mvns	r3, r3
 800060c:	ea02 0103 	and.w	r1, r2, r3
 8000610:	687b      	ldr	r3, [r7, #4]
 8000612:	f100 0208 	add.w	r2, r0, #8
 8000616:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 800061a:	887b      	ldrh	r3, [r7, #2]
 800061c:	08db      	lsrs	r3, r3, #3
 800061e:	b29b      	uxth	r3, r3
 8000620:	461a      	mov	r2, r3
 8000622:	687b      	ldr	r3, [r7, #4]
 8000624:	3208      	adds	r2, #8
 8000626:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800062a:	68fb      	ldr	r3, [r7, #12]
 800062c:	4313      	orrs	r3, r2
 800062e:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8000630:	887b      	ldrh	r3, [r7, #2]
 8000632:	08db      	lsrs	r3, r3, #3
 8000634:	b29b      	uxth	r3, r3
 8000636:	461a      	mov	r2, r3
 8000638:	687b      	ldr	r3, [r7, #4]
 800063a:	3208      	adds	r2, #8
 800063c:	68b9      	ldr	r1, [r7, #8]
 800063e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8000642:	bf00      	nop
 8000644:	3714      	adds	r7, #20
 8000646:	46bd      	mov	sp, r7
 8000648:	bc80      	pop	{r7}
 800064a:	4770      	bx	lr

0800064c <RCC_GetClocksFreq>:
  *           configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 800064c:	b480      	push	{r7}
 800064e:	b089      	sub	sp, #36	; 0x24
 8000650:	af00      	add	r7, sp, #0
 8000652:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmul = 0, plldiv = 0, pllsource = 0, presc = 0, msirange = 0;
 8000654:	2300      	movs	r3, #0
 8000656:	61fb      	str	r3, [r7, #28]
 8000658:	2300      	movs	r3, #0
 800065a:	61bb      	str	r3, [r7, #24]
 800065c:	2300      	movs	r3, #0
 800065e:	617b      	str	r3, [r7, #20]
 8000660:	2300      	movs	r3, #0
 8000662:	613b      	str	r3, [r7, #16]
 8000664:	2300      	movs	r3, #0
 8000666:	60fb      	str	r3, [r7, #12]
 8000668:	2300      	movs	r3, #0
 800066a:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800066c:	4b5f      	ldr	r3, [pc, #380]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 800066e:	689b      	ldr	r3, [r3, #8]
 8000670:	f003 030c 	and.w	r3, r3, #12
 8000674:	61fb      	str	r3, [r7, #28]
  
  switch (tmp)
 8000676:	69fb      	ldr	r3, [r7, #28]
 8000678:	2b0c      	cmp	r3, #12
 800067a:	d865      	bhi.n	8000748 <RCC_GetClocksFreq+0xfc>
 800067c:	a201      	add	r2, pc, #4	; (adr r2, 8000684 <RCC_GetClocksFreq+0x38>)
 800067e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000682:	bf00      	nop
 8000684:	080006b9 	.word	0x080006b9
 8000688:	08000749 	.word	0x08000749
 800068c:	08000749 	.word	0x08000749
 8000690:	08000749 	.word	0x08000749
 8000694:	080006d9 	.word	0x080006d9
 8000698:	08000749 	.word	0x08000749
 800069c:	08000749 	.word	0x08000749
 80006a0:	08000749 	.word	0x08000749
 80006a4:	080006e1 	.word	0x080006e1
 80006a8:	08000749 	.word	0x08000749
 80006ac:	08000749 	.word	0x08000749
 80006b0:	08000749 	.word	0x08000749
 80006b4:	080006e9 	.word	0x080006e9
  {
    case 0x00:  /* MSI used as system clock */
      msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> 13;
 80006b8:	4b4c      	ldr	r3, [pc, #304]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 80006ba:	685b      	ldr	r3, [r3, #4]
 80006bc:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 80006c0:	0b5b      	lsrs	r3, r3, #13
 80006c2:	60bb      	str	r3, [r7, #8]
      RCC_Clocks->SYSCLK_Frequency = (32768 * (1 << (msirange + 1)));
 80006c4:	68bb      	ldr	r3, [r7, #8]
 80006c6:	3301      	adds	r3, #1
 80006c8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80006cc:	fa02 f303 	lsl.w	r3, r2, r3
 80006d0:	461a      	mov	r2, r3
 80006d2:	687b      	ldr	r3, [r7, #4]
 80006d4:	601a      	str	r2, [r3, #0]
      break;
 80006d6:	e047      	b.n	8000768 <RCC_GetClocksFreq+0x11c>
    case 0x04:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80006d8:	687b      	ldr	r3, [r7, #4]
 80006da:	4a45      	ldr	r2, [pc, #276]	; (80007f0 <RCC_GetClocksFreq+0x1a4>)
 80006dc:	601a      	str	r2, [r3, #0]
      break;
 80006de:	e043      	b.n	8000768 <RCC_GetClocksFreq+0x11c>
    case 0x08:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 80006e0:	687b      	ldr	r3, [r7, #4]
 80006e2:	4a44      	ldr	r2, [pc, #272]	; (80007f4 <RCC_GetClocksFreq+0x1a8>)
 80006e4:	601a      	str	r2, [r3, #0]
      break;
 80006e6:	e03f      	b.n	8000768 <RCC_GetClocksFreq+0x11c>
    case 0x0C:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
 80006e8:	4b40      	ldr	r3, [pc, #256]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 80006ea:	689b      	ldr	r3, [r3, #8]
 80006ec:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 80006f0:	61bb      	str	r3, [r7, #24]
      plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
 80006f2:	4b3e      	ldr	r3, [pc, #248]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 80006f4:	689b      	ldr	r3, [r3, #8]
 80006f6:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 80006fa:	617b      	str	r3, [r7, #20]
      pllmul = PLLMulTable[(pllmul >> 18)];
 80006fc:	69bb      	ldr	r3, [r7, #24]
 80006fe:	0c9b      	lsrs	r3, r3, #18
 8000700:	4a3d      	ldr	r2, [pc, #244]	; (80007f8 <RCC_GetClocksFreq+0x1ac>)
 8000702:	5cd3      	ldrb	r3, [r2, r3]
 8000704:	b2db      	uxtb	r3, r3
 8000706:	61bb      	str	r3, [r7, #24]
      plldiv = (plldiv >> 22) + 1;
 8000708:	697b      	ldr	r3, [r7, #20]
 800070a:	0d9b      	lsrs	r3, r3, #22
 800070c:	3301      	adds	r3, #1
 800070e:	617b      	str	r3, [r7, #20]
      
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8000710:	4b36      	ldr	r3, [pc, #216]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 8000712:	689b      	ldr	r3, [r3, #8]
 8000714:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000718:	613b      	str	r3, [r7, #16]

      if (pllsource == 0x00)
 800071a:	693b      	ldr	r3, [r7, #16]
 800071c:	2b00      	cmp	r3, #0
 800071e:	d109      	bne.n	8000734 <RCC_GetClocksFreq+0xe8>
      {
        /* HSI oscillator clock selected as PLL clock source */
        RCC_Clocks->SYSCLK_Frequency = (((HSI_VALUE) * pllmul) / plldiv);
 8000720:	69bb      	ldr	r3, [r7, #24]
 8000722:	4a33      	ldr	r2, [pc, #204]	; (80007f0 <RCC_GetClocksFreq+0x1a4>)
 8000724:	fb02 f203 	mul.w	r2, r2, r3
 8000728:	697b      	ldr	r3, [r7, #20]
 800072a:	fbb2 f2f3 	udiv	r2, r2, r3
 800072e:	687b      	ldr	r3, [r7, #4]
 8000730:	601a      	str	r2, [r3, #0]
      else
      {
        /* HSE selected as PLL clock source */
        RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE) * pllmul) / plldiv);
      }
      break;
 8000732:	e019      	b.n	8000768 <RCC_GetClocksFreq+0x11c>
        RCC_Clocks->SYSCLK_Frequency = (((HSI_VALUE) * pllmul) / plldiv);
      }
      else
      {
        /* HSE selected as PLL clock source */
        RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE) * pllmul) / plldiv);
 8000734:	69bb      	ldr	r3, [r7, #24]
 8000736:	4a2f      	ldr	r2, [pc, #188]	; (80007f4 <RCC_GetClocksFreq+0x1a8>)
 8000738:	fb02 f203 	mul.w	r2, r2, r3
 800073c:	697b      	ldr	r3, [r7, #20]
 800073e:	fbb2 f2f3 	udiv	r2, r2, r3
 8000742:	687b      	ldr	r3, [r7, #4]
 8000744:	601a      	str	r2, [r3, #0]
      }
      break;
 8000746:	e00f      	b.n	8000768 <RCC_GetClocksFreq+0x11c>
    default: /* MSI used as system clock */
      msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> 13;
 8000748:	4b28      	ldr	r3, [pc, #160]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 800074a:	685b      	ldr	r3, [r3, #4]
 800074c:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8000750:	0b5b      	lsrs	r3, r3, #13
 8000752:	60bb      	str	r3, [r7, #8]
      RCC_Clocks->SYSCLK_Frequency = (32768 * (1 << (msirange + 1)));
 8000754:	68bb      	ldr	r3, [r7, #8]
 8000756:	3301      	adds	r3, #1
 8000758:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800075c:	fa02 f303 	lsl.w	r3, r2, r3
 8000760:	461a      	mov	r2, r3
 8000762:	687b      	ldr	r3, [r7, #4]
 8000764:	601a      	str	r2, [r3, #0]
      break;
 8000766:	bf00      	nop
  }
  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8000768:	4b20      	ldr	r3, [pc, #128]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 800076a:	689b      	ldr	r3, [r3, #8]
 800076c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8000770:	61fb      	str	r3, [r7, #28]
  tmp = tmp >> 4;
 8000772:	69fb      	ldr	r3, [r7, #28]
 8000774:	091b      	lsrs	r3, r3, #4
 8000776:	61fb      	str	r3, [r7, #28]
  presc = APBAHBPrescTable[tmp]; 
 8000778:	4a20      	ldr	r2, [pc, #128]	; (80007fc <RCC_GetClocksFreq+0x1b0>)
 800077a:	69fb      	ldr	r3, [r7, #28]
 800077c:	4413      	add	r3, r2
 800077e:	781b      	ldrb	r3, [r3, #0]
 8000780:	b2db      	uxtb	r3, r3
 8000782:	60fb      	str	r3, [r7, #12]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8000784:	687b      	ldr	r3, [r7, #4]
 8000786:	681a      	ldr	r2, [r3, #0]
 8000788:	68fb      	ldr	r3, [r7, #12]
 800078a:	40da      	lsrs	r2, r3
 800078c:	687b      	ldr	r3, [r7, #4]
 800078e:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8000790:	4b16      	ldr	r3, [pc, #88]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 8000792:	689b      	ldr	r3, [r3, #8]
 8000794:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8000798:	61fb      	str	r3, [r7, #28]
  tmp = tmp >> 8;
 800079a:	69fb      	ldr	r3, [r7, #28]
 800079c:	0a1b      	lsrs	r3, r3, #8
 800079e:	61fb      	str	r3, [r7, #28]
  presc = APBAHBPrescTable[tmp];
 80007a0:	4a16      	ldr	r2, [pc, #88]	; (80007fc <RCC_GetClocksFreq+0x1b0>)
 80007a2:	69fb      	ldr	r3, [r7, #28]
 80007a4:	4413      	add	r3, r2
 80007a6:	781b      	ldrb	r3, [r3, #0]
 80007a8:	b2db      	uxtb	r3, r3
 80007aa:	60fb      	str	r3, [r7, #12]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80007ac:	687b      	ldr	r3, [r7, #4]
 80007ae:	685a      	ldr	r2, [r3, #4]
 80007b0:	68fb      	ldr	r3, [r7, #12]
 80007b2:	40da      	lsrs	r2, r3
 80007b4:	687b      	ldr	r3, [r7, #4]
 80007b6:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 80007b8:	4b0c      	ldr	r3, [pc, #48]	; (80007ec <RCC_GetClocksFreq+0x1a0>)
 80007ba:	689b      	ldr	r3, [r3, #8]
 80007bc:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 80007c0:	61fb      	str	r3, [r7, #28]
  tmp = tmp >> 11;
 80007c2:	69fb      	ldr	r3, [r7, #28]
 80007c4:	0adb      	lsrs	r3, r3, #11
 80007c6:	61fb      	str	r3, [r7, #28]
  presc = APBAHBPrescTable[tmp];
 80007c8:	4a0c      	ldr	r2, [pc, #48]	; (80007fc <RCC_GetClocksFreq+0x1b0>)
 80007ca:	69fb      	ldr	r3, [r7, #28]
 80007cc:	4413      	add	r3, r2
 80007ce:	781b      	ldrb	r3, [r3, #0]
 80007d0:	b2db      	uxtb	r3, r3
 80007d2:	60fb      	str	r3, [r7, #12]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80007d4:	687b      	ldr	r3, [r7, #4]
 80007d6:	685a      	ldr	r2, [r3, #4]
 80007d8:	68fb      	ldr	r3, [r7, #12]
 80007da:	40da      	lsrs	r2, r3
 80007dc:	687b      	ldr	r3, [r7, #4]
 80007de:	60da      	str	r2, [r3, #12]
}
 80007e0:	bf00      	nop
 80007e2:	3724      	adds	r7, #36	; 0x24
 80007e4:	46bd      	mov	sp, r7
 80007e6:	bc80      	pop	{r7}
 80007e8:	4770      	bx	lr
 80007ea:	bf00      	nop
 80007ec:	40023800 	.word	0x40023800
 80007f0:	00f42400 	.word	0x00f42400
 80007f4:	007a1200 	.word	0x007a1200
 80007f8:	20000000 	.word	0x20000000
 80007fc:	2000000c 	.word	0x2000000c

08000800 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8000800:	b480      	push	{r7}
 8000802:	b083      	sub	sp, #12
 8000804:	af00      	add	r7, sp, #0
 8000806:	6078      	str	r0, [r7, #4]
 8000808:	460b      	mov	r3, r1
 800080a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800080c:	78fb      	ldrb	r3, [r7, #3]
 800080e:	2b00      	cmp	r3, #0
 8000810:	d006      	beq.n	8000820 <RCC_AHBPeriphClockCmd+0x20>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8000812:	4909      	ldr	r1, [pc, #36]	; (8000838 <RCC_AHBPeriphClockCmd+0x38>)
 8000814:	4b08      	ldr	r3, [pc, #32]	; (8000838 <RCC_AHBPeriphClockCmd+0x38>)
 8000816:	69da      	ldr	r2, [r3, #28]
 8000818:	687b      	ldr	r3, [r7, #4]
 800081a:	4313      	orrs	r3, r2
 800081c:	61cb      	str	r3, [r1, #28]
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
  }
}
 800081e:	e006      	b.n	800082e <RCC_AHBPeriphClockCmd+0x2e>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8000820:	4905      	ldr	r1, [pc, #20]	; (8000838 <RCC_AHBPeriphClockCmd+0x38>)
 8000822:	4b05      	ldr	r3, [pc, #20]	; (8000838 <RCC_AHBPeriphClockCmd+0x38>)
 8000824:	69da      	ldr	r2, [r3, #28]
 8000826:	687b      	ldr	r3, [r7, #4]
 8000828:	43db      	mvns	r3, r3
 800082a:	4013      	ands	r3, r2
 800082c:	61cb      	str	r3, [r1, #28]
  }
}
 800082e:	bf00      	nop
 8000830:	370c      	adds	r7, #12
 8000832:	46bd      	mov	sp, r7
 8000834:	bc80      	pop	{r7}
 8000836:	4770      	bx	lr
 8000838:	40023800 	.word	0x40023800

0800083c <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 800083c:	b480      	push	{r7}
 800083e:	b083      	sub	sp, #12
 8000840:	af00      	add	r7, sp, #0
 8000842:	6078      	str	r0, [r7, #4]
 8000844:	460b      	mov	r3, r1
 8000846:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000848:	78fb      	ldrb	r3, [r7, #3]
 800084a:	2b00      	cmp	r3, #0
 800084c:	d006      	beq.n	800085c <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800084e:	4909      	ldr	r1, [pc, #36]	; (8000874 <RCC_APB2PeriphClockCmd+0x38>)
 8000850:	4b08      	ldr	r3, [pc, #32]	; (8000874 <RCC_APB2PeriphClockCmd+0x38>)
 8000852:	6a1a      	ldr	r2, [r3, #32]
 8000854:	687b      	ldr	r3, [r7, #4]
 8000856:	4313      	orrs	r3, r2
 8000858:	620b      	str	r3, [r1, #32]
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 800085a:	e006      	b.n	800086a <RCC_APB2PeriphClockCmd+0x2e>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800085c:	4905      	ldr	r1, [pc, #20]	; (8000874 <RCC_APB2PeriphClockCmd+0x38>)
 800085e:	4b05      	ldr	r3, [pc, #20]	; (8000874 <RCC_APB2PeriphClockCmd+0x38>)
 8000860:	6a1a      	ldr	r2, [r3, #32]
 8000862:	687b      	ldr	r3, [r7, #4]
 8000864:	43db      	mvns	r3, r3
 8000866:	4013      	ands	r3, r2
 8000868:	620b      	str	r3, [r1, #32]
  }
}
 800086a:	bf00      	nop
 800086c:	370c      	adds	r7, #12
 800086e:	46bd      	mov	sp, r7
 8000870:	bc80      	pop	{r7}
 8000872:	4770      	bx	lr
 8000874:	40023800 	.word	0x40023800

08000878 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8000878:	b480      	push	{r7}
 800087a:	b083      	sub	sp, #12
 800087c:	af00      	add	r7, sp, #0
 800087e:	6078      	str	r0, [r7, #4]
 8000880:	460b      	mov	r3, r1
 8000882:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000884:	78fb      	ldrb	r3, [r7, #3]
 8000886:	2b00      	cmp	r3, #0
 8000888:	d006      	beq.n	8000898 <RCC_APB1PeriphClockCmd+0x20>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800088a:	4909      	ldr	r1, [pc, #36]	; (80008b0 <RCC_APB1PeriphClockCmd+0x38>)
 800088c:	4b08      	ldr	r3, [pc, #32]	; (80008b0 <RCC_APB1PeriphClockCmd+0x38>)
 800088e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000890:	687b      	ldr	r3, [r7, #4]
 8000892:	4313      	orrs	r3, r2
 8000894:	624b      	str	r3, [r1, #36]	; 0x24
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}
 8000896:	e006      	b.n	80008a6 <RCC_APB1PeriphClockCmd+0x2e>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8000898:	4905      	ldr	r1, [pc, #20]	; (80008b0 <RCC_APB1PeriphClockCmd+0x38>)
 800089a:	4b05      	ldr	r3, [pc, #20]	; (80008b0 <RCC_APB1PeriphClockCmd+0x38>)
 800089c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800089e:	687b      	ldr	r3, [r7, #4]
 80008a0:	43db      	mvns	r3, r3
 80008a2:	4013      	ands	r3, r2
 80008a4:	624b      	str	r3, [r1, #36]	; 0x24
  }
}
 80008a6:	bf00      	nop
 80008a8:	370c      	adds	r7, #12
 80008aa:	46bd      	mov	sp, r7
 80008ac:	bc80      	pop	{r7}
 80008ae:	4770      	bx	lr
 80008b0:	40023800 	.word	0x40023800

080008b4 <SPI_Init>:
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 80008b4:	b480      	push	{r7}
 80008b6:	b085      	sub	sp, #20
 80008b8:	af00      	add	r7, sp, #0
 80008ba:	6078      	str	r0, [r7, #4]
 80008bc:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0;
 80008be:	2300      	movs	r3, #0
 80008c0:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 80008c2:	687b      	ldr	r3, [r7, #4]
 80008c4:	881b      	ldrh	r3, [r3, #0]
 80008c6:	81fb      	strh	r3, [r7, #14]
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 80008c8:	89fb      	ldrh	r3, [r7, #14]
 80008ca:	f403 5341 	and.w	r3, r3, #12352	; 0x3040
 80008ce:	81fb      	strh	r3, [r7, #14]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 80008d0:	683b      	ldr	r3, [r7, #0]
 80008d2:	881a      	ldrh	r2, [r3, #0]
 80008d4:	683b      	ldr	r3, [r7, #0]
 80008d6:	885b      	ldrh	r3, [r3, #2]
 80008d8:	4313      	orrs	r3, r2
 80008da:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 80008dc:	683b      	ldr	r3, [r7, #0]
 80008de:	889b      	ldrh	r3, [r3, #4]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 80008e0:	4313      	orrs	r3, r2
 80008e2:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 80008e4:	683b      	ldr	r3, [r7, #0]
 80008e6:	88db      	ldrh	r3, [r3, #6]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 80008e8:	4313      	orrs	r3, r2
 80008ea:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 80008ec:	683b      	ldr	r3, [r7, #0]
 80008ee:	891b      	ldrh	r3, [r3, #8]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 80008f0:	4313      	orrs	r3, r2
 80008f2:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 80008f4:	683b      	ldr	r3, [r7, #0]
 80008f6:	895b      	ldrh	r3, [r3, #10]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 80008f8:	4313      	orrs	r3, r2
 80008fa:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 80008fc:	683b      	ldr	r3, [r7, #0]
 80008fe:	899b      	ldrh	r3, [r3, #12]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000900:	4313      	orrs	r3, r2
 8000902:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 8000904:	683b      	ldr	r3, [r7, #0]
 8000906:	89db      	ldrh	r3, [r3, #14]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000908:	4313      	orrs	r3, r2
 800090a:	b29a      	uxth	r2, r3
 800090c:	89fb      	ldrh	r3, [r7, #14]
 800090e:	4313      	orrs	r3, r2
 8000910:	81fb      	strh	r3, [r7, #14]
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8000912:	687b      	ldr	r3, [r7, #4]
 8000914:	89fa      	ldrh	r2, [r7, #14]
 8000916:	801a      	strh	r2, [r3, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8000918:	687b      	ldr	r3, [r7, #4]
 800091a:	8b9b      	ldrh	r3, [r3, #28]
 800091c:	b29b      	uxth	r3, r3
 800091e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000922:	b29a      	uxth	r2, r3
 8000924:	687b      	ldr	r3, [r7, #4]
 8000926:	839a      	strh	r2, [r3, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8000928:	683b      	ldr	r3, [r7, #0]
 800092a:	8a1a      	ldrh	r2, [r3, #16]
 800092c:	687b      	ldr	r3, [r7, #4]
 800092e:	821a      	strh	r2, [r3, #16]
}
 8000930:	bf00      	nop
 8000932:	3714      	adds	r7, #20
 8000934:	46bd      	mov	sp, r7
 8000936:	bc80      	pop	{r7}
 8000938:	4770      	bx	lr
 800093a:	bf00      	nop

0800093c <SPI_Cmd>:
  * @param  NewState: new state of the SPIx peripheral. 
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 800093c:	b480      	push	{r7}
 800093e:	b083      	sub	sp, #12
 8000940:	af00      	add	r7, sp, #0
 8000942:	6078      	str	r0, [r7, #4]
 8000944:	460b      	mov	r3, r1
 8000946:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000948:	78fb      	ldrb	r3, [r7, #3]
 800094a:	2b00      	cmp	r3, #0
 800094c:	d008      	beq.n	8000960 <SPI_Cmd+0x24>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 800094e:	687b      	ldr	r3, [r7, #4]
 8000950:	881b      	ldrh	r3, [r3, #0]
 8000952:	b29b      	uxth	r3, r3
 8000954:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000958:	b29a      	uxth	r2, r3
 800095a:	687b      	ldr	r3, [r7, #4]
 800095c:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
  }
}
 800095e:	e007      	b.n	8000970 <SPI_Cmd+0x34>
    SPIx->CR1 |= SPI_CR1_SPE;
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 8000960:	687b      	ldr	r3, [r7, #4]
 8000962:	881b      	ldrh	r3, [r3, #0]
 8000964:	b29b      	uxth	r3, r3
 8000966:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800096a:	b29a      	uxth	r2, r3
 800096c:	687b      	ldr	r3, [r7, #4]
 800096e:	801a      	strh	r2, [r3, #0]
  }
}
 8000970:	bf00      	nop
 8000972:	370c      	adds	r7, #12
 8000974:	46bd      	mov	sp, r7
 8000976:	bc80      	pop	{r7}
 8000978:	4770      	bx	lr
 800097a:	bf00      	nop

0800097c <SPI_I2S_ReceiveData>:
  * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3
  *         in SPI mode or 2 or 3 in I2S mode.
  * @retval The value of the received data.
  */
uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
{
 800097c:	b480      	push	{r7}
 800097e:	b083      	sub	sp, #12
 8000980:	af00      	add	r7, sp, #0
 8000982:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
 8000984:	687b      	ldr	r3, [r7, #4]
 8000986:	899b      	ldrh	r3, [r3, #12]
 8000988:	b29b      	uxth	r3, r3
}
 800098a:	4618      	mov	r0, r3
 800098c:	370c      	adds	r7, #12
 800098e:	46bd      	mov	sp, r7
 8000990:	bc80      	pop	{r7}
 8000992:	4770      	bx	lr

08000994 <SPI_I2S_SendData>:
  *         in SPI mode or 2 or 3 in I2S mode.
  * @param  Data: Data to be transmitted.
  * @retval None
  */
void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
{
 8000994:	b480      	push	{r7}
 8000996:	b083      	sub	sp, #12
 8000998:	af00      	add	r7, sp, #0
 800099a:	6078      	str	r0, [r7, #4]
 800099c:	460b      	mov	r3, r1
 800099e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 80009a0:	687b      	ldr	r3, [r7, #4]
 80009a2:	887a      	ldrh	r2, [r7, #2]
 80009a4:	819a      	strh	r2, [r3, #12]
}
 80009a6:	bf00      	nop
 80009a8:	370c      	adds	r7, #12
 80009aa:	46bd      	mov	sp, r7
 80009ac:	bc80      	pop	{r7}
 80009ae:	4770      	bx	lr

080009b0 <SPI_I2S_GetFlagStatus>:
  *     @arg I2S_FLAG_UDR: Underrun Error flag.
  *     @arg I2S_FLAG_CHSIDE: Channel Side flag.
  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
  */
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
 80009b0:	b480      	push	{r7}
 80009b2:	b085      	sub	sp, #20
 80009b4:	af00      	add	r7, sp, #0
 80009b6:	6078      	str	r0, [r7, #4]
 80009b8:	460b      	mov	r3, r1
 80009ba:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 80009bc:	2300      	movs	r3, #0
 80009be:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 80009c0:	687b      	ldr	r3, [r7, #4]
 80009c2:	891b      	ldrh	r3, [r3, #8]
 80009c4:	b29a      	uxth	r2, r3
 80009c6:	887b      	ldrh	r3, [r7, #2]
 80009c8:	4013      	ands	r3, r2
 80009ca:	b29b      	uxth	r3, r3
 80009cc:	2b00      	cmp	r3, #0
 80009ce:	d002      	beq.n	80009d6 <SPI_I2S_GetFlagStatus+0x26>
  {
    /* SPI_I2S_FLAG is set */
    bitstatus = SET;
 80009d0:	2301      	movs	r3, #1
 80009d2:	73fb      	strb	r3, [r7, #15]
 80009d4:	e001      	b.n	80009da <SPI_I2S_GetFlagStatus+0x2a>
  }
  else
  {
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
 80009d6:	2300      	movs	r3, #0
 80009d8:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
 80009da:	7bfb      	ldrb	r3, [r7, #15]
}
 80009dc:	4618      	mov	r0, r3
 80009de:	3714      	adds	r7, #20
 80009e0:	46bd      	mov	sp, r7
 80009e2:	bc80      	pop	{r7}
 80009e4:	4770      	bx	lr
 80009e6:	bf00      	nop

080009e8 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that 
  *        contains the configuration information for the specified USART peripheral.
  * @retval None.
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80009e8:	b580      	push	{r7, lr}
 80009ea:	b08a      	sub	sp, #40	; 0x28
 80009ec:	af00      	add	r7, sp, #0
 80009ee:	6078      	str	r0, [r7, #4]
 80009f0:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 80009f2:	2300      	movs	r3, #0
 80009f4:	627b      	str	r3, [r7, #36]	; 0x24
 80009f6:	2300      	movs	r3, #0
 80009f8:	623b      	str	r3, [r7, #32]
  uint32_t integerdivider = 0x00;
 80009fa:	2300      	movs	r3, #0
 80009fc:	61fb      	str	r3, [r7, #28]
  uint32_t fractionaldivider = 0x00;
 80009fe:	2300      	movs	r3, #0
 8000a00:	61bb      	str	r3, [r7, #24]
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }
   
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8000a02:	687b      	ldr	r3, [r7, #4]
 8000a04:	8a1b      	ldrh	r3, [r3, #16]
 8000a06:	b29b      	uxth	r3, r3
 8000a08:	627b      	str	r3, [r7, #36]	; 0x24
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8000a0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a0c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8000a10:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8000a12:	683b      	ldr	r3, [r7, #0]
 8000a14:	88db      	ldrh	r3, [r3, #6]
 8000a16:	461a      	mov	r2, r3
 8000a18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a1a:	4313      	orrs	r3, r2
 8000a1c:	627b      	str	r3, [r7, #36]	; 0x24
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8000a1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a20:	b29a      	uxth	r2, r3
 8000a22:	687b      	ldr	r3, [r7, #4]
 8000a24:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8000a26:	687b      	ldr	r3, [r7, #4]
 8000a28:	899b      	ldrh	r3, [r3, #12]
 8000a2a:	b29b      	uxth	r3, r3
 8000a2c:	627b      	str	r3, [r7, #36]	; 0x24
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8000a2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a30:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 8000a34:	f023 030c 	bic.w	r3, r3, #12
 8000a38:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8000a3a:	683b      	ldr	r3, [r7, #0]
 8000a3c:	889a      	ldrh	r2, [r3, #4]
 8000a3e:	683b      	ldr	r3, [r7, #0]
 8000a40:	891b      	ldrh	r3, [r3, #8]
 8000a42:	4313      	orrs	r3, r2
 8000a44:	b29a      	uxth	r2, r3
            USART_InitStruct->USART_Mode;
 8000a46:	683b      	ldr	r3, [r7, #0]
 8000a48:	895b      	ldrh	r3, [r3, #10]

  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8000a4a:	4313      	orrs	r3, r2
 8000a4c:	b29b      	uxth	r3, r3
 8000a4e:	461a      	mov	r2, r3
 8000a50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a52:	4313      	orrs	r3, r2
 8000a54:	627b      	str	r3, [r7, #36]	; 0x24
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8000a56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a58:	b29a      	uxth	r2, r3
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8000a5e:	687b      	ldr	r3, [r7, #4]
 8000a60:	8a9b      	ldrh	r3, [r3, #20]
 8000a62:	b29b      	uxth	r3, r3
 8000a64:	627b      	str	r3, [r7, #36]	; 0x24
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 8000a66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a68:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000a6c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8000a6e:	683b      	ldr	r3, [r7, #0]
 8000a70:	899b      	ldrh	r3, [r3, #12]
 8000a72:	461a      	mov	r2, r3
 8000a74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a76:	4313      	orrs	r3, r2
 8000a78:	627b      	str	r3, [r7, #36]	; 0x24

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8000a7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000a7c:	b29a      	uxth	r2, r3
 8000a7e:	687b      	ldr	r3, [r7, #4]
 8000a80:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8000a82:	f107 0308 	add.w	r3, r7, #8
 8000a86:	4618      	mov	r0, r3
 8000a88:	f7ff fde0 	bl	800064c <RCC_GetClocksFreq>
  if (USARTx == USART1) 
 8000a8c:	687b      	ldr	r3, [r7, #4]
 8000a8e:	4a2e      	ldr	r2, [pc, #184]	; (8000b48 <USART_Init+0x160>)
 8000a90:	4293      	cmp	r3, r2
 8000a92:	d102      	bne.n	8000a9a <USART_Init+0xb2>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8000a94:	697b      	ldr	r3, [r7, #20]
 8000a96:	623b      	str	r3, [r7, #32]
 8000a98:	e001      	b.n	8000a9e <USART_Init+0xb6>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8000a9a:	693b      	ldr	r3, [r7, #16]
 8000a9c:	623b      	str	r3, [r7, #32]
  }

  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8000a9e:	687b      	ldr	r3, [r7, #4]
 8000aa0:	899b      	ldrh	r3, [r3, #12]
 8000aa2:	b29b      	uxth	r3, r3
 8000aa4:	b21b      	sxth	r3, r3
 8000aa6:	2b00      	cmp	r3, #0
 8000aa8:	da0c      	bge.n	8000ac4 <USART_Init+0xdc>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8000aaa:	6a3a      	ldr	r2, [r7, #32]
 8000aac:	4613      	mov	r3, r2
 8000aae:	009b      	lsls	r3, r3, #2
 8000ab0:	4413      	add	r3, r2
 8000ab2:	009a      	lsls	r2, r3, #2
 8000ab4:	441a      	add	r2, r3
 8000ab6:	683b      	ldr	r3, [r7, #0]
 8000ab8:	681b      	ldr	r3, [r3, #0]
 8000aba:	005b      	lsls	r3, r3, #1
 8000abc:	fbb2 f3f3 	udiv	r3, r2, r3
 8000ac0:	61fb      	str	r3, [r7, #28]
 8000ac2:	e00b      	b.n	8000adc <USART_Init+0xf4>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8000ac4:	6a3a      	ldr	r2, [r7, #32]
 8000ac6:	4613      	mov	r3, r2
 8000ac8:	009b      	lsls	r3, r3, #2
 8000aca:	4413      	add	r3, r2
 8000acc:	009a      	lsls	r2, r3, #2
 8000ace:	441a      	add	r2, r3
 8000ad0:	683b      	ldr	r3, [r7, #0]
 8000ad2:	681b      	ldr	r3, [r3, #0]
 8000ad4:	009b      	lsls	r3, r3, #2
 8000ad6:	fbb2 f3f3 	udiv	r3, r2, r3
 8000ada:	61fb      	str	r3, [r7, #28]
  }
  tmpreg = (integerdivider / 100) << 4;
 8000adc:	69fb      	ldr	r3, [r7, #28]
 8000ade:	4a1b      	ldr	r2, [pc, #108]	; (8000b4c <USART_Init+0x164>)
 8000ae0:	fba2 2303 	umull	r2, r3, r2, r3
 8000ae4:	095b      	lsrs	r3, r3, #5
 8000ae6:	011b      	lsls	r3, r3, #4
 8000ae8:	627b      	str	r3, [r7, #36]	; 0x24

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8000aea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000aec:	091b      	lsrs	r3, r3, #4
 8000aee:	2264      	movs	r2, #100	; 0x64
 8000af0:	fb02 f303 	mul.w	r3, r2, r3
 8000af4:	69fa      	ldr	r2, [r7, #28]
 8000af6:	1ad3      	subs	r3, r2, r3
 8000af8:	61bb      	str	r3, [r7, #24]

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8000afa:	687b      	ldr	r3, [r7, #4]
 8000afc:	899b      	ldrh	r3, [r3, #12]
 8000afe:	b29b      	uxth	r3, r3
 8000b00:	b21b      	sxth	r3, r3
 8000b02:	2b00      	cmp	r3, #0
 8000b04:	da0c      	bge.n	8000b20 <USART_Init+0x138>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8000b06:	69bb      	ldr	r3, [r7, #24]
 8000b08:	00db      	lsls	r3, r3, #3
 8000b0a:	3332      	adds	r3, #50	; 0x32
 8000b0c:	4a0f      	ldr	r2, [pc, #60]	; (8000b4c <USART_Init+0x164>)
 8000b0e:	fba2 2303 	umull	r2, r3, r2, r3
 8000b12:	095b      	lsrs	r3, r3, #5
 8000b14:	f003 0307 	and.w	r3, r3, #7
 8000b18:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8000b1a:	4313      	orrs	r3, r2
 8000b1c:	627b      	str	r3, [r7, #36]	; 0x24
 8000b1e:	e00b      	b.n	8000b38 <USART_Init+0x150>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8000b20:	69bb      	ldr	r3, [r7, #24]
 8000b22:	011b      	lsls	r3, r3, #4
 8000b24:	3332      	adds	r3, #50	; 0x32
 8000b26:	4a09      	ldr	r2, [pc, #36]	; (8000b4c <USART_Init+0x164>)
 8000b28:	fba2 2303 	umull	r2, r3, r2, r3
 8000b2c:	095b      	lsrs	r3, r3, #5
 8000b2e:	f003 030f 	and.w	r3, r3, #15
 8000b32:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8000b34:	4313      	orrs	r3, r2
 8000b36:	627b      	str	r3, [r7, #36]	; 0x24
  }
 
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
 8000b38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000b3a:	b29a      	uxth	r2, r3
 8000b3c:	687b      	ldr	r3, [r7, #4]
 8000b3e:	811a      	strh	r2, [r3, #8]
}
 8000b40:	bf00      	nop
 8000b42:	3728      	adds	r7, #40	; 0x28
 8000b44:	46bd      	mov	sp, r7
 8000b46:	bd80      	pop	{r7, pc}
 8000b48:	40013800 	.word	0x40013800
 8000b4c:	51eb851f 	.word	0x51eb851f

08000b50 <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8000b50:	b480      	push	{r7}
 8000b52:	b083      	sub	sp, #12
 8000b54:	af00      	add	r7, sp, #0
 8000b56:	6078      	str	r0, [r7, #4]
 8000b58:	460b      	mov	r3, r1
 8000b5a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000b5c:	78fb      	ldrb	r3, [r7, #3]
 8000b5e:	2b00      	cmp	r3, #0
 8000b60:	d008      	beq.n	8000b74 <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8000b62:	687b      	ldr	r3, [r7, #4]
 8000b64:	899b      	ldrh	r3, [r3, #12]
 8000b66:	b29b      	uxth	r3, r3
 8000b68:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000b6c:	b29a      	uxth	r2, r3
 8000b6e:	687b      	ldr	r3, [r7, #4]
 8000b70:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
  }
}
 8000b72:	e007      	b.n	8000b84 <USART_Cmd+0x34>
    USARTx->CR1 |= USART_CR1_UE;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8000b74:	687b      	ldr	r3, [r7, #4]
 8000b76:	899b      	ldrh	r3, [r3, #12]
 8000b78:	b29b      	uxth	r3, r3
 8000b7a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8000b7e:	b29a      	uxth	r2, r3
 8000b80:	687b      	ldr	r3, [r7, #4]
 8000b82:	819a      	strh	r2, [r3, #12]
  }
}
 8000b84:	bf00      	nop
 8000b86:	370c      	adds	r7, #12
 8000b88:	46bd      	mov	sp, r7
 8000b8a:	bc80      	pop	{r7}
 8000b8c:	4770      	bx	lr
 8000b8e:	bf00      	nop

08000b90 <USART_SendData>:
  *   USART1, USART2, USART3, UART4 or UART5.
  * @param  Data: the data to transmit.
  * @retval None.
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8000b90:	b480      	push	{r7}
 8000b92:	b083      	sub	sp, #12
 8000b94:	af00      	add	r7, sp, #0
 8000b96:	6078      	str	r0, [r7, #4]
 8000b98:	460b      	mov	r3, r1
 8000b9a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8000b9c:	887b      	ldrh	r3, [r7, #2]
 8000b9e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8000ba2:	b29a      	uxth	r2, r3
 8000ba4:	687b      	ldr	r3, [r7, #4]
 8000ba6:	809a      	strh	r2, [r3, #4]
}
 8000ba8:	bf00      	nop
 8000baa:	370c      	adds	r7, #12
 8000bac:	46bd      	mov	sp, r7
 8000bae:	bc80      	pop	{r7}
 8000bb0:	4770      	bx	lr
 8000bb2:	bf00      	nop

08000bb4 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8000bb4:	b480      	push	{r7}
 8000bb6:	b087      	sub	sp, #28
 8000bb8:	af00      	add	r7, sp, #0
 8000bba:	6078      	str	r0, [r7, #4]
 8000bbc:	460b      	mov	r3, r1
 8000bbe:	807b      	strh	r3, [r7, #2]
 8000bc0:	4613      	mov	r3, r2
 8000bc2:	707b      	strb	r3, [r7, #1]
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 8000bc4:	2300      	movs	r3, #0
 8000bc6:	613b      	str	r3, [r7, #16]
 8000bc8:	2300      	movs	r3, #0
 8000bca:	60fb      	str	r3, [r7, #12]
 8000bcc:	2300      	movs	r3, #0
 8000bce:	60bb      	str	r3, [r7, #8]
  uint32_t usartxbase = 0x00;
 8000bd0:	2300      	movs	r3, #0
 8000bd2:	617b      	str	r3, [r7, #20]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  } 
    
  usartxbase = (uint32_t)USARTx;
 8000bd4:	687b      	ldr	r3, [r7, #4]
 8000bd6:	617b      	str	r3, [r7, #20]

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8000bd8:	887b      	ldrh	r3, [r7, #2]
 8000bda:	b2db      	uxtb	r3, r3
 8000bdc:	095b      	lsrs	r3, r3, #5
 8000bde:	b2db      	uxtb	r3, r3
 8000be0:	613b      	str	r3, [r7, #16]

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 8000be2:	887b      	ldrh	r3, [r7, #2]
 8000be4:	f003 031f 	and.w	r3, r3, #31
 8000be8:	60fb      	str	r3, [r7, #12]
  itmask = (((uint32_t)0x01) << itpos);
 8000bea:	2201      	movs	r2, #1
 8000bec:	68fb      	ldr	r3, [r7, #12]
 8000bee:	fa02 f303 	lsl.w	r3, r2, r3
 8000bf2:	60bb      	str	r3, [r7, #8]
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8000bf4:	693b      	ldr	r3, [r7, #16]
 8000bf6:	2b01      	cmp	r3, #1
 8000bf8:	d103      	bne.n	8000c02 <USART_ITConfig+0x4e>
  {
    usartxbase += 0x0C;
 8000bfa:	697b      	ldr	r3, [r7, #20]
 8000bfc:	330c      	adds	r3, #12
 8000bfe:	617b      	str	r3, [r7, #20]
 8000c00:	e009      	b.n	8000c16 <USART_ITConfig+0x62>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8000c02:	693b      	ldr	r3, [r7, #16]
 8000c04:	2b02      	cmp	r3, #2
 8000c06:	d103      	bne.n	8000c10 <USART_ITConfig+0x5c>
  {
    usartxbase += 0x10;
 8000c08:	697b      	ldr	r3, [r7, #20]
 8000c0a:	3310      	adds	r3, #16
 8000c0c:	617b      	str	r3, [r7, #20]
 8000c0e:	e002      	b.n	8000c16 <USART_ITConfig+0x62>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8000c10:	697b      	ldr	r3, [r7, #20]
 8000c12:	3314      	adds	r3, #20
 8000c14:	617b      	str	r3, [r7, #20]
  }
  if (NewState != DISABLE)
 8000c16:	787b      	ldrb	r3, [r7, #1]
 8000c18:	2b00      	cmp	r3, #0
 8000c1a:	d006      	beq.n	8000c2a <USART_ITConfig+0x76>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8000c1c:	697b      	ldr	r3, [r7, #20]
 8000c1e:	697a      	ldr	r2, [r7, #20]
 8000c20:	6811      	ldr	r1, [r2, #0]
 8000c22:	68ba      	ldr	r2, [r7, #8]
 8000c24:	430a      	orrs	r2, r1
 8000c26:	601a      	str	r2, [r3, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 8000c28:	e006      	b.n	8000c38 <USART_ITConfig+0x84>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8000c2a:	697b      	ldr	r3, [r7, #20]
 8000c2c:	697a      	ldr	r2, [r7, #20]
 8000c2e:	6811      	ldr	r1, [r2, #0]
 8000c30:	68ba      	ldr	r2, [r7, #8]
 8000c32:	43d2      	mvns	r2, r2
 8000c34:	400a      	ands	r2, r1
 8000c36:	601a      	str	r2, [r3, #0]
  }
}
 8000c38:	bf00      	nop
 8000c3a:	371c      	adds	r7, #28
 8000c3c:	46bd      	mov	sp, r7
 8000c3e:	bc80      	pop	{r7}
 8000c40:	4770      	bx	lr
 8000c42:	bf00      	nop

08000c44 <USART_GetFlagStatus>:
  *     @arg USART_FLAG_FE:   Framing Error flag.
  *     @arg USART_FLAG_PE:   Parity Error flag.
  * @retval The new state of USART_FLAG (SET or RESET).
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
 8000c44:	b480      	push	{r7}
 8000c46:	b085      	sub	sp, #20
 8000c48:	af00      	add	r7, sp, #0
 8000c4a:	6078      	str	r0, [r7, #4]
 8000c4c:	460b      	mov	r3, r1
 8000c4e:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 8000c50:	2300      	movs	r3, #0
 8000c52:	73fb      	strb	r3, [r7, #15]
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8000c54:	687b      	ldr	r3, [r7, #4]
 8000c56:	881b      	ldrh	r3, [r3, #0]
 8000c58:	b29a      	uxth	r2, r3
 8000c5a:	887b      	ldrh	r3, [r7, #2]
 8000c5c:	4013      	ands	r3, r2
 8000c5e:	b29b      	uxth	r3, r3
 8000c60:	2b00      	cmp	r3, #0
 8000c62:	d002      	beq.n	8000c6a <USART_GetFlagStatus+0x26>
  {
    bitstatus = SET;
 8000c64:	2301      	movs	r3, #1
 8000c66:	73fb      	strb	r3, [r7, #15]
 8000c68:	e001      	b.n	8000c6e <USART_GetFlagStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
 8000c6a:	2300      	movs	r3, #0
 8000c6c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8000c6e:	7bfb      	ldrb	r3, [r7, #15]
}
 8000c70:	4618      	mov	r0, r3
 8000c72:	3714      	adds	r7, #20
 8000c74:	46bd      	mov	sp, r7
 8000c76:	bc80      	pop	{r7}
 8000c78:	4770      	bx	lr
 8000c7a:	bf00      	nop

08000c7c <TM_MFRC522_Init>:
 * RST => +3.3V
 * 3.3V => +3.3V
 */

//-------------------------------------------------
void TM_MFRC522_Init(void) {
 8000c7c:	b580      	push	{r7, lr}
 8000c7e:	af00      	add	r7, sp, #0

	TM_MFRC522_InitSPI();
 8000c80:	f000 f826 	bl	8000cd0 <TM_MFRC522_InitSPI>
	//CS high
	MFRC522_CS_HIGH;
 8000c84:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000c88:	4810      	ldr	r0, [pc, #64]	; (8000ccc <TM_MFRC522_Init+0x50>)
 8000c8a:	f7ff fc67 	bl	800055c <GPIO_SetBits>

	TM_MFRC522_Reset();
 8000c8e:	f000 f94f 	bl	8000f30 <TM_MFRC522_Reset>

	TM_MFRC522_WriteRegister(MFRC522_REG_T_MODE, 0x8D);
 8000c92:	218d      	movs	r1, #141	; 0x8d
 8000c94:	202a      	movs	r0, #42	; 0x2a
 8000c96:	f000 f89f 	bl	8000dd8 <TM_MFRC522_WriteRegister>
	TM_MFRC522_WriteRegister(MFRC522_REG_T_PRESCALER, 0x3E);
 8000c9a:	213e      	movs	r1, #62	; 0x3e
 8000c9c:	202b      	movs	r0, #43	; 0x2b
 8000c9e:	f000 f89b 	bl	8000dd8 <TM_MFRC522_WriteRegister>
	TM_MFRC522_WriteRegister(MFRC522_REG_T_RELOAD_L, 30);
 8000ca2:	211e      	movs	r1, #30
 8000ca4:	202d      	movs	r0, #45	; 0x2d
 8000ca6:	f000 f897 	bl	8000dd8 <TM_MFRC522_WriteRegister>
	TM_MFRC522_WriteRegister(MFRC522_REG_T_RELOAD_H, 0);
 8000caa:	2100      	movs	r1, #0
 8000cac:	202c      	movs	r0, #44	; 0x2c
 8000cae:	f000 f893 	bl	8000dd8 <TM_MFRC522_WriteRegister>

	/* 48dB gain */
	//TM_MFRC522_WriteRegister(MFRC522_REG_RF_CFG, 0x70); 
	TM_MFRC522_WriteRegister(MFRC522_REG_TX_AUTO, 0x40);
 8000cb2:	2140      	movs	r1, #64	; 0x40
 8000cb4:	2015      	movs	r0, #21
 8000cb6:	f000 f88f 	bl	8000dd8 <TM_MFRC522_WriteRegister>
	TM_MFRC522_WriteRegister(MFRC522_REG_MODE, 0x3D);
 8000cba:	213d      	movs	r1, #61	; 0x3d
 8000cbc:	2011      	movs	r0, #17
 8000cbe:	f000 f88b 	bl	8000dd8 <TM_MFRC522_WriteRegister>

	TM_MFRC522_AntennaOn();		//Open the antenna
 8000cc2:	f000 f91f 	bl	8000f04 <TM_MFRC522_AntennaOn>
}
 8000cc6:	bf00      	nop
 8000cc8:	bd80      	pop	{r7, pc}
 8000cca:	bf00      	nop
 8000ccc:	40020400 	.word	0x40020400

08000cd0 <TM_MFRC522_InitSPI>:

//SPI2
void TM_MFRC522_InitSPI(void) {
 8000cd0:	b580      	push	{r7, lr}
 8000cd2:	b088      	sub	sp, #32
 8000cd4:	af00      	add	r7, sp, #0
	SPI_InitTypeDef SPI_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;

	/* Enable SPI2 and GPIOB clocks */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8000cd6:	2101      	movs	r1, #1
 8000cd8:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8000cdc:	f7ff fdcc 	bl	8000878 <RCC_APB1PeriphClockCmd>
	//  
	//CS  ---- Output, duoc dieu khien khi read/write
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 8000ce0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000ce4:	607b      	str	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 8000ce6:	2303      	movs	r3, #3
 8000ce8:	727b      	strb	r3, [r7, #9]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000cea:	2301      	movs	r3, #1
 8000cec:	723b      	strb	r3, [r7, #8]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8000cee:	1d3b      	adds	r3, r7, #4
 8000cf0:	4619      	mov	r1, r3
 8000cf2:	4824      	ldr	r0, [pc, #144]	; (8000d84 <TM_MFRC522_InitSPI+0xb4>)
 8000cf4:	f7ff fb80 	bl	80003f8 <GPIO_Init>
	//SET CS HIGH LEVEL
	GPIO_SetBits(GPIOB, GPIO_Pin_12);
 8000cf8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000cfc:	4821      	ldr	r0, [pc, #132]	; (8000d84 <TM_MFRC522_InitSPI+0xb4>)
 8000cfe:	f7ff fc2d 	bl	800055c <GPIO_SetBits>

	/*Configure SPI2 pins: SCK, MISO and MOSI*/
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
 8000d02:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8000d06:	607b      	str	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8000d08:	2302      	movs	r3, #2
 8000d0a:	723b      	strb	r3, [r7, #8]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000d0c:	2300      	movs	r3, #0
 8000d0e:	72bb      	strb	r3, [r7, #10]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 8000d10:	2303      	movs	r3, #3
 8000d12:	727b      	strb	r3, [r7, #9]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000d14:	2300      	movs	r3, #0
 8000d16:	72fb      	strb	r3, [r7, #11]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8000d18:	1d3b      	adds	r3, r7, #4
 8000d1a:	4619      	mov	r1, r3
 8000d1c:	4819      	ldr	r0, [pc, #100]	; (8000d84 <TM_MFRC522_InitSPI+0xb4>)
 8000d1e:	f7ff fb6b 	bl	80003f8 <GPIO_Init>

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);
 8000d22:	2205      	movs	r2, #5
 8000d24:	210d      	movs	r1, #13
 8000d26:	4817      	ldr	r0, [pc, #92]	; (8000d84 <TM_MFRC522_InitSPI+0xb4>)
 8000d28:	f7ff fc48 	bl	80005bc <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_SPI2);
 8000d2c:	2205      	movs	r2, #5
 8000d2e:	210e      	movs	r1, #14
 8000d30:	4814      	ldr	r0, [pc, #80]	; (8000d84 <TM_MFRC522_InitSPI+0xb4>)
 8000d32:	f7ff fc43 	bl	80005bc <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_SPI2);
 8000d36:	2205      	movs	r2, #5
 8000d38:	210f      	movs	r1, #15
 8000d3a:	4812      	ldr	r0, [pc, #72]	; (8000d84 <TM_MFRC522_InitSPI+0xb4>)
 8000d3c:	f7ff fc3e 	bl	80005bc <GPIO_PinAFConfig>
	/* SPI2 configuration */
	/* Data bytes on both MOSI and MISO lines are sent with the MSB first. Data on both MOSI
	 and MISO lines must be stable on the rising edge of the clock and can be changed on the
	 falling edge. Data is provided by the MFRC522 on the falling clock edge and is stable
	 during the rising clock edge. */
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8000d40:	2300      	movs	r3, #0
 8000d42:	81bb      	strh	r3, [r7, #12]
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8000d44:	f44f 7382 	mov.w	r3, #260	; 0x104
 8000d48:	81fb      	strh	r3, [r7, #14]
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 8000d4a:	2300      	movs	r3, #0
 8000d4c:	823b      	strh	r3, [r7, #16]
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8000d4e:	2300      	movs	r3, #0
 8000d50:	827b      	strh	r3, [r7, #18]
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8000d52:	2300      	movs	r3, #0
 8000d54:	82bb      	strh	r3, [r7, #20]
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8000d56:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000d5a:	82fb      	strh	r3, [r7, #22]
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8; // 72Mhz / 8 = 9Mhz  
 8000d5c:	2310      	movs	r3, #16
 8000d5e:	833b      	strh	r3, [r7, #24]
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 8000d60:	2300      	movs	r3, #0
 8000d62:	837b      	strh	r3, [r7, #26]
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 8000d64:	2307      	movs	r3, #7
 8000d66:	83bb      	strh	r3, [r7, #28]
	SPI_Init(SPI2, &SPI_InitStructure);
 8000d68:	f107 030c 	add.w	r3, r7, #12
 8000d6c:	4619      	mov	r1, r3
 8000d6e:	4806      	ldr	r0, [pc, #24]	; (8000d88 <TM_MFRC522_InitSPI+0xb8>)
 8000d70:	f7ff fda0 	bl	80008b4 <SPI_Init>

	/* Enable SPI2  */
	SPI_Cmd(SPI2, ENABLE);
 8000d74:	2101      	movs	r1, #1
 8000d76:	4804      	ldr	r0, [pc, #16]	; (8000d88 <TM_MFRC522_InitSPI+0xb8>)
 8000d78:	f7ff fde0 	bl	800093c <SPI_Cmd>
}
 8000d7c:	bf00      	nop
 8000d7e:	3720      	adds	r7, #32
 8000d80:	46bd      	mov	sp, r7
 8000d82:	bd80      	pop	{r7, pc}
 8000d84:	40020400 	.word	0x40020400
 8000d88:	40003800 	.word	0x40003800

08000d8c <SPI2_ReadWrite>:
//-------------------------------------------------
//SPI2
unsigned char SPI2_ReadWrite(unsigned char writedat) {
 8000d8c:	b580      	push	{r7, lr}
 8000d8e:	b082      	sub	sp, #8
 8000d90:	af00      	add	r7, sp, #0
 8000d92:	4603      	mov	r3, r0
 8000d94:	71fb      	strb	r3, [r7, #7]
	/* Loop while DR register in not emplty */
	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET)
 8000d96:	bf00      	nop
 8000d98:	2102      	movs	r1, #2
 8000d9a:	480e      	ldr	r0, [pc, #56]	; (8000dd4 <SPI2_ReadWrite+0x48>)
 8000d9c:	f7ff fe08 	bl	80009b0 <SPI_I2S_GetFlagStatus>
 8000da0:	4603      	mov	r3, r0
 8000da2:	2b00      	cmp	r3, #0
 8000da4:	d0f8      	beq.n	8000d98 <SPI2_ReadWrite+0xc>
		;

	/* Send byte through the SPI2 peripheral */
	SPI_I2S_SendData(SPI2, writedat);
 8000da6:	79fb      	ldrb	r3, [r7, #7]
 8000da8:	b29b      	uxth	r3, r3
 8000daa:	4619      	mov	r1, r3
 8000dac:	4809      	ldr	r0, [pc, #36]	; (8000dd4 <SPI2_ReadWrite+0x48>)
 8000dae:	f7ff fdf1 	bl	8000994 <SPI_I2S_SendData>

	/* Wait to receive a byte */
	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET)
 8000db2:	bf00      	nop
 8000db4:	2101      	movs	r1, #1
 8000db6:	4807      	ldr	r0, [pc, #28]	; (8000dd4 <SPI2_ReadWrite+0x48>)
 8000db8:	f7ff fdfa 	bl	80009b0 <SPI_I2S_GetFlagStatus>
 8000dbc:	4603      	mov	r3, r0
 8000dbe:	2b00      	cmp	r3, #0
 8000dc0:	d0f8      	beq.n	8000db4 <SPI2_ReadWrite+0x28>
		;

	/* Return the byte read from the SPI bus */
	return SPI_I2S_ReceiveData(SPI2);
 8000dc2:	4804      	ldr	r0, [pc, #16]	; (8000dd4 <SPI2_ReadWrite+0x48>)
 8000dc4:	f7ff fdda 	bl	800097c <SPI_I2S_ReceiveData>
 8000dc8:	4603      	mov	r3, r0
 8000dca:	b2db      	uxtb	r3, r3
}
 8000dcc:	4618      	mov	r0, r3
 8000dce:	3708      	adds	r7, #8
 8000dd0:	46bd      	mov	sp, r7
 8000dd2:	bd80      	pop	{r7, pc}
 8000dd4:	40003800 	.word	0x40003800

08000dd8 <TM_MFRC522_WriteRegister>:

//-------------------------------------------------
void TM_MFRC522_WriteRegister(uint8_t addr, uint8_t val) {
 8000dd8:	b580      	push	{r7, lr}
 8000dda:	b084      	sub	sp, #16
 8000ddc:	af00      	add	r7, sp, #0
 8000dde:	4603      	mov	r3, r0
 8000de0:	460a      	mov	r2, r1
 8000de2:	71fb      	strb	r3, [r7, #7]
 8000de4:	4613      	mov	r3, r2
 8000de6:	71bb      	strb	r3, [r7, #6]
	//CS low
	unsigned char status;
	MFRC522_CS_LOW;
 8000de8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000dec:	4811      	ldr	r0, [pc, #68]	; (8000e34 <TM_MFRC522_WriteRegister+0x5c>)
 8000dee:	f7ff fbc3 	bl	8000578 <GPIO_ResetBits>
	//Send address
	Delay_us(10);
 8000df2:	200a      	movs	r0, #10
 8000df4:	f001 fffc 	bl	8002df0 <Delay_us>
	status = SPI2_ReadWrite((addr << 1) & 0x7E);
 8000df8:	79fb      	ldrb	r3, [r7, #7]
 8000dfa:	005b      	lsls	r3, r3, #1
 8000dfc:	b2db      	uxtb	r3, r3
 8000dfe:	f003 037e 	and.w	r3, r3, #126	; 0x7e
 8000e02:	b2db      	uxtb	r3, r3
 8000e04:	4618      	mov	r0, r3
 8000e06:	f7ff ffc1 	bl	8000d8c <SPI2_ReadWrite>
 8000e0a:	4603      	mov	r3, r0
 8000e0c:	73fb      	strb	r3, [r7, #15]
	//Send data	
	Delay_us(10);
 8000e0e:	200a      	movs	r0, #10
 8000e10:	f001 ffee 	bl	8002df0 <Delay_us>
	status = SPI2_ReadWrite(val);
 8000e14:	79bb      	ldrb	r3, [r7, #6]
 8000e16:	4618      	mov	r0, r3
 8000e18:	f7ff ffb8 	bl	8000d8c <SPI2_ReadWrite>
 8000e1c:	4603      	mov	r3, r0
 8000e1e:	73fb      	strb	r3, [r7, #15]
	//CS high
	MFRC522_CS_HIGH;
 8000e20:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000e24:	4803      	ldr	r0, [pc, #12]	; (8000e34 <TM_MFRC522_WriteRegister+0x5c>)
 8000e26:	f7ff fb99 	bl	800055c <GPIO_SetBits>
}
 8000e2a:	bf00      	nop
 8000e2c:	3710      	adds	r7, #16
 8000e2e:	46bd      	mov	sp, r7
 8000e30:	bd80      	pop	{r7, pc}
 8000e32:	bf00      	nop
 8000e34:	40020400 	.word	0x40020400

08000e38 <TM_MFRC522_ReadRegister>:
//-------------------------------------------------
uint8_t TM_MFRC522_ReadRegister(uint8_t addr) {
 8000e38:	b580      	push	{r7, lr}
 8000e3a:	b084      	sub	sp, #16
 8000e3c:	af00      	add	r7, sp, #0
 8000e3e:	4603      	mov	r3, r0
 8000e40:	71fb      	strb	r3, [r7, #7]
	uint8_t val;
	//CS low
	MFRC522_CS_LOW;
 8000e42:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000e46:	4812      	ldr	r0, [pc, #72]	; (8000e90 <TM_MFRC522_ReadRegister+0x58>)
 8000e48:	f7ff fb96 	bl	8000578 <GPIO_ResetBits>
	Delay_us(10);
 8000e4c:	200a      	movs	r0, #10
 8000e4e:	f001 ffcf 	bl	8002df0 <Delay_us>
	SPI2_ReadWrite(((addr << 1) & 0x7E) | 0x80);
 8000e52:	79fb      	ldrb	r3, [r7, #7]
 8000e54:	005b      	lsls	r3, r3, #1
 8000e56:	b25b      	sxtb	r3, r3
 8000e58:	f003 037e 	and.w	r3, r3, #126	; 0x7e
 8000e5c:	b25b      	sxtb	r3, r3
 8000e5e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8000e62:	b25b      	sxtb	r3, r3
 8000e64:	b2db      	uxtb	r3, r3
 8000e66:	4618      	mov	r0, r3
 8000e68:	f7ff ff90 	bl	8000d8c <SPI2_ReadWrite>
	Delay_us(10);
 8000e6c:	200a      	movs	r0, #10
 8000e6e:	f001 ffbf 	bl	8002df0 <Delay_us>
	val = SPI2_ReadWrite(0x00); // SPI2_ReadWrite(0x00);
 8000e72:	2000      	movs	r0, #0
 8000e74:	f7ff ff8a 	bl	8000d8c <SPI2_ReadWrite>
 8000e78:	4603      	mov	r3, r0
 8000e7a:	73fb      	strb	r3, [r7, #15]
	//CS high
	MFRC522_CS_HIGH;
 8000e7c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000e80:	4803      	ldr	r0, [pc, #12]	; (8000e90 <TM_MFRC522_ReadRegister+0x58>)
 8000e82:	f7ff fb6b 	bl	800055c <GPIO_SetBits>

	return val;
 8000e86:	7bfb      	ldrb	r3, [r7, #15]
}
 8000e88:	4618      	mov	r0, r3
 8000e8a:	3710      	adds	r7, #16
 8000e8c:	46bd      	mov	sp, r7
 8000e8e:	bd80      	pop	{r7, pc}
 8000e90:	40020400 	.word	0x40020400

08000e94 <TM_MFRC522_SetBitMask>:
//-------------------------------------------------
void TM_MFRC522_SetBitMask(uint8_t reg, uint8_t mask) {
 8000e94:	b580      	push	{r7, lr}
 8000e96:	b082      	sub	sp, #8
 8000e98:	af00      	add	r7, sp, #0
 8000e9a:	4603      	mov	r3, r0
 8000e9c:	460a      	mov	r2, r1
 8000e9e:	71fb      	strb	r3, [r7, #7]
 8000ea0:	4613      	mov	r3, r2
 8000ea2:	71bb      	strb	r3, [r7, #6]
	TM_MFRC522_WriteRegister(reg, TM_MFRC522_ReadRegister(reg) | mask);
 8000ea4:	79fb      	ldrb	r3, [r7, #7]
 8000ea6:	4618      	mov	r0, r3
 8000ea8:	f7ff ffc6 	bl	8000e38 <TM_MFRC522_ReadRegister>
 8000eac:	4603      	mov	r3, r0
 8000eae:	461a      	mov	r2, r3
 8000eb0:	79bb      	ldrb	r3, [r7, #6]
 8000eb2:	4313      	orrs	r3, r2
 8000eb4:	b2da      	uxtb	r2, r3
 8000eb6:	79fb      	ldrb	r3, [r7, #7]
 8000eb8:	4611      	mov	r1, r2
 8000eba:	4618      	mov	r0, r3
 8000ebc:	f7ff ff8c 	bl	8000dd8 <TM_MFRC522_WriteRegister>
}
 8000ec0:	bf00      	nop
 8000ec2:	3708      	adds	r7, #8
 8000ec4:	46bd      	mov	sp, r7
 8000ec6:	bd80      	pop	{r7, pc}

08000ec8 <TM_MFRC522_ClearBitMask>:
//-------------------------------------------------
void TM_MFRC522_ClearBitMask(uint8_t reg, uint8_t mask) {
 8000ec8:	b580      	push	{r7, lr}
 8000eca:	b082      	sub	sp, #8
 8000ecc:	af00      	add	r7, sp, #0
 8000ece:	4603      	mov	r3, r0
 8000ed0:	460a      	mov	r2, r1
 8000ed2:	71fb      	strb	r3, [r7, #7]
 8000ed4:	4613      	mov	r3, r2
 8000ed6:	71bb      	strb	r3, [r7, #6]
	TM_MFRC522_WriteRegister(reg, TM_MFRC522_ReadRegister(reg) & (~mask));
 8000ed8:	79fb      	ldrb	r3, [r7, #7]
 8000eda:	4618      	mov	r0, r3
 8000edc:	f7ff ffac 	bl	8000e38 <TM_MFRC522_ReadRegister>
 8000ee0:	4603      	mov	r3, r0
 8000ee2:	b25a      	sxtb	r2, r3
 8000ee4:	f997 3006 	ldrsb.w	r3, [r7, #6]
 8000ee8:	43db      	mvns	r3, r3
 8000eea:	b25b      	sxtb	r3, r3
 8000eec:	4013      	ands	r3, r2
 8000eee:	b25b      	sxtb	r3, r3
 8000ef0:	b2da      	uxtb	r2, r3
 8000ef2:	79fb      	ldrb	r3, [r7, #7]
 8000ef4:	4611      	mov	r1, r2
 8000ef6:	4618      	mov	r0, r3
 8000ef8:	f7ff ff6e 	bl	8000dd8 <TM_MFRC522_WriteRegister>
}
 8000efc:	bf00      	nop
 8000efe:	3708      	adds	r7, #8
 8000f00:	46bd      	mov	sp, r7
 8000f02:	bd80      	pop	{r7, pc}

08000f04 <TM_MFRC522_AntennaOn>:
//-------------------------------------------------
void TM_MFRC522_AntennaOn(void) {
 8000f04:	b580      	push	{r7, lr}
 8000f06:	b082      	sub	sp, #8
 8000f08:	af00      	add	r7, sp, #0
	uint8_t temp;

	temp = TM_MFRC522_ReadRegister(MFRC522_REG_TX_CONTROL);
 8000f0a:	2014      	movs	r0, #20
 8000f0c:	f7ff ff94 	bl	8000e38 <TM_MFRC522_ReadRegister>
 8000f10:	4603      	mov	r3, r0
 8000f12:	71fb      	strb	r3, [r7, #7]
	if (!(temp & 0x03)) {
 8000f14:	79fb      	ldrb	r3, [r7, #7]
 8000f16:	f003 0303 	and.w	r3, r3, #3
 8000f1a:	2b00      	cmp	r3, #0
 8000f1c:	d103      	bne.n	8000f26 <TM_MFRC522_AntennaOn+0x22>
		TM_MFRC522_SetBitMask(MFRC522_REG_TX_CONTROL, 0x03);
 8000f1e:	2103      	movs	r1, #3
 8000f20:	2014      	movs	r0, #20
 8000f22:	f7ff ffb7 	bl	8000e94 <TM_MFRC522_SetBitMask>
	}
}
 8000f26:	bf00      	nop
 8000f28:	3708      	adds	r7, #8
 8000f2a:	46bd      	mov	sp, r7
 8000f2c:	bd80      	pop	{r7, pc}
 8000f2e:	bf00      	nop

08000f30 <TM_MFRC522_Reset>:
//-------------------------------------------------
void TM_MFRC522_AntennaOff(void) {
	TM_MFRC522_ClearBitMask(MFRC522_REG_TX_CONTROL, 0x03);
}
//-------------------------------------------------
void TM_MFRC522_Reset(void) {
 8000f30:	b580      	push	{r7, lr}
 8000f32:	af00      	add	r7, sp, #0
	TM_MFRC522_WriteRegister(MFRC522_REG_COMMAND, PCD_RESETPHASE);
 8000f34:	210f      	movs	r1, #15
 8000f36:	2001      	movs	r0, #1
 8000f38:	f7ff ff4e 	bl	8000dd8 <TM_MFRC522_WriteRegister>
}
 8000f3c:	bf00      	nop
 8000f3e:	bd80      	pop	{r7, pc}

08000f40 <TM_MFRC522_Request>:
	uint8_t response;
	response = TM_MFRC522_ReadRegister(MFRC522_REG_VERSION);
	return response;
}
//-------------------------------------------------
TM_MFRC522_Status_t TM_MFRC522_Request(uint8_t reqMode, uint8_t* TagType) {
 8000f40:	b580      	push	{r7, lr}
 8000f42:	b086      	sub	sp, #24
 8000f44:	af02      	add	r7, sp, #8
 8000f46:	4603      	mov	r3, r0
 8000f48:	6039      	str	r1, [r7, #0]
 8000f4a:	71fb      	strb	r3, [r7, #7]
	TM_MFRC522_Status_t status;
	uint16_t backBits;			//The received data bits

	TM_MFRC522_WriteRegister(MFRC522_REG_BIT_FRAMING, 0x07);//TxLastBists = BitFramingReg[2..0]	???
 8000f4c:	2107      	movs	r1, #7
 8000f4e:	200d      	movs	r0, #13
 8000f50:	f7ff ff42 	bl	8000dd8 <TM_MFRC522_WriteRegister>

	TagType[0] = reqMode;
 8000f54:	683b      	ldr	r3, [r7, #0]
 8000f56:	79fa      	ldrb	r2, [r7, #7]
 8000f58:	701a      	strb	r2, [r3, #0]
	status = TM_MFRC522_ToCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backBits);
 8000f5a:	f107 030c 	add.w	r3, r7, #12
 8000f5e:	9300      	str	r3, [sp, #0]
 8000f60:	683b      	ldr	r3, [r7, #0]
 8000f62:	2201      	movs	r2, #1
 8000f64:	6839      	ldr	r1, [r7, #0]
 8000f66:	200c      	movs	r0, #12
 8000f68:	f000 f82a 	bl	8000fc0 <TM_MFRC522_ToCard>
 8000f6c:	4603      	mov	r3, r0
 8000f6e:	73fb      	strb	r3, [r7, #15]

	if ((status != MI_OK) || (backBits != 0x10)) {
 8000f70:	7bfb      	ldrb	r3, [r7, #15]
 8000f72:	2b00      	cmp	r3, #0
 8000f74:	d102      	bne.n	8000f7c <TM_MFRC522_Request+0x3c>
 8000f76:	89bb      	ldrh	r3, [r7, #12]
 8000f78:	2b10      	cmp	r3, #16
 8000f7a:	d001      	beq.n	8000f80 <TM_MFRC522_Request+0x40>
		status = MI_ERR;
 8000f7c:	2302      	movs	r3, #2
 8000f7e:	73fb      	strb	r3, [r7, #15]
	}

	return status;
 8000f80:	7bfb      	ldrb	r3, [r7, #15]
}
 8000f82:	4618      	mov	r0, r3
 8000f84:	3710      	adds	r7, #16
 8000f86:	46bd      	mov	sp, r7
 8000f88:	bd80      	pop	{r7, pc}
 8000f8a:	bf00      	nop

08000f8c <TM_MFRC522_Check>:

//-------------------------------------------------
TM_MFRC522_Status_t TM_MFRC522_Check(uint8_t* id) {
 8000f8c:	b580      	push	{r7, lr}
 8000f8e:	b084      	sub	sp, #16
 8000f90:	af00      	add	r7, sp, #0
 8000f92:	6078      	str	r0, [r7, #4]
	TM_MFRC522_Status_t status;
	//Find cards, return card type
	status = TM_MFRC522_Request(PICC_REQIDL, id);
 8000f94:	6879      	ldr	r1, [r7, #4]
 8000f96:	2026      	movs	r0, #38	; 0x26
 8000f98:	f7ff ffd2 	bl	8000f40 <TM_MFRC522_Request>
 8000f9c:	4603      	mov	r3, r0
 8000f9e:	73fb      	strb	r3, [r7, #15]
	if (status == MI_OK) {
 8000fa0:	7bfb      	ldrb	r3, [r7, #15]
 8000fa2:	2b00      	cmp	r3, #0
 8000fa4:	d104      	bne.n	8000fb0 <TM_MFRC522_Check+0x24>
		//Card detected
		//Anti-collision, return card serial number 4 bytes
		status = TM_MFRC522_Anticoll(id);
 8000fa6:	6878      	ldr	r0, [r7, #4]
 8000fa8:	f000 f8da 	bl	8001160 <TM_MFRC522_Anticoll>
 8000fac:	4603      	mov	r3, r0
 8000fae:	73fb      	strb	r3, [r7, #15]
	}
	TM_MFRC522_Halt();			//Command card into hibernation 
 8000fb0:	f000 f95e 	bl	8001270 <TM_MFRC522_Halt>

	return status;
 8000fb4:	7bfb      	ldrb	r3, [r7, #15]
}
 8000fb6:	4618      	mov	r0, r3
 8000fb8:	3710      	adds	r7, #16
 8000fba:	46bd      	mov	sp, r7
 8000fbc:	bd80      	pop	{r7, pc}
 8000fbe:	bf00      	nop

08000fc0 <TM_MFRC522_ToCard>:
	}
	return MI_OK;
}
//-------------------------------------------------
TM_MFRC522_Status_t TM_MFRC522_ToCard(uint8_t command, uint8_t* sendData,
		uint8_t sendLen, uint8_t* backData, uint16_t* backLen) {
 8000fc0:	b590      	push	{r4, r7, lr}
 8000fc2:	b087      	sub	sp, #28
 8000fc4:	af00      	add	r7, sp, #0
 8000fc6:	60b9      	str	r1, [r7, #8]
 8000fc8:	607b      	str	r3, [r7, #4]
 8000fca:	4603      	mov	r3, r0
 8000fcc:	73fb      	strb	r3, [r7, #15]
 8000fce:	4613      	mov	r3, r2
 8000fd0:	73bb      	strb	r3, [r7, #14]
	TM_MFRC522_Status_t status = MI_ERR;
 8000fd2:	2302      	movs	r3, #2
 8000fd4:	75fb      	strb	r3, [r7, #23]
	uint8_t irqEn = 0x00;
 8000fd6:	2300      	movs	r3, #0
 8000fd8:	75bb      	strb	r3, [r7, #22]
	uint8_t waitIRq = 0x00;
 8000fda:	2300      	movs	r3, #0
 8000fdc:	757b      	strb	r3, [r7, #21]
	uint8_t lastBits;
	uint8_t n;
	uint16_t i;

	switch (command) {
 8000fde:	7bfb      	ldrb	r3, [r7, #15]
 8000fe0:	2b0c      	cmp	r3, #12
 8000fe2:	d007      	beq.n	8000ff4 <TM_MFRC522_ToCard+0x34>
 8000fe4:	2b0e      	cmp	r3, #14
 8000fe6:	d000      	beq.n	8000fea <TM_MFRC522_ToCard+0x2a>
		irqEn = 0x77;
		waitIRq = 0x30;
		break;
	}
	default:
		break;
 8000fe8:	e009      	b.n	8000ffe <TM_MFRC522_ToCard+0x3e>
	uint8_t n;
	uint16_t i;

	switch (command) {
	case PCD_AUTHENT: {
		irqEn = 0x12;
 8000fea:	2312      	movs	r3, #18
 8000fec:	75bb      	strb	r3, [r7, #22]
		waitIRq = 0x10;
 8000fee:	2310      	movs	r3, #16
 8000ff0:	757b      	strb	r3, [r7, #21]
		break;
 8000ff2:	e004      	b.n	8000ffe <TM_MFRC522_ToCard+0x3e>
	}
	case PCD_TRANSCEIVE: {
		irqEn = 0x77;
 8000ff4:	2377      	movs	r3, #119	; 0x77
 8000ff6:	75bb      	strb	r3, [r7, #22]
		waitIRq = 0x30;
 8000ff8:	2330      	movs	r3, #48	; 0x30
 8000ffa:	757b      	strb	r3, [r7, #21]
		break;
 8000ffc:	bf00      	nop
	}
	default:
		break;
	}

	TM_MFRC522_WriteRegister(MFRC522_REG_COMM_IE_N, irqEn | 0x80);
 8000ffe:	7dbb      	ldrb	r3, [r7, #22]
 8001000:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8001004:	b2db      	uxtb	r3, r3
 8001006:	4619      	mov	r1, r3
 8001008:	2002      	movs	r0, #2
 800100a:	f7ff fee5 	bl	8000dd8 <TM_MFRC522_WriteRegister>
	TM_MFRC522_ClearBitMask(MFRC522_REG_COMM_IRQ, 0x80);
 800100e:	2180      	movs	r1, #128	; 0x80
 8001010:	2004      	movs	r0, #4
 8001012:	f7ff ff59 	bl	8000ec8 <TM_MFRC522_ClearBitMask>
	TM_MFRC522_SetBitMask(MFRC522_REG_FIFO_LEVEL, 0x80);
 8001016:	2180      	movs	r1, #128	; 0x80
 8001018:	200a      	movs	r0, #10
 800101a:	f7ff ff3b 	bl	8000e94 <TM_MFRC522_SetBitMask>

	TM_MFRC522_WriteRegister(MFRC522_REG_COMMAND, PCD_IDLE);
 800101e:	2100      	movs	r1, #0
 8001020:	2001      	movs	r0, #1
 8001022:	f7ff fed9 	bl	8000dd8 <TM_MFRC522_WriteRegister>

	//Writing data to the FIFO
	for (i = 0; i < sendLen; i++) {
 8001026:	2300      	movs	r3, #0
 8001028:	827b      	strh	r3, [r7, #18]
 800102a:	e00a      	b.n	8001042 <TM_MFRC522_ToCard+0x82>
		TM_MFRC522_WriteRegister(MFRC522_REG_FIFO_DATA, sendData[i]);
 800102c:	8a7b      	ldrh	r3, [r7, #18]
 800102e:	68ba      	ldr	r2, [r7, #8]
 8001030:	4413      	add	r3, r2
 8001032:	781b      	ldrb	r3, [r3, #0]
 8001034:	4619      	mov	r1, r3
 8001036:	2009      	movs	r0, #9
 8001038:	f7ff fece 	bl	8000dd8 <TM_MFRC522_WriteRegister>
	TM_MFRC522_SetBitMask(MFRC522_REG_FIFO_LEVEL, 0x80);

	TM_MFRC522_WriteRegister(MFRC522_REG_COMMAND, PCD_IDLE);

	//Writing data to the FIFO
	for (i = 0; i < sendLen; i++) {
 800103c:	8a7b      	ldrh	r3, [r7, #18]
 800103e:	3301      	adds	r3, #1
 8001040:	827b      	strh	r3, [r7, #18]
 8001042:	7bbb      	ldrb	r3, [r7, #14]
 8001044:	b29b      	uxth	r3, r3
 8001046:	8a7a      	ldrh	r2, [r7, #18]
 8001048:	429a      	cmp	r2, r3
 800104a:	d3ef      	bcc.n	800102c <TM_MFRC522_ToCard+0x6c>
		TM_MFRC522_WriteRegister(MFRC522_REG_FIFO_DATA, sendData[i]);
	}

	//Execute the command
	TM_MFRC522_WriteRegister(MFRC522_REG_COMMAND, command);
 800104c:	7bfb      	ldrb	r3, [r7, #15]
 800104e:	4619      	mov	r1, r3
 8001050:	2001      	movs	r0, #1
 8001052:	f7ff fec1 	bl	8000dd8 <TM_MFRC522_WriteRegister>
	if (command == PCD_TRANSCEIVE) {
 8001056:	7bfb      	ldrb	r3, [r7, #15]
 8001058:	2b0c      	cmp	r3, #12
 800105a:	d103      	bne.n	8001064 <TM_MFRC522_ToCard+0xa4>
		TM_MFRC522_SetBitMask(MFRC522_REG_BIT_FRAMING, 0x80);//StartSend=1,transmission of data starts
 800105c:	2180      	movs	r1, #128	; 0x80
 800105e:	200d      	movs	r0, #13
 8001060:	f7ff ff18 	bl	8000e94 <TM_MFRC522_SetBitMask>
	}

	//Waiting to receive data to complete
	i = 2000;//i according to the clock frequency adjustment, the operator M1 card maximum waiting time 25ms???
 8001064:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 8001068:	827b      	strh	r3, [r7, #18]
	do {
		//CommIrqReg[7..0]
		//Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq
		n = TM_MFRC522_ReadRegister(MFRC522_REG_COMM_IRQ);
 800106a:	2004      	movs	r0, #4
 800106c:	f7ff fee4 	bl	8000e38 <TM_MFRC522_ReadRegister>
 8001070:	4603      	mov	r3, r0
 8001072:	753b      	strb	r3, [r7, #20]
		i--;
 8001074:	8a7b      	ldrh	r3, [r7, #18]
 8001076:	3b01      	subs	r3, #1
 8001078:	827b      	strh	r3, [r7, #18]
	} while ((i != 0) && !(n & 0x01) && !(n & waitIRq));
 800107a:	8a7b      	ldrh	r3, [r7, #18]
 800107c:	2b00      	cmp	r3, #0
 800107e:	d00a      	beq.n	8001096 <TM_MFRC522_ToCard+0xd6>
 8001080:	7d3b      	ldrb	r3, [r7, #20]
 8001082:	f003 0301 	and.w	r3, r3, #1
 8001086:	2b00      	cmp	r3, #0
 8001088:	d105      	bne.n	8001096 <TM_MFRC522_ToCard+0xd6>
 800108a:	7d3a      	ldrb	r2, [r7, #20]
 800108c:	7d7b      	ldrb	r3, [r7, #21]
 800108e:	4013      	ands	r3, r2
 8001090:	b2db      	uxtb	r3, r3
 8001092:	2b00      	cmp	r3, #0
 8001094:	d0e9      	beq.n	800106a <TM_MFRC522_ToCard+0xaa>

	TM_MFRC522_ClearBitMask(MFRC522_REG_BIT_FRAMING, 0x80);		//StartSend=0
 8001096:	2180      	movs	r1, #128	; 0x80
 8001098:	200d      	movs	r0, #13
 800109a:	f7ff ff15 	bl	8000ec8 <TM_MFRC522_ClearBitMask>

	if (i != 0) {
 800109e:	8a7b      	ldrh	r3, [r7, #18]
 80010a0:	2b00      	cmp	r3, #0
 80010a2:	d057      	beq.n	8001154 <TM_MFRC522_ToCard+0x194>
		if (!(TM_MFRC522_ReadRegister(MFRC522_REG_ERROR) & 0x1B)) {
 80010a4:	2006      	movs	r0, #6
 80010a6:	f7ff fec7 	bl	8000e38 <TM_MFRC522_ReadRegister>
 80010aa:	4603      	mov	r3, r0
 80010ac:	f003 031b 	and.w	r3, r3, #27
 80010b0:	2b00      	cmp	r3, #0
 80010b2:	d14d      	bne.n	8001150 <TM_MFRC522_ToCard+0x190>
			status = MI_OK;
 80010b4:	2300      	movs	r3, #0
 80010b6:	75fb      	strb	r3, [r7, #23]
			if (n & irqEn & 0x01) {
 80010b8:	7d3a      	ldrb	r2, [r7, #20]
 80010ba:	7dbb      	ldrb	r3, [r7, #22]
 80010bc:	4013      	ands	r3, r2
 80010be:	b2db      	uxtb	r3, r3
 80010c0:	f003 0301 	and.w	r3, r3, #1
 80010c4:	2b00      	cmp	r3, #0
 80010c6:	d001      	beq.n	80010cc <TM_MFRC522_ToCard+0x10c>
				status = MI_NOTAGERR;
 80010c8:	2301      	movs	r3, #1
 80010ca:	75fb      	strb	r3, [r7, #23]
			}

			if (command == PCD_TRANSCEIVE) {
 80010cc:	7bfb      	ldrb	r3, [r7, #15]
 80010ce:	2b0c      	cmp	r3, #12
 80010d0:	d140      	bne.n	8001154 <TM_MFRC522_ToCard+0x194>
				n = TM_MFRC522_ReadRegister(MFRC522_REG_FIFO_LEVEL);
 80010d2:	200a      	movs	r0, #10
 80010d4:	f7ff feb0 	bl	8000e38 <TM_MFRC522_ReadRegister>
 80010d8:	4603      	mov	r3, r0
 80010da:	753b      	strb	r3, [r7, #20]
				lastBits = TM_MFRC522_ReadRegister(MFRC522_REG_CONTROL) & 0x07;
 80010dc:	200c      	movs	r0, #12
 80010de:	f7ff feab 	bl	8000e38 <TM_MFRC522_ReadRegister>
 80010e2:	4603      	mov	r3, r0
 80010e4:	f003 0307 	and.w	r3, r3, #7
 80010e8:	747b      	strb	r3, [r7, #17]
				if (lastBits) {
 80010ea:	7c7b      	ldrb	r3, [r7, #17]
 80010ec:	2b00      	cmp	r3, #0
 80010ee:	d00b      	beq.n	8001108 <TM_MFRC522_ToCard+0x148>
					*backLen = (n - 1) * 8 + lastBits;
 80010f0:	7d3b      	ldrb	r3, [r7, #20]
 80010f2:	3b01      	subs	r3, #1
 80010f4:	b29b      	uxth	r3, r3
 80010f6:	00db      	lsls	r3, r3, #3
 80010f8:	b29a      	uxth	r2, r3
 80010fa:	7c7b      	ldrb	r3, [r7, #17]
 80010fc:	b29b      	uxth	r3, r3
 80010fe:	4413      	add	r3, r2
 8001100:	b29a      	uxth	r2, r3
 8001102:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001104:	801a      	strh	r2, [r3, #0]
 8001106:	e005      	b.n	8001114 <TM_MFRC522_ToCard+0x154>
				} else {
					*backLen = n * 8;
 8001108:	7d3b      	ldrb	r3, [r7, #20]
 800110a:	b29b      	uxth	r3, r3
 800110c:	00db      	lsls	r3, r3, #3
 800110e:	b29a      	uxth	r2, r3
 8001110:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001112:	801a      	strh	r2, [r3, #0]
				}

				if (n == 0) {
 8001114:	7d3b      	ldrb	r3, [r7, #20]
 8001116:	2b00      	cmp	r3, #0
 8001118:	d101      	bne.n	800111e <TM_MFRC522_ToCard+0x15e>
					n = 1;
 800111a:	2301      	movs	r3, #1
 800111c:	753b      	strb	r3, [r7, #20]
				}
				if (n > MFRC522_MAX_LEN) {
 800111e:	7d3b      	ldrb	r3, [r7, #20]
 8001120:	2b10      	cmp	r3, #16
 8001122:	d901      	bls.n	8001128 <TM_MFRC522_ToCard+0x168>
					n = MFRC522_MAX_LEN;
 8001124:	2310      	movs	r3, #16
 8001126:	753b      	strb	r3, [r7, #20]
				}

				//Reading the received data in FIFO
				for (i = 0; i < n; i++) {
 8001128:	2300      	movs	r3, #0
 800112a:	827b      	strh	r3, [r7, #18]
 800112c:	e00a      	b.n	8001144 <TM_MFRC522_ToCard+0x184>
					backData[i] = TM_MFRC522_ReadRegister(
 800112e:	8a7b      	ldrh	r3, [r7, #18]
 8001130:	687a      	ldr	r2, [r7, #4]
 8001132:	18d4      	adds	r4, r2, r3
 8001134:	2009      	movs	r0, #9
 8001136:	f7ff fe7f 	bl	8000e38 <TM_MFRC522_ReadRegister>
 800113a:	4603      	mov	r3, r0
 800113c:	7023      	strb	r3, [r4, #0]
				if (n > MFRC522_MAX_LEN) {
					n = MFRC522_MAX_LEN;
				}

				//Reading the received data in FIFO
				for (i = 0; i < n; i++) {
 800113e:	8a7b      	ldrh	r3, [r7, #18]
 8001140:	3301      	adds	r3, #1
 8001142:	827b      	strh	r3, [r7, #18]
 8001144:	7d3b      	ldrb	r3, [r7, #20]
 8001146:	b29b      	uxth	r3, r3
 8001148:	8a7a      	ldrh	r2, [r7, #18]
 800114a:	429a      	cmp	r2, r3
 800114c:	d3ef      	bcc.n	800112e <TM_MFRC522_ToCard+0x16e>
 800114e:	e001      	b.n	8001154 <TM_MFRC522_ToCard+0x194>
					backData[i] = TM_MFRC522_ReadRegister(
					MFRC522_REG_FIFO_DATA);
				}
			}
		} else {
			status = MI_ERR;
 8001150:	2302      	movs	r3, #2
 8001152:	75fb      	strb	r3, [r7, #23]
		}
	}

	return status;
 8001154:	7dfb      	ldrb	r3, [r7, #23]
}
 8001156:	4618      	mov	r0, r3
 8001158:	371c      	adds	r7, #28
 800115a:	46bd      	mov	sp, r7
 800115c:	bd90      	pop	{r4, r7, pc}
 800115e:	bf00      	nop

08001160 <TM_MFRC522_Anticoll>:
//-------------------------------------------------
TM_MFRC522_Status_t TM_MFRC522_Anticoll(uint8_t* serNum) {
 8001160:	b580      	push	{r7, lr}
 8001162:	b086      	sub	sp, #24
 8001164:	af02      	add	r7, sp, #8
 8001166:	6078      	str	r0, [r7, #4]
	TM_MFRC522_Status_t status;
	uint8_t i;
	uint8_t serNumCheck = 0;
 8001168:	2300      	movs	r3, #0
 800116a:	737b      	strb	r3, [r7, #13]
	uint16_t unLen;

	TM_MFRC522_WriteRegister(MFRC522_REG_BIT_FRAMING, 0x00);//TxLastBists = BitFramingReg[2..0]
 800116c:	2100      	movs	r1, #0
 800116e:	200d      	movs	r0, #13
 8001170:	f7ff fe32 	bl	8000dd8 <TM_MFRC522_WriteRegister>

	serNum[0] = PICC_ANTICOLL;
 8001174:	687b      	ldr	r3, [r7, #4]
 8001176:	2293      	movs	r2, #147	; 0x93
 8001178:	701a      	strb	r2, [r3, #0]
	serNum[1] = 0x20;
 800117a:	687b      	ldr	r3, [r7, #4]
 800117c:	3301      	adds	r3, #1
 800117e:	2220      	movs	r2, #32
 8001180:	701a      	strb	r2, [r3, #0]
	status = TM_MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);
 8001182:	f107 030a 	add.w	r3, r7, #10
 8001186:	9300      	str	r3, [sp, #0]
 8001188:	687b      	ldr	r3, [r7, #4]
 800118a:	2202      	movs	r2, #2
 800118c:	6879      	ldr	r1, [r7, #4]
 800118e:	200c      	movs	r0, #12
 8001190:	f7ff ff16 	bl	8000fc0 <TM_MFRC522_ToCard>
 8001194:	4603      	mov	r3, r0
 8001196:	73fb      	strb	r3, [r7, #15]

	if (status == MI_OK) {
 8001198:	7bfb      	ldrb	r3, [r7, #15]
 800119a:	2b00      	cmp	r3, #0
 800119c:	d118      	bne.n	80011d0 <TM_MFRC522_Anticoll+0x70>
		//Check card serial number
		for (i = 0; i < 4; i++) {
 800119e:	2300      	movs	r3, #0
 80011a0:	73bb      	strb	r3, [r7, #14]
 80011a2:	e009      	b.n	80011b8 <TM_MFRC522_Anticoll+0x58>
			serNumCheck ^= serNum[i];
 80011a4:	7bbb      	ldrb	r3, [r7, #14]
 80011a6:	687a      	ldr	r2, [r7, #4]
 80011a8:	4413      	add	r3, r2
 80011aa:	781a      	ldrb	r2, [r3, #0]
 80011ac:	7b7b      	ldrb	r3, [r7, #13]
 80011ae:	4053      	eors	r3, r2
 80011b0:	737b      	strb	r3, [r7, #13]
	serNum[1] = 0x20;
	status = TM_MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);

	if (status == MI_OK) {
		//Check card serial number
		for (i = 0; i < 4; i++) {
 80011b2:	7bbb      	ldrb	r3, [r7, #14]
 80011b4:	3301      	adds	r3, #1
 80011b6:	73bb      	strb	r3, [r7, #14]
 80011b8:	7bbb      	ldrb	r3, [r7, #14]
 80011ba:	2b03      	cmp	r3, #3
 80011bc:	d9f2      	bls.n	80011a4 <TM_MFRC522_Anticoll+0x44>
			serNumCheck ^= serNum[i];
		}
		if (serNumCheck != serNum[i]) {
 80011be:	7bbb      	ldrb	r3, [r7, #14]
 80011c0:	687a      	ldr	r2, [r7, #4]
 80011c2:	4413      	add	r3, r2
 80011c4:	781b      	ldrb	r3, [r3, #0]
 80011c6:	7b7a      	ldrb	r2, [r7, #13]
 80011c8:	429a      	cmp	r2, r3
 80011ca:	d001      	beq.n	80011d0 <TM_MFRC522_Anticoll+0x70>
			status = MI_ERR;
 80011cc:	2302      	movs	r3, #2
 80011ce:	73fb      	strb	r3, [r7, #15]
		}
	}
	return status;
 80011d0:	7bfb      	ldrb	r3, [r7, #15]
}
 80011d2:	4618      	mov	r0, r3
 80011d4:	3710      	adds	r7, #16
 80011d6:	46bd      	mov	sp, r7
 80011d8:	bd80      	pop	{r7, pc}
 80011da:	bf00      	nop

080011dc <TM_MFRC522_CalculateCRC>:

void TM_MFRC522_CalculateCRC(uint8_t* pIndata, uint8_t len, uint8_t* pOutData) {
 80011dc:	b590      	push	{r4, r7, lr}
 80011de:	b087      	sub	sp, #28
 80011e0:	af00      	add	r7, sp, #0
 80011e2:	60f8      	str	r0, [r7, #12]
 80011e4:	460b      	mov	r3, r1
 80011e6:	607a      	str	r2, [r7, #4]
 80011e8:	72fb      	strb	r3, [r7, #11]
	uint8_t i, n;

	TM_MFRC522_ClearBitMask(MFRC522_REG_DIV_IRQ, 0x04);			//CRCIrq = 0
 80011ea:	2104      	movs	r1, #4
 80011ec:	2005      	movs	r0, #5
 80011ee:	f7ff fe6b 	bl	8000ec8 <TM_MFRC522_ClearBitMask>
	TM_MFRC522_SetBitMask(MFRC522_REG_FIFO_LEVEL, 0x80);//Clear the FIFO pointer
 80011f2:	2180      	movs	r1, #128	; 0x80
 80011f4:	200a      	movs	r0, #10
 80011f6:	f7ff fe4d 	bl	8000e94 <TM_MFRC522_SetBitMask>
	//Write_MFRC522(CommandReg, PCD_IDLE);

	//Writing data to the FIFO	
	for (i = 0; i < len; i++) {
 80011fa:	2300      	movs	r3, #0
 80011fc:	75fb      	strb	r3, [r7, #23]
 80011fe:	e00a      	b.n	8001216 <TM_MFRC522_CalculateCRC+0x3a>
		TM_MFRC522_WriteRegister(MFRC522_REG_FIFO_DATA, *(pIndata + i));
 8001200:	7dfb      	ldrb	r3, [r7, #23]
 8001202:	68fa      	ldr	r2, [r7, #12]
 8001204:	4413      	add	r3, r2
 8001206:	781b      	ldrb	r3, [r3, #0]
 8001208:	4619      	mov	r1, r3
 800120a:	2009      	movs	r0, #9
 800120c:	f7ff fde4 	bl	8000dd8 <TM_MFRC522_WriteRegister>
	TM_MFRC522_ClearBitMask(MFRC522_REG_DIV_IRQ, 0x04);			//CRCIrq = 0
	TM_MFRC522_SetBitMask(MFRC522_REG_FIFO_LEVEL, 0x80);//Clear the FIFO pointer
	//Write_MFRC522(CommandReg, PCD_IDLE);

	//Writing data to the FIFO	
	for (i = 0; i < len; i++) {
 8001210:	7dfb      	ldrb	r3, [r7, #23]
 8001212:	3301      	adds	r3, #1
 8001214:	75fb      	strb	r3, [r7, #23]
 8001216:	7dfa      	ldrb	r2, [r7, #23]
 8001218:	7afb      	ldrb	r3, [r7, #11]
 800121a:	429a      	cmp	r2, r3
 800121c:	d3f0      	bcc.n	8001200 <TM_MFRC522_CalculateCRC+0x24>
		TM_MFRC522_WriteRegister(MFRC522_REG_FIFO_DATA, *(pIndata + i));
	}
	TM_MFRC522_WriteRegister(MFRC522_REG_COMMAND, PCD_CALCCRC);
 800121e:	2103      	movs	r1, #3
 8001220:	2001      	movs	r0, #1
 8001222:	f7ff fdd9 	bl	8000dd8 <TM_MFRC522_WriteRegister>

	//Wait CRC calculation is complete
	i = 0xFF;
 8001226:	23ff      	movs	r3, #255	; 0xff
 8001228:	75fb      	strb	r3, [r7, #23]
	do {
		n = TM_MFRC522_ReadRegister(MFRC522_REG_DIV_IRQ);
 800122a:	2005      	movs	r0, #5
 800122c:	f7ff fe04 	bl	8000e38 <TM_MFRC522_ReadRegister>
 8001230:	4603      	mov	r3, r0
 8001232:	75bb      	strb	r3, [r7, #22]
		i--;
 8001234:	7dfb      	ldrb	r3, [r7, #23]
 8001236:	3b01      	subs	r3, #1
 8001238:	75fb      	strb	r3, [r7, #23]
	} while ((i != 0) && !(n & 0x04));			//CRCIrq = 1
 800123a:	7dfb      	ldrb	r3, [r7, #23]
 800123c:	2b00      	cmp	r3, #0
 800123e:	d004      	beq.n	800124a <TM_MFRC522_CalculateCRC+0x6e>
 8001240:	7dbb      	ldrb	r3, [r7, #22]
 8001242:	f003 0304 	and.w	r3, r3, #4
 8001246:	2b00      	cmp	r3, #0
 8001248:	d0ef      	beq.n	800122a <TM_MFRC522_CalculateCRC+0x4e>

	//Read CRC calculation result
	pOutData[0] = TM_MFRC522_ReadRegister(MFRC522_REG_CRC_RESULT_L);
 800124a:	2022      	movs	r0, #34	; 0x22
 800124c:	f7ff fdf4 	bl	8000e38 <TM_MFRC522_ReadRegister>
 8001250:	4603      	mov	r3, r0
 8001252:	461a      	mov	r2, r3
 8001254:	687b      	ldr	r3, [r7, #4]
 8001256:	701a      	strb	r2, [r3, #0]
	pOutData[1] = TM_MFRC522_ReadRegister(MFRC522_REG_CRC_RESULT_M);
 8001258:	687b      	ldr	r3, [r7, #4]
 800125a:	1c5c      	adds	r4, r3, #1
 800125c:	2021      	movs	r0, #33	; 0x21
 800125e:	f7ff fdeb 	bl	8000e38 <TM_MFRC522_ReadRegister>
 8001262:	4603      	mov	r3, r0
 8001264:	7023      	strb	r3, [r4, #0]
}
 8001266:	bf00      	nop
 8001268:	371c      	adds	r7, #28
 800126a:	46bd      	mov	sp, r7
 800126c:	bd90      	pop	{r4, r7, pc}
 800126e:	bf00      	nop

08001270 <TM_MFRC522_Halt>:
	}

	return status;
}

void TM_MFRC522_Halt(void) {
 8001270:	b580      	push	{r7, lr}
 8001272:	b084      	sub	sp, #16
 8001274:	af02      	add	r7, sp, #8
	uint16_t unLen;
	uint8_t buff[4];

	buff[0] = PICC_HALT;
 8001276:	2350      	movs	r3, #80	; 0x50
 8001278:	703b      	strb	r3, [r7, #0]
	buff[1] = 0;
 800127a:	2300      	movs	r3, #0
 800127c:	707b      	strb	r3, [r7, #1]
	TM_MFRC522_CalculateCRC(buff, 2, &buff[2]);
 800127e:	463b      	mov	r3, r7
 8001280:	1c9a      	adds	r2, r3, #2
 8001282:	463b      	mov	r3, r7
 8001284:	2102      	movs	r1, #2
 8001286:	4618      	mov	r0, r3
 8001288:	f7ff ffa8 	bl	80011dc <TM_MFRC522_CalculateCRC>

	TM_MFRC522_ToCard(PCD_TRANSCEIVE, buff, 4, buff, &unLen);
 800128c:	463a      	mov	r2, r7
 800128e:	4639      	mov	r1, r7
 8001290:	1dbb      	adds	r3, r7, #6
 8001292:	9300      	str	r3, [sp, #0]
 8001294:	4613      	mov	r3, r2
 8001296:	2204      	movs	r2, #4
 8001298:	200c      	movs	r0, #12
 800129a:	f7ff fe91 	bl	8000fc0 <TM_MFRC522_ToCard>
}
 800129e:	bf00      	nop
 80012a0:	3708      	adds	r7, #8
 80012a2:	46bd      	mov	sp, r7
 80012a4:	bd80      	pop	{r7, pc}
 80012a6:	bf00      	nop

080012a8 <zapisanie>:

void zapisanie(void) {
 80012a8:	b5b0      	push	{r4, r5, r7, lr}
 80012aa:	b09a      	sub	sp, #104	; 0x68
 80012ac:	af04      	add	r7, sp, #16
	char bufferRFID[30];
	char bufferDisplay[10];
	unsigned char MyID[5] = { 0x1a, 0x18, 0x3a, 0x45, 0x7d };
 80012ae:	4ad2      	ldr	r2, [pc, #840]	; (80015f8 <zapisanie+0x350>)
 80012b0:	f107 0314 	add.w	r3, r7, #20
 80012b4:	6810      	ldr	r0, [r2, #0]
 80012b6:	6018      	str	r0, [r3, #0]
 80012b8:	7912      	ldrb	r2, [r2, #4]
 80012ba:	711a      	strb	r2, [r3, #4]
	unsigned char CardID[5];
	unsigned char newCardID[5];
	int pom = 0;
 80012bc:	2300      	movs	r3, #0
 80012be:	64bb      	str	r3, [r7, #72]	; 0x48
	for (int x = 0; x <= 5; x++) {
 80012c0:	2300      	movs	r3, #0
 80012c2:	657b      	str	r3, [r7, #84]	; 0x54
 80012c4:	e192      	b.n	80015ec <zapisanie+0x344>
		if (pom == 0) {
 80012c6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80012c8:	2b00      	cmp	r3, #0
 80012ca:	f040 81b1 	bne.w	8001630 <zapisanie+0x388>
			if (TM_MFRC522_Check(CardID) == MI_OK) {
 80012ce:	f107 030c 	add.w	r3, r7, #12
 80012d2:	4618      	mov	r0, r3
 80012d4:	f7ff fe5a 	bl	8000f8c <TM_MFRC522_Check>
 80012d8:	4603      	mov	r3, r0
 80012da:	2b00      	cmp	r3, #0
 80012dc:	f040 814f 	bne.w	800157e <zapisanie+0x2d6>

				sprintf(bufferRFID, "[%x-%x-%x-%x-%x]", CardID[0], CardID[1],
 80012e0:	7b3b      	ldrb	r3, [r7, #12]
 80012e2:	461c      	mov	r4, r3
 80012e4:	7b7b      	ldrb	r3, [r7, #13]
 80012e6:	461d      	mov	r5, r3
						CardID[2], CardID[3], CardID[4]);
 80012e8:	7bbb      	ldrb	r3, [r7, #14]
 80012ea:	7bfa      	ldrb	r2, [r7, #15]
 80012ec:	7c39      	ldrb	r1, [r7, #16]
	int pom = 0;
	for (int x = 0; x <= 5; x++) {
		if (pom == 0) {
			if (TM_MFRC522_Check(CardID) == MI_OK) {

				sprintf(bufferRFID, "[%x-%x-%x-%x-%x]", CardID[0], CardID[1],
 80012ee:	f107 0028 	add.w	r0, r7, #40	; 0x28
 80012f2:	9102      	str	r1, [sp, #8]
 80012f4:	9201      	str	r2, [sp, #4]
 80012f6:	9300      	str	r3, [sp, #0]
 80012f8:	462b      	mov	r3, r5
 80012fa:	4622      	mov	r2, r4
 80012fc:	49bf      	ldr	r1, [pc, #764]	; (80015fc <zapisanie+0x354>)
 80012fe:	f002 f97b 	bl	80035f8 <siprintf>
						CardID[2], CardID[3], CardID[4]);

				if (karta_v_zozname(CardID) == MI_OK) {
 8001302:	f107 030c 	add.w	r3, r7, #12
 8001306:	4618      	mov	r0, r3
 8001308:	f000 fb3c 	bl	8001984 <karta_v_zozname>
 800130c:	4603      	mov	r3, r0
 800130e:	2b00      	cmp	r3, #0
 8001310:	f040 8104 	bne.w	800151c <zapisanie+0x274>

					Send_string_uart("Prilozte novu kartu\n\r");
 8001314:	48ba      	ldr	r0, [pc, #744]	; (8001600 <zapisanie+0x358>)
 8001316:	f001 fd7d 	bl	8002e14 <Send_string_uart>

					lcdClearDisplay(decodeRgbValue(255, 255, 255));
 800131a:	22ff      	movs	r2, #255	; 0xff
 800131c:	21ff      	movs	r1, #255	; 0xff
 800131e:	20ff      	movs	r0, #255	; 0xff
 8001320:	f001 faaa 	bl	8002878 <decodeRgbValue>
 8001324:	4603      	mov	r3, r0
 8001326:	4618      	mov	r0, r3
 8001328:	f000 ff9e 	bl	8002268 <lcdClearDisplay>
					sprintf(bufferDisplay, "Prilozte novu kartu");
 800132c:	f107 031c 	add.w	r3, r7, #28
 8001330:	4ab4      	ldr	r2, [pc, #720]	; (8001604 <zapisanie+0x35c>)
 8001332:	461c      	mov	r4, r3
 8001334:	4615      	mov	r5, r2
 8001336:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001338:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800133a:	682b      	ldr	r3, [r5, #0]
 800133c:	6023      	str	r3, [r4, #0]
					lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
 800133e:	22ff      	movs	r2, #255	; 0xff
 8001340:	2100      	movs	r1, #0
 8001342:	2000      	movs	r0, #0
 8001344:	f001 fa98 	bl	8002878 <decodeRgbValue>
 8001348:	4603      	mov	r3, r0
 800134a:	461c      	mov	r4, r3
 800134c:	22ff      	movs	r2, #255	; 0xff
 800134e:	21ff      	movs	r1, #255	; 0xff
 8001350:	20ff      	movs	r0, #255	; 0xff
 8001352:	f001 fa91 	bl	8002878 <decodeRgbValue>
 8001356:	4603      	mov	r3, r0
 8001358:	f107 001c 	add.w	r0, r7, #28
 800135c:	9300      	str	r3, [sp, #0]
 800135e:	4623      	mov	r3, r4
 8001360:	2232      	movs	r2, #50	; 0x32
 8001362:	210a      	movs	r1, #10
 8001364:	f001 faa4 	bl	80028b0 <lcdPutS>
							decodeRgbValue(255, 255, 255));

					Delay(3);
 8001368:	2003      	movs	r0, #3
 800136a:	f001 fd27 	bl	8002dbc <Delay>

					for (int i = 0; i <= 10; i++) {
 800136e:	2300      	movs	r3, #0
 8001370:	653b      	str	r3, [r7, #80]	; 0x50
 8001372:	e0ce      	b.n	8001512 <zapisanie+0x26a>
						if (TM_MFRC522_Check(newCardID) == MI_OK) {
 8001374:	1d3b      	adds	r3, r7, #4
 8001376:	4618      	mov	r0, r3
 8001378:	f7ff fe08 	bl	8000f8c <TM_MFRC522_Check>
 800137c:	4603      	mov	r3, r0
 800137e:	2b00      	cmp	r3, #0
 8001380:	f040 80ba 	bne.w	80014f8 <zapisanie+0x250>
							//if (karta_v_zozname(CardID) != MI_OK) {
							if (karta_v_zozname(newCardID) == MI_ERR) {
 8001384:	1d3b      	adds	r3, r7, #4
 8001386:	4618      	mov	r0, r3
 8001388:	f000 fafc 	bl	8001984 <karta_v_zozname>
 800138c:	4603      	mov	r3, r0
 800138e:	2b02      	cmp	r3, #2
 8001390:	f040 8081 	bne.w	8001496 <zapisanie+0x1ee>
								TM_MFRC522_Status_t stav_pridania =
 8001394:	1d3b      	adds	r3, r7, #4
 8001396:	4618      	mov	r0, r3
 8001398:	f000 fb3e 	bl	8001a18 <pridaj_kartu>
 800139c:	4603      	mov	r3, r0
 800139e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
										pridaj_kartu(newCardID);
								if (stav_pridania == MI_OK) {
 80013a2:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80013a6:	2b00      	cmp	r3, #0
 80013a8:	d143      	bne.n	8001432 <zapisanie+0x18a>

									Send_string_uart("Uspesne zapisanie\n\r");
 80013aa:	4897      	ldr	r0, [pc, #604]	; (8001608 <zapisanie+0x360>)
 80013ac:	f001 fd32 	bl	8002e14 <Send_string_uart>
									lcdClearDisplay(
 80013b0:	22ff      	movs	r2, #255	; 0xff
 80013b2:	21ff      	movs	r1, #255	; 0xff
 80013b4:	20ff      	movs	r0, #255	; 0xff
 80013b6:	f001 fa5f 	bl	8002878 <decodeRgbValue>
 80013ba:	4603      	mov	r3, r0
 80013bc:	4618      	mov	r0, r3
 80013be:	f000 ff53 	bl	8002268 <lcdClearDisplay>
											decodeRgbValue(255, 255, 255));
									sprintf(bufferDisplay, "Uspesne zapisanie");
 80013c2:	f107 031c 	add.w	r3, r7, #28
 80013c6:	4a91      	ldr	r2, [pc, #580]	; (800160c <zapisanie+0x364>)
 80013c8:	461c      	mov	r4, r3
 80013ca:	4615      	mov	r5, r2
 80013cc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80013ce:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80013d0:	682b      	ldr	r3, [r5, #0]
 80013d2:	8023      	strh	r3, [r4, #0]
									//odober_kartu(newCardID);
									lcdPutS(bufferDisplay, 10, 50,
 80013d4:	22ff      	movs	r2, #255	; 0xff
 80013d6:	2100      	movs	r1, #0
 80013d8:	2000      	movs	r0, #0
 80013da:	f001 fa4d 	bl	8002878 <decodeRgbValue>
 80013de:	4603      	mov	r3, r0
 80013e0:	461c      	mov	r4, r3
 80013e2:	22ff      	movs	r2, #255	; 0xff
 80013e4:	21ff      	movs	r1, #255	; 0xff
 80013e6:	20ff      	movs	r0, #255	; 0xff
 80013e8:	f001 fa46 	bl	8002878 <decodeRgbValue>
 80013ec:	4603      	mov	r3, r0
 80013ee:	f107 001c 	add.w	r0, r7, #28
 80013f2:	9300      	str	r3, [sp, #0]
 80013f4:	4623      	mov	r3, r4
 80013f6:	2232      	movs	r2, #50	; 0x32
 80013f8:	210a      	movs	r1, #10
 80013fa:	f001 fa59 	bl	80028b0 <lcdPutS>
											decodeRgbValue(0, 0, 255),
											decodeRgbValue(255, 255, 255));

									//vykreslenie OK
									ok();
 80013fe:	f001 fb09 	bl	8002a14 <ok>
									//blikanie zltej LED
									for (int c = 0; c < 6; c++) {
 8001402:	2300      	movs	r3, #0
 8001404:	64fb      	str	r3, [r7, #76]	; 0x4c
 8001406:	e009      	b.n	800141c <zapisanie+0x174>
										GPIO_ToggleBits(GPIOA, GPIO_Pin_4);
 8001408:	2110      	movs	r1, #16
 800140a:	4881      	ldr	r0, [pc, #516]	; (8001610 <zapisanie+0x368>)
 800140c:	f7ff f8c2 	bl	8000594 <GPIO_ToggleBits>
										Delay_us(200000);
 8001410:	4880      	ldr	r0, [pc, #512]	; (8001614 <zapisanie+0x36c>)
 8001412:	f001 fced 	bl	8002df0 <Delay_us>
											decodeRgbValue(255, 255, 255));

									//vykreslenie OK
									ok();
									//blikanie zltej LED
									for (int c = 0; c < 6; c++) {
 8001416:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001418:	3301      	adds	r3, #1
 800141a:	64fb      	str	r3, [r7, #76]	; 0x4c
 800141c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800141e:	2b05      	cmp	r3, #5
 8001420:	ddf2      	ble.n	8001408 <zapisanie+0x160>
										GPIO_ToggleBits(GPIOA, GPIO_Pin_4);
										Delay_us(200000);
									}
									Delay(1);
 8001422:	2001      	movs	r0, #1
 8001424:	f001 fcca 	bl	8002dbc <Delay>
									pom = 1;
 8001428:	2301      	movs	r3, #1
 800142a:	64bb      	str	r3, [r7, #72]	; 0x48
									//i = 10;
									//Delay(3);
									welcome();
 800142c:	f001 fa7c 	bl	8002928 <welcome>
									goto koniec;
 8001430:	e0ff      	b.n	8001632 <zapisanie+0x38a>
								} else if (stav_pridania == MI_ERR) {
 8001432:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8001436:	2b02      	cmp	r3, #2
 8001438:	d161      	bne.n	80014fe <zapisanie+0x256>

									lcdClearDisplay(
 800143a:	22ff      	movs	r2, #255	; 0xff
 800143c:	21ff      	movs	r1, #255	; 0xff
 800143e:	20ff      	movs	r0, #255	; 0xff
 8001440:	f001 fa1a 	bl	8002878 <decodeRgbValue>
 8001444:	4603      	mov	r3, r0
 8001446:	4618      	mov	r0, r3
 8001448:	f000 ff0e 	bl	8002268 <lcdClearDisplay>
											decodeRgbValue(255, 255, 255));
									sprintf(bufferDisplay, "Zoznam je plny");
 800144c:	f107 031c 	add.w	r3, r7, #28
 8001450:	4a71      	ldr	r2, [pc, #452]	; (8001618 <zapisanie+0x370>)
 8001452:	461c      	mov	r4, r3
 8001454:	4613      	mov	r3, r2
 8001456:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8001458:	c407      	stmia	r4!, {r0, r1, r2}
 800145a:	8023      	strh	r3, [r4, #0]
 800145c:	3402      	adds	r4, #2
 800145e:	0c1b      	lsrs	r3, r3, #16
 8001460:	7023      	strb	r3, [r4, #0]
									lcdPutS(bufferDisplay, 10, 50,
 8001462:	2200      	movs	r2, #0
 8001464:	2100      	movs	r1, #0
 8001466:	20ff      	movs	r0, #255	; 0xff
 8001468:	f001 fa06 	bl	8002878 <decodeRgbValue>
 800146c:	4603      	mov	r3, r0
 800146e:	461c      	mov	r4, r3
 8001470:	22ff      	movs	r2, #255	; 0xff
 8001472:	21ff      	movs	r1, #255	; 0xff
 8001474:	20ff      	movs	r0, #255	; 0xff
 8001476:	f001 f9ff 	bl	8002878 <decodeRgbValue>
 800147a:	4603      	mov	r3, r0
 800147c:	f107 001c 	add.w	r0, r7, #28
 8001480:	9300      	str	r3, [sp, #0]
 8001482:	4623      	mov	r3, r4
 8001484:	2232      	movs	r2, #50	; 0x32
 8001486:	210a      	movs	r1, #10
 8001488:	f001 fa12 	bl	80028b0 <lcdPutS>
											decodeRgbValue(255, 0, 0),
											decodeRgbValue(255, 255, 255));

									//vykreslenie Vykricnika
									vykricnik();
 800148c:	f001 fafa 	bl	8002a84 <vykricnik>
									welcome();
 8001490:	f001 fa4a 	bl	8002928 <welcome>
									goto koniec;
 8001494:	e0cd      	b.n	8001632 <zapisanie+0x38a>

								}

							} else {
								lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001496:	22ff      	movs	r2, #255	; 0xff
 8001498:	21ff      	movs	r1, #255	; 0xff
 800149a:	20ff      	movs	r0, #255	; 0xff
 800149c:	f001 f9ec 	bl	8002878 <decodeRgbValue>
 80014a0:	4603      	mov	r3, r0
 80014a2:	4618      	mov	r0, r3
 80014a4:	f000 fee0 	bl	8002268 <lcdClearDisplay>
								sprintf(bufferDisplay,
 80014a8:	f107 031c 	add.w	r3, r7, #28
 80014ac:	4a5b      	ldr	r2, [pc, #364]	; (800161c <zapisanie+0x374>)
 80014ae:	461c      	mov	r4, r3
 80014b0:	4615      	mov	r5, r2
 80014b2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80014b4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80014b6:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80014ba:	c403      	stmia	r4!, {r0, r1}
 80014bc:	8022      	strh	r2, [r4, #0]
 80014be:	3402      	adds	r4, #2
 80014c0:	0c13      	lsrs	r3, r2, #16
 80014c2:	7023      	strb	r3, [r4, #0]
										"Karta uz je v      zozname");
								lcdPutS(bufferDisplay, 10, 50,
 80014c4:	2200      	movs	r2, #0
 80014c6:	2100      	movs	r1, #0
 80014c8:	20ff      	movs	r0, #255	; 0xff
 80014ca:	f001 f9d5 	bl	8002878 <decodeRgbValue>
 80014ce:	4603      	mov	r3, r0
 80014d0:	461c      	mov	r4, r3
 80014d2:	22ff      	movs	r2, #255	; 0xff
 80014d4:	21ff      	movs	r1, #255	; 0xff
 80014d6:	20ff      	movs	r0, #255	; 0xff
 80014d8:	f001 f9ce 	bl	8002878 <decodeRgbValue>
 80014dc:	4603      	mov	r3, r0
 80014de:	f107 001c 	add.w	r0, r7, #28
 80014e2:	9300      	str	r3, [sp, #0]
 80014e4:	4623      	mov	r3, r4
 80014e6:	2232      	movs	r2, #50	; 0x32
 80014e8:	210a      	movs	r1, #10
 80014ea:	f001 f9e1 	bl	80028b0 <lcdPutS>
										decodeRgbValue(255, 0, 0),
										decodeRgbValue(255, 255, 255));

								//vykreslenie Vykricnika
								vykricnik();
 80014ee:	f001 fac9 	bl	8002a84 <vykricnik>
								welcome();
 80014f2:	f001 fa19 	bl	8002928 <welcome>
								goto koniec;
 80014f6:	e09c      	b.n	8001632 <zapisanie+0x38a>
							}

						} else {
							Delay(1);
 80014f8:	2001      	movs	r0, #1
 80014fa:	f001 fc5f 	bl	8002dbc <Delay>
						}
						if (i == 10) {
 80014fe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8001500:	2b0a      	cmp	r3, #10
 8001502:	d103      	bne.n	800150c <zapisanie+0x264>
							x = 5;
 8001504:	2305      	movs	r3, #5
 8001506:	657b      	str	r3, [r7, #84]	; 0x54
							welcome();
 8001508:	f001 fa0e 	bl	8002928 <welcome>
					lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
							decodeRgbValue(255, 255, 255));

					Delay(3);

					for (int i = 0; i <= 10; i++) {
 800150c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800150e:	3301      	adds	r3, #1
 8001510:	653b      	str	r3, [r7, #80]	; 0x50
 8001512:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8001514:	2b0a      	cmp	r3, #10
 8001516:	f77f af2d 	ble.w	8001374 <zapisanie+0xcc>
 800151a:	e064      	b.n	80015e6 <zapisanie+0x33e>
							welcome();
						}
					}

				} else {
					Send_string_uart("Neopravnena karta\n\r");
 800151c:	4840      	ldr	r0, [pc, #256]	; (8001620 <zapisanie+0x378>)
 800151e:	f001 fc79 	bl	8002e14 <Send_string_uart>
					x = 5;
 8001522:	2305      	movs	r3, #5
 8001524:	657b      	str	r3, [r7, #84]	; 0x54
					lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001526:	22ff      	movs	r2, #255	; 0xff
 8001528:	21ff      	movs	r1, #255	; 0xff
 800152a:	20ff      	movs	r0, #255	; 0xff
 800152c:	f001 f9a4 	bl	8002878 <decodeRgbValue>
 8001530:	4603      	mov	r3, r0
 8001532:	4618      	mov	r0, r3
 8001534:	f000 fe98 	bl	8002268 <lcdClearDisplay>
					sprintf(bufferDisplay, "Neopravnena karta");
 8001538:	f107 031c 	add.w	r3, r7, #28
 800153c:	4a39      	ldr	r2, [pc, #228]	; (8001624 <zapisanie+0x37c>)
 800153e:	461c      	mov	r4, r3
 8001540:	4615      	mov	r5, r2
 8001542:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001544:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8001546:	682b      	ldr	r3, [r5, #0]
 8001548:	8023      	strh	r3, [r4, #0]
					lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(255, 0, 0),
 800154a:	2200      	movs	r2, #0
 800154c:	2100      	movs	r1, #0
 800154e:	20ff      	movs	r0, #255	; 0xff
 8001550:	f001 f992 	bl	8002878 <decodeRgbValue>
 8001554:	4603      	mov	r3, r0
 8001556:	461c      	mov	r4, r3
 8001558:	22ff      	movs	r2, #255	; 0xff
 800155a:	21ff      	movs	r1, #255	; 0xff
 800155c:	20ff      	movs	r0, #255	; 0xff
 800155e:	f001 f98b 	bl	8002878 <decodeRgbValue>
 8001562:	4603      	mov	r3, r0
 8001564:	f107 001c 	add.w	r0, r7, #28
 8001568:	9300      	str	r3, [sp, #0]
 800156a:	4623      	mov	r3, r4
 800156c:	2232      	movs	r2, #50	; 0x32
 800156e:	210a      	movs	r1, #10
 8001570:	f001 f99e 	bl	80028b0 <lcdPutS>
							decodeRgbValue(255, 255, 255));

					//vykreslenie Vykricnika
					vykricnik();
 8001574:	f001 fa86 	bl	8002a84 <vykricnik>
					welcome();
 8001578:	f001 f9d6 	bl	8002928 <welcome>
 800157c:	e033      	b.n	80015e6 <zapisanie+0x33e>
				}

			} else {
				Send_string_uart("Priloz opravnenu kartu\n\r");
 800157e:	482a      	ldr	r0, [pc, #168]	; (8001628 <zapisanie+0x380>)
 8001580:	f001 fc48 	bl	8002e14 <Send_string_uart>
				lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001584:	22ff      	movs	r2, #255	; 0xff
 8001586:	21ff      	movs	r1, #255	; 0xff
 8001588:	20ff      	movs	r0, #255	; 0xff
 800158a:	f001 f975 	bl	8002878 <decodeRgbValue>
 800158e:	4603      	mov	r3, r0
 8001590:	4618      	mov	r0, r3
 8001592:	f000 fe69 	bl	8002268 <lcdClearDisplay>
				sprintf(bufferDisplay, "Priloz opravnenu   kartu");
 8001596:	f107 031c 	add.w	r3, r7, #28
 800159a:	4a24      	ldr	r2, [pc, #144]	; (800162c <zapisanie+0x384>)
 800159c:	461c      	mov	r4, r3
 800159e:	4615      	mov	r5, r2
 80015a0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80015a2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80015a4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80015a8:	c403      	stmia	r4!, {r0, r1}
 80015aa:	7022      	strb	r2, [r4, #0]
				lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
 80015ac:	22ff      	movs	r2, #255	; 0xff
 80015ae:	2100      	movs	r1, #0
 80015b0:	2000      	movs	r0, #0
 80015b2:	f001 f961 	bl	8002878 <decodeRgbValue>
 80015b6:	4603      	mov	r3, r0
 80015b8:	461c      	mov	r4, r3
 80015ba:	22ff      	movs	r2, #255	; 0xff
 80015bc:	21ff      	movs	r1, #255	; 0xff
 80015be:	20ff      	movs	r0, #255	; 0xff
 80015c0:	f001 f95a 	bl	8002878 <decodeRgbValue>
 80015c4:	4603      	mov	r3, r0
 80015c6:	f107 001c 	add.w	r0, r7, #28
 80015ca:	9300      	str	r3, [sp, #0]
 80015cc:	4623      	mov	r3, r4
 80015ce:	2232      	movs	r2, #50	; 0x32
 80015d0:	210a      	movs	r1, #10
 80015d2:	f001 f96d 	bl	80028b0 <lcdPutS>
						decodeRgbValue(255, 255, 255));
				Delay(1);
 80015d6:	2001      	movs	r0, #1
 80015d8:	f001 fbf0 	bl	8002dbc <Delay>
				if (x == 5) {
 80015dc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80015de:	2b05      	cmp	r3, #5
 80015e0:	d101      	bne.n	80015e6 <zapisanie+0x33e>
					welcome();
 80015e2:	f001 f9a1 	bl	8002928 <welcome>
	char bufferDisplay[10];
	unsigned char MyID[5] = { 0x1a, 0x18, 0x3a, 0x45, 0x7d };
	unsigned char CardID[5];
	unsigned char newCardID[5];
	int pom = 0;
	for (int x = 0; x <= 5; x++) {
 80015e6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80015e8:	3301      	adds	r3, #1
 80015ea:	657b      	str	r3, [r7, #84]	; 0x54
 80015ec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80015ee:	2b05      	cmp	r3, #5
 80015f0:	f77f ae69 	ble.w	80012c6 <zapisanie+0x1e>
			//welcome();
			break;
		}
	}
	koniec: ;
}
 80015f4:	e01d      	b.n	8001632 <zapisanie+0x38a>
 80015f6:	bf00      	nop
 80015f8:	08003794 	.word	0x08003794
 80015fc:	080036a0 	.word	0x080036a0
 8001600:	080036b4 	.word	0x080036b4
 8001604:	080036cc 	.word	0x080036cc
 8001608:	080036e0 	.word	0x080036e0
 800160c:	080036f4 	.word	0x080036f4
 8001610:	40020000 	.word	0x40020000
 8001614:	00030d40 	.word	0x00030d40
 8001618:	08003708 	.word	0x08003708
 800161c:	08003718 	.word	0x08003718
 8001620:	08003734 	.word	0x08003734
 8001624:	08003748 	.word	0x08003748
 8001628:	0800375c 	.word	0x0800375c
 800162c:	08003778 	.word	0x08003778
				}
			}
			//Delay(1);
		} else {
			//welcome();
			break;
 8001630:	bf00      	nop
		}
	}
	koniec: ;
}
 8001632:	bf00      	nop
 8001634:	3758      	adds	r7, #88	; 0x58
 8001636:	46bd      	mov	sp, r7
 8001638:	bdb0      	pop	{r4, r5, r7, pc}
 800163a:	bf00      	nop

0800163c <vymazanie>:

void vymazanie(void) {
 800163c:	b5b0      	push	{r4, r5, r7, lr}
 800163e:	b09c      	sub	sp, #112	; 0x70
 8001640:	af04      	add	r7, sp, #16
	char bufferRFID[30];
	char bufferDisplay[10];
	unsigned char MyID[5] = { 0x1a, 0x18, 0x3a, 0x45, 0x7d };
 8001642:	4ac3      	ldr	r2, [pc, #780]	; (8001950 <vymazanie+0x314>)
 8001644:	f107 0314 	add.w	r3, r7, #20
 8001648:	6810      	ldr	r0, [r2, #0]
 800164a:	6018      	str	r0, [r3, #0]
 800164c:	7912      	ldrb	r2, [r2, #4]
 800164e:	711a      	strb	r2, [r3, #4]
	unsigned char CardID[5];
	unsigned char newCardID[5];
	int pom = 0;
 8001650:	2300      	movs	r3, #0
 8001652:	65fb      	str	r3, [r7, #92]	; 0x5c
	int pom2 = 0;
 8001654:	2300      	movs	r3, #0
 8001656:	65bb      	str	r3, [r7, #88]	; 0x58
	for (int x = 0; x <= 5; x++) {
 8001658:	2300      	movs	r3, #0
 800165a:	657b      	str	r3, [r7, #84]	; 0x54
 800165c:	e16d      	b.n	800193a <vymazanie+0x2fe>
		if (pom == 0) {
 800165e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001660:	2b00      	cmp	r3, #0
 8001662:	f040 816f 	bne.w	8001944 <vymazanie+0x308>
			if (TM_MFRC522_Check(CardID) == MI_OK) {
 8001666:	f107 030c 	add.w	r3, r7, #12
 800166a:	4618      	mov	r0, r3
 800166c:	f7ff fc8e 	bl	8000f8c <TM_MFRC522_Check>
 8001670:	4603      	mov	r3, r0
 8001672:	2b00      	cmp	r3, #0
 8001674:	f040 812a 	bne.w	80018cc <vymazanie+0x290>

				sprintf(bufferRFID, "[%x-%x-%x-%x-%x]", CardID[0], CardID[1],
 8001678:	7b3b      	ldrb	r3, [r7, #12]
 800167a:	461c      	mov	r4, r3
 800167c:	7b7b      	ldrb	r3, [r7, #13]
 800167e:	461d      	mov	r5, r3
						CardID[2], CardID[3], CardID[4]);
 8001680:	7bbb      	ldrb	r3, [r7, #14]
 8001682:	7bfa      	ldrb	r2, [r7, #15]
 8001684:	7c39      	ldrb	r1, [r7, #16]
	int pom2 = 0;
	for (int x = 0; x <= 5; x++) {
		if (pom == 0) {
			if (TM_MFRC522_Check(CardID) == MI_OK) {

				sprintf(bufferRFID, "[%x-%x-%x-%x-%x]", CardID[0], CardID[1],
 8001686:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800168a:	9102      	str	r1, [sp, #8]
 800168c:	9201      	str	r2, [sp, #4]
 800168e:	9300      	str	r3, [sp, #0]
 8001690:	462b      	mov	r3, r5
 8001692:	4622      	mov	r2, r4
 8001694:	49af      	ldr	r1, [pc, #700]	; (8001954 <vymazanie+0x318>)
 8001696:	f001 ffaf 	bl	80035f8 <siprintf>
						CardID[2], CardID[3], CardID[4]);

				if (karta_v_zozname(CardID) == MI_OK) {
 800169a:	f107 030c 	add.w	r3, r7, #12
 800169e:	4618      	mov	r0, r3
 80016a0:	f000 f970 	bl	8001984 <karta_v_zozname>
 80016a4:	4603      	mov	r3, r0
 80016a6:	2b00      	cmp	r3, #0
 80016a8:	f040 80df 	bne.w	800186a <vymazanie+0x22e>

					Send_string_uart("Prilozte kartu na odstranenie\n\r");
 80016ac:	48aa      	ldr	r0, [pc, #680]	; (8001958 <vymazanie+0x31c>)
 80016ae:	f001 fbb1 	bl	8002e14 <Send_string_uart>

					lcdClearDisplay(decodeRgbValue(255, 255, 255));
 80016b2:	22ff      	movs	r2, #255	; 0xff
 80016b4:	21ff      	movs	r1, #255	; 0xff
 80016b6:	20ff      	movs	r0, #255	; 0xff
 80016b8:	f001 f8de 	bl	8002878 <decodeRgbValue>
 80016bc:	4603      	mov	r3, r0
 80016be:	4618      	mov	r0, r3
 80016c0:	f000 fdd2 	bl	8002268 <lcdClearDisplay>
					sprintf(bufferDisplay, "Prilozte kartu na  odstranenie");
 80016c4:	f107 031c 	add.w	r3, r7, #28
 80016c8:	4aa4      	ldr	r2, [pc, #656]	; (800195c <vymazanie+0x320>)
 80016ca:	461c      	mov	r4, r3
 80016cc:	4615      	mov	r5, r2
 80016ce:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80016d0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80016d2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80016d6:	c407      	stmia	r4!, {r0, r1, r2}
 80016d8:	8023      	strh	r3, [r4, #0]
 80016da:	3402      	adds	r4, #2
 80016dc:	0c1b      	lsrs	r3, r3, #16
 80016de:	7023      	strb	r3, [r4, #0]
					lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
 80016e0:	22ff      	movs	r2, #255	; 0xff
 80016e2:	2100      	movs	r1, #0
 80016e4:	2000      	movs	r0, #0
 80016e6:	f001 f8c7 	bl	8002878 <decodeRgbValue>
 80016ea:	4603      	mov	r3, r0
 80016ec:	461c      	mov	r4, r3
 80016ee:	22ff      	movs	r2, #255	; 0xff
 80016f0:	21ff      	movs	r1, #255	; 0xff
 80016f2:	20ff      	movs	r0, #255	; 0xff
 80016f4:	f001 f8c0 	bl	8002878 <decodeRgbValue>
 80016f8:	4603      	mov	r3, r0
 80016fa:	f107 001c 	add.w	r0, r7, #28
 80016fe:	9300      	str	r3, [sp, #0]
 8001700:	4623      	mov	r3, r4
 8001702:	2232      	movs	r2, #50	; 0x32
 8001704:	210a      	movs	r1, #10
 8001706:	f001 f8d3 	bl	80028b0 <lcdPutS>
							decodeRgbValue(255, 255, 255));

					Delay(3);
 800170a:	2003      	movs	r0, #3
 800170c:	f001 fb56 	bl	8002dbc <Delay>

					for (int i = 0; i <= 10; i++) {
 8001710:	2300      	movs	r3, #0
 8001712:	653b      	str	r3, [r7, #80]	; 0x50
 8001714:	e0a4      	b.n	8001860 <vymazanie+0x224>
						if (TM_MFRC522_Check(newCardID) == MI_OK) {
 8001716:	1d3b      	adds	r3, r7, #4
 8001718:	4618      	mov	r0, r3
 800171a:	f7ff fc37 	bl	8000f8c <TM_MFRC522_Check>
 800171e:	4603      	mov	r3, r0
 8001720:	2b00      	cmp	r3, #0
 8001722:	f040 8090 	bne.w	8001846 <vymazanie+0x20a>
							for (int j = 0; j < 5; j++) {
 8001726:	2300      	movs	r3, #0
 8001728:	64fb      	str	r3, [r7, #76]	; 0x4c
 800172a:	e010      	b.n	800174e <vymazanie+0x112>
								if (CardID[j] == newCardID[j]) {
 800172c:	f107 020c 	add.w	r2, r7, #12
 8001730:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001732:	4413      	add	r3, r2
 8001734:	781a      	ldrb	r2, [r3, #0]
 8001736:	1d39      	adds	r1, r7, #4
 8001738:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800173a:	440b      	add	r3, r1
 800173c:	781b      	ldrb	r3, [r3, #0]
 800173e:	429a      	cmp	r2, r3
 8001740:	d102      	bne.n	8001748 <vymazanie+0x10c>
									pom2++;
 8001742:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001744:	3301      	adds	r3, #1
 8001746:	65bb      	str	r3, [r7, #88]	; 0x58

					Delay(3);

					for (int i = 0; i <= 10; i++) {
						if (TM_MFRC522_Check(newCardID) == MI_OK) {
							for (int j = 0; j < 5; j++) {
 8001748:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800174a:	3301      	adds	r3, #1
 800174c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800174e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001750:	2b04      	cmp	r3, #4
 8001752:	ddeb      	ble.n	800172c <vymazanie+0xf0>
								if (CardID[j] == newCardID[j]) {
									pom2++;
								}
							}

							if (pom2 != 5) {
 8001754:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001756:	2b05      	cmp	r3, #5
 8001758:	d047      	beq.n	80017ea <vymazanie+0x1ae>
								odober_kartu(newCardID);
 800175a:	1d3b      	adds	r3, r7, #4
 800175c:	4618      	mov	r0, r3
 800175e:	f000 f9a5 	bl	8001aac <odober_kartu>
								Send_string_uart("Uspesne vymazane\n\r");
 8001762:	487f      	ldr	r0, [pc, #508]	; (8001960 <vymazanie+0x324>)
 8001764:	f001 fb56 	bl	8002e14 <Send_string_uart>
								lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001768:	22ff      	movs	r2, #255	; 0xff
 800176a:	21ff      	movs	r1, #255	; 0xff
 800176c:	20ff      	movs	r0, #255	; 0xff
 800176e:	f001 f883 	bl	8002878 <decodeRgbValue>
 8001772:	4603      	mov	r3, r0
 8001774:	4618      	mov	r0, r3
 8001776:	f000 fd77 	bl	8002268 <lcdClearDisplay>
								sprintf(bufferDisplay, "Uspesne vymazane");
 800177a:	f107 031c 	add.w	r3, r7, #28
 800177e:	4a79      	ldr	r2, [pc, #484]	; (8001964 <vymazanie+0x328>)
 8001780:	461c      	mov	r4, r3
 8001782:	4615      	mov	r5, r2
 8001784:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001786:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8001788:	682b      	ldr	r3, [r5, #0]
 800178a:	7023      	strb	r3, [r4, #0]
								//odober_kartu(newCardID);
								lcdPutS(bufferDisplay, 10, 50,
 800178c:	22ff      	movs	r2, #255	; 0xff
 800178e:	2100      	movs	r1, #0
 8001790:	2000      	movs	r0, #0
 8001792:	f001 f871 	bl	8002878 <decodeRgbValue>
 8001796:	4603      	mov	r3, r0
 8001798:	461c      	mov	r4, r3
 800179a:	22ff      	movs	r2, #255	; 0xff
 800179c:	21ff      	movs	r1, #255	; 0xff
 800179e:	20ff      	movs	r0, #255	; 0xff
 80017a0:	f001 f86a 	bl	8002878 <decodeRgbValue>
 80017a4:	4603      	mov	r3, r0
 80017a6:	f107 001c 	add.w	r0, r7, #28
 80017aa:	9300      	str	r3, [sp, #0]
 80017ac:	4623      	mov	r3, r4
 80017ae:	2232      	movs	r2, #50	; 0x32
 80017b0:	210a      	movs	r1, #10
 80017b2:	f001 f87d 	bl	80028b0 <lcdPutS>
										decodeRgbValue(0, 0, 255),
										decodeRgbValue(255, 255, 255));

								//vykreslenie OK
								ok();
 80017b6:	f001 f92d 	bl	8002a14 <ok>
								//blikanie zltej LED
								for (int c = 0; c < 6; c++) {
 80017ba:	2300      	movs	r3, #0
 80017bc:	64bb      	str	r3, [r7, #72]	; 0x48
 80017be:	e009      	b.n	80017d4 <vymazanie+0x198>
									GPIO_ToggleBits(GPIOA, GPIO_Pin_4);
 80017c0:	2110      	movs	r1, #16
 80017c2:	4869      	ldr	r0, [pc, #420]	; (8001968 <vymazanie+0x32c>)
 80017c4:	f7fe fee6 	bl	8000594 <GPIO_ToggleBits>
									Delay_us(200000);
 80017c8:	4868      	ldr	r0, [pc, #416]	; (800196c <vymazanie+0x330>)
 80017ca:	f001 fb11 	bl	8002df0 <Delay_us>
										decodeRgbValue(255, 255, 255));

								//vykreslenie OK
								ok();
								//blikanie zltej LED
								for (int c = 0; c < 6; c++) {
 80017ce:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80017d0:	3301      	adds	r3, #1
 80017d2:	64bb      	str	r3, [r7, #72]	; 0x48
 80017d4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80017d6:	2b05      	cmp	r3, #5
 80017d8:	ddf2      	ble.n	80017c0 <vymazanie+0x184>
									GPIO_ToggleBits(GPIOA, GPIO_Pin_4);
									Delay_us(200000);
								}
								Delay(1);
 80017da:	2001      	movs	r0, #1
 80017dc:	f001 faee 	bl	8002dbc <Delay>
								pom = 1;
 80017e0:	2301      	movs	r3, #1
 80017e2:	65fb      	str	r3, [r7, #92]	; 0x5c
								//i = 10;
								//Delay(3);
								welcome();
 80017e4:	f001 f8a0 	bl	8002928 <welcome>
								break;
 80017e8:	e0a4      	b.n	8001934 <vymazanie+0x2f8>
							} else {
								lcdClearDisplay(decodeRgbValue(255, 255, 255));
 80017ea:	22ff      	movs	r2, #255	; 0xff
 80017ec:	21ff      	movs	r1, #255	; 0xff
 80017ee:	20ff      	movs	r0, #255	; 0xff
 80017f0:	f001 f842 	bl	8002878 <decodeRgbValue>
 80017f4:	4603      	mov	r3, r0
 80017f6:	4618      	mov	r0, r3
 80017f8:	f000 fd36 	bl	8002268 <lcdClearDisplay>
								sprintf(bufferDisplay,
 80017fc:	f107 031c 	add.w	r3, r7, #28
 8001800:	4a5b      	ldr	r2, [pc, #364]	; (8001970 <vymazanie+0x334>)
 8001802:	461c      	mov	r4, r3
 8001804:	4615      	mov	r5, r2
 8001806:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001808:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800180a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 800180e:	c407      	stmia	r4!, {r0, r1, r2}
 8001810:	8023      	strh	r3, [r4, #0]
										"Nemozno vymazat tu istu kartu");
								lcdPutS(bufferDisplay, 10, 50,
 8001812:	2200      	movs	r2, #0
 8001814:	2100      	movs	r1, #0
 8001816:	20ff      	movs	r0, #255	; 0xff
 8001818:	f001 f82e 	bl	8002878 <decodeRgbValue>
 800181c:	4603      	mov	r3, r0
 800181e:	461c      	mov	r4, r3
 8001820:	22ff      	movs	r2, #255	; 0xff
 8001822:	21ff      	movs	r1, #255	; 0xff
 8001824:	20ff      	movs	r0, #255	; 0xff
 8001826:	f001 f827 	bl	8002878 <decodeRgbValue>
 800182a:	4603      	mov	r3, r0
 800182c:	f107 001c 	add.w	r0, r7, #28
 8001830:	9300      	str	r3, [sp, #0]
 8001832:	4623      	mov	r3, r4
 8001834:	2232      	movs	r2, #50	; 0x32
 8001836:	210a      	movs	r1, #10
 8001838:	f001 f83a 	bl	80028b0 <lcdPutS>
										decodeRgbValue(255, 0, 0),
										decodeRgbValue(255, 255, 255));

								//vykreslenie Vykricnika
								vykricnik();
 800183c:	f001 f922 	bl	8002a84 <vykricnik>
								welcome();
 8001840:	f001 f872 	bl	8002928 <welcome>
								goto koniec;
 8001844:	e07f      	b.n	8001946 <vymazanie+0x30a>
							}

						} else {
							Delay(1);
 8001846:	2001      	movs	r0, #1
 8001848:	f001 fab8 	bl	8002dbc <Delay>
						}
						if (i == 10) {
 800184c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800184e:	2b0a      	cmp	r3, #10
 8001850:	d103      	bne.n	800185a <vymazanie+0x21e>
							x = 5;
 8001852:	2305      	movs	r3, #5
 8001854:	657b      	str	r3, [r7, #84]	; 0x54
							welcome();
 8001856:	f001 f867 	bl	8002928 <welcome>
					lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
							decodeRgbValue(255, 255, 255));

					Delay(3);

					for (int i = 0; i <= 10; i++) {
 800185a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800185c:	3301      	adds	r3, #1
 800185e:	653b      	str	r3, [r7, #80]	; 0x50
 8001860:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8001862:	2b0a      	cmp	r3, #10
 8001864:	f77f af57 	ble.w	8001716 <vymazanie+0xda>
 8001868:	e064      	b.n	8001934 <vymazanie+0x2f8>
						}

					}

				} else {
					Send_string_uart("Neopravnena karta\n\r");
 800186a:	4842      	ldr	r0, [pc, #264]	; (8001974 <vymazanie+0x338>)
 800186c:	f001 fad2 	bl	8002e14 <Send_string_uart>
					x = 5;
 8001870:	2305      	movs	r3, #5
 8001872:	657b      	str	r3, [r7, #84]	; 0x54
					lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001874:	22ff      	movs	r2, #255	; 0xff
 8001876:	21ff      	movs	r1, #255	; 0xff
 8001878:	20ff      	movs	r0, #255	; 0xff
 800187a:	f000 fffd 	bl	8002878 <decodeRgbValue>
 800187e:	4603      	mov	r3, r0
 8001880:	4618      	mov	r0, r3
 8001882:	f000 fcf1 	bl	8002268 <lcdClearDisplay>
					sprintf(bufferDisplay, "Neopravnena karta");
 8001886:	f107 031c 	add.w	r3, r7, #28
 800188a:	4a3b      	ldr	r2, [pc, #236]	; (8001978 <vymazanie+0x33c>)
 800188c:	461c      	mov	r4, r3
 800188e:	4615      	mov	r5, r2
 8001890:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001892:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8001894:	682b      	ldr	r3, [r5, #0]
 8001896:	8023      	strh	r3, [r4, #0]
					lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(255, 0, 0),
 8001898:	2200      	movs	r2, #0
 800189a:	2100      	movs	r1, #0
 800189c:	20ff      	movs	r0, #255	; 0xff
 800189e:	f000 ffeb 	bl	8002878 <decodeRgbValue>
 80018a2:	4603      	mov	r3, r0
 80018a4:	461c      	mov	r4, r3
 80018a6:	22ff      	movs	r2, #255	; 0xff
 80018a8:	21ff      	movs	r1, #255	; 0xff
 80018aa:	20ff      	movs	r0, #255	; 0xff
 80018ac:	f000 ffe4 	bl	8002878 <decodeRgbValue>
 80018b0:	4603      	mov	r3, r0
 80018b2:	f107 001c 	add.w	r0, r7, #28
 80018b6:	9300      	str	r3, [sp, #0]
 80018b8:	4623      	mov	r3, r4
 80018ba:	2232      	movs	r2, #50	; 0x32
 80018bc:	210a      	movs	r1, #10
 80018be:	f000 fff7 	bl	80028b0 <lcdPutS>
							decodeRgbValue(255, 255, 255));

					//vykreslenie Vykricnika
					vykricnik();
 80018c2:	f001 f8df 	bl	8002a84 <vykricnik>
					welcome();
 80018c6:	f001 f82f 	bl	8002928 <welcome>
 80018ca:	e033      	b.n	8001934 <vymazanie+0x2f8>
				}

			} else {
				Send_string_uart("Priloz opravnenu kartu\n\r");
 80018cc:	482b      	ldr	r0, [pc, #172]	; (800197c <vymazanie+0x340>)
 80018ce:	f001 faa1 	bl	8002e14 <Send_string_uart>
				lcdClearDisplay(decodeRgbValue(255, 255, 255));
 80018d2:	22ff      	movs	r2, #255	; 0xff
 80018d4:	21ff      	movs	r1, #255	; 0xff
 80018d6:	20ff      	movs	r0, #255	; 0xff
 80018d8:	f000 ffce 	bl	8002878 <decodeRgbValue>
 80018dc:	4603      	mov	r3, r0
 80018de:	4618      	mov	r0, r3
 80018e0:	f000 fcc2 	bl	8002268 <lcdClearDisplay>
				sprintf(bufferDisplay, "Priloz opravnenu   kartu");
 80018e4:	f107 031c 	add.w	r3, r7, #28
 80018e8:	4a25      	ldr	r2, [pc, #148]	; (8001980 <vymazanie+0x344>)
 80018ea:	461c      	mov	r4, r3
 80018ec:	4615      	mov	r5, r2
 80018ee:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80018f0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80018f2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80018f6:	c403      	stmia	r4!, {r0, r1}
 80018f8:	7022      	strb	r2, [r4, #0]
				lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
 80018fa:	22ff      	movs	r2, #255	; 0xff
 80018fc:	2100      	movs	r1, #0
 80018fe:	2000      	movs	r0, #0
 8001900:	f000 ffba 	bl	8002878 <decodeRgbValue>
 8001904:	4603      	mov	r3, r0
 8001906:	461c      	mov	r4, r3
 8001908:	22ff      	movs	r2, #255	; 0xff
 800190a:	21ff      	movs	r1, #255	; 0xff
 800190c:	20ff      	movs	r0, #255	; 0xff
 800190e:	f000 ffb3 	bl	8002878 <decodeRgbValue>
 8001912:	4603      	mov	r3, r0
 8001914:	f107 001c 	add.w	r0, r7, #28
 8001918:	9300      	str	r3, [sp, #0]
 800191a:	4623      	mov	r3, r4
 800191c:	2232      	movs	r2, #50	; 0x32
 800191e:	210a      	movs	r1, #10
 8001920:	f000 ffc6 	bl	80028b0 <lcdPutS>
						decodeRgbValue(255, 255, 255));
				Delay(1);
 8001924:	2001      	movs	r0, #1
 8001926:	f001 fa49 	bl	8002dbc <Delay>
				if (x == 5) {
 800192a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800192c:	2b05      	cmp	r3, #5
 800192e:	d101      	bne.n	8001934 <vymazanie+0x2f8>
					welcome();
 8001930:	f000 fffa 	bl	8002928 <welcome>
	unsigned char MyID[5] = { 0x1a, 0x18, 0x3a, 0x45, 0x7d };
	unsigned char CardID[5];
	unsigned char newCardID[5];
	int pom = 0;
	int pom2 = 0;
	for (int x = 0; x <= 5; x++) {
 8001934:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001936:	3301      	adds	r3, #1
 8001938:	657b      	str	r3, [r7, #84]	; 0x54
 800193a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800193c:	2b05      	cmp	r3, #5
 800193e:	f77f ae8e 	ble.w	800165e <vymazanie+0x22>
			//welcome();
			break;
		}
	}
	koniec: ;
}
 8001942:	e000      	b.n	8001946 <vymazanie+0x30a>
				}
			}
			//Delay(1);
		} else {
			//welcome();
			break;
 8001944:	bf00      	nop
		}
	}
	koniec: ;
}
 8001946:	bf00      	nop
 8001948:	3760      	adds	r7, #96	; 0x60
 800194a:	46bd      	mov	sp, r7
 800194c:	bdb0      	pop	{r4, r5, r7, pc}
 800194e:	bf00      	nop
 8001950:	08003794 	.word	0x08003794
 8001954:	080036a0 	.word	0x080036a0
 8001958:	0800379c 	.word	0x0800379c
 800195c:	080037bc 	.word	0x080037bc
 8001960:	080037dc 	.word	0x080037dc
 8001964:	080037f0 	.word	0x080037f0
 8001968:	40020000 	.word	0x40020000
 800196c:	00030d40 	.word	0x00030d40
 8001970:	08003804 	.word	0x08003804
 8001974:	08003734 	.word	0x08003734
 8001978:	08003748 	.word	0x08003748
 800197c:	0800375c 	.word	0x0800375c
 8001980:	08003778 	.word	0x08003778

08001984 <karta_v_zozname>:

//funkcia na prejdenie zoznamu zapisanych kariet na flash pameti na adresach
//0x08080000 az 0x08080100
TM_MFRC522_Status_t karta_v_zozname(uint8_t* CardID) {
 8001984:	b480      	push	{r7}
 8001986:	b087      	sub	sp, #28
 8001988:	af00      	add	r7, sp, #0
 800198a:	6078      	str	r0, [r7, #4]
	uint8_t i;
	uint8_t j;
	uint8_t pom;
	uint32_t *addres;
	uint8_t CompareID;
	for (j = 0; j < 8; j++) {
 800198c:	2300      	movs	r3, #0
 800198e:	75bb      	strb	r3, [r7, #22]
 8001990:	e036      	b.n	8001a00 <karta_v_zozname+0x7c>
		pom = 0;
 8001992:	2300      	movs	r3, #0
 8001994:	757b      	strb	r3, [r7, #21]
		addres = (uint32_t *) 0x08080000 + (0x05) + (j * 0x8);
 8001996:	7dbb      	ldrb	r3, [r7, #22]
 8001998:	015b      	lsls	r3, r3, #5
 800199a:	461a      	mov	r2, r3
 800199c:	4b1d      	ldr	r3, [pc, #116]	; (8001a14 <karta_v_zozname+0x90>)
 800199e:	4413      	add	r3, r2
 80019a0:	613b      	str	r3, [r7, #16]
		CompareID = *addres;
 80019a2:	693b      	ldr	r3, [r7, #16]
 80019a4:	681b      	ldr	r3, [r3, #0]
 80019a6:	73fb      	strb	r3, [r7, #15]
		if (1 == CompareID) {
 80019a8:	7bfb      	ldrb	r3, [r7, #15]
 80019aa:	2b01      	cmp	r3, #1
 80019ac:	d125      	bne.n	80019fa <karta_v_zozname+0x76>
			for (i = 0; i < 5; i++) {
 80019ae:	2300      	movs	r3, #0
 80019b0:	75fb      	strb	r3, [r7, #23]
 80019b2:	e01a      	b.n	80019ea <karta_v_zozname+0x66>
				addres = (uint32_t *) 0x08080000 + 0x1 * i + j * 0x8;
 80019b4:	7dfb      	ldrb	r3, [r7, #23]
 80019b6:	009b      	lsls	r3, r3, #2
 80019b8:	461a      	mov	r2, r3
 80019ba:	7dbb      	ldrb	r3, [r7, #22]
 80019bc:	015b      	lsls	r3, r3, #5
 80019be:	4413      	add	r3, r2
 80019c0:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80019c4:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 80019c8:	613b      	str	r3, [r7, #16]
				CompareID = *addres;
 80019ca:	693b      	ldr	r3, [r7, #16]
 80019cc:	681b      	ldr	r3, [r3, #0]
 80019ce:	73fb      	strb	r3, [r7, #15]
				if (CardID[i] == CompareID) {
 80019d0:	7dfb      	ldrb	r3, [r7, #23]
 80019d2:	687a      	ldr	r2, [r7, #4]
 80019d4:	4413      	add	r3, r2
 80019d6:	781b      	ldrb	r3, [r3, #0]
 80019d8:	7bfa      	ldrb	r2, [r7, #15]
 80019da:	429a      	cmp	r2, r3
 80019dc:	d102      	bne.n	80019e4 <karta_v_zozname+0x60>
					pom++;
 80019de:	7d7b      	ldrb	r3, [r7, #21]
 80019e0:	3301      	adds	r3, #1
 80019e2:	757b      	strb	r3, [r7, #21]
	for (j = 0; j < 8; j++) {
		pom = 0;
		addres = (uint32_t *) 0x08080000 + (0x05) + (j * 0x8);
		CompareID = *addres;
		if (1 == CompareID) {
			for (i = 0; i < 5; i++) {
 80019e4:	7dfb      	ldrb	r3, [r7, #23]
 80019e6:	3301      	adds	r3, #1
 80019e8:	75fb      	strb	r3, [r7, #23]
 80019ea:	7dfb      	ldrb	r3, [r7, #23]
 80019ec:	2b04      	cmp	r3, #4
 80019ee:	d9e1      	bls.n	80019b4 <karta_v_zozname+0x30>
				if (CardID[i] == CompareID) {
					pom++;
				}

			}
			if (pom == 5) {
 80019f0:	7d7b      	ldrb	r3, [r7, #21]
 80019f2:	2b05      	cmp	r3, #5
 80019f4:	d101      	bne.n	80019fa <karta_v_zozname+0x76>
				return MI_OK;
 80019f6:	2300      	movs	r3, #0
 80019f8:	e006      	b.n	8001a08 <karta_v_zozname+0x84>
	uint8_t i;
	uint8_t j;
	uint8_t pom;
	uint32_t *addres;
	uint8_t CompareID;
	for (j = 0; j < 8; j++) {
 80019fa:	7dbb      	ldrb	r3, [r7, #22]
 80019fc:	3301      	adds	r3, #1
 80019fe:	75bb      	strb	r3, [r7, #22]
 8001a00:	7dbb      	ldrb	r3, [r7, #22]
 8001a02:	2b07      	cmp	r3, #7
 8001a04:	d9c5      	bls.n	8001992 <karta_v_zozname+0xe>
			if (pom == 5) {
				return MI_OK;
			}
		}
	}
	return MI_ERR;
 8001a06:	2302      	movs	r3, #2
}
 8001a08:	4618      	mov	r0, r3
 8001a0a:	371c      	adds	r7, #28
 8001a0c:	46bd      	mov	sp, r7
 8001a0e:	bc80      	pop	{r7}
 8001a10:	4770      	bx	lr
 8001a12:	bf00      	nop
 8001a14:	08080014 	.word	0x08080014

08001a18 <pridaj_kartu>:

//funkcia na zapis do zoznamu kariet na adresach
//0x08080000 az 0x08080100

TM_MFRC522_Status_t pridaj_kartu(uint8_t* CardID) {
 8001a18:	b580      	push	{r7, lr}
 8001a1a:	b086      	sub	sp, #24
 8001a1c:	af00      	add	r7, sp, #0
 8001a1e:	6078      	str	r0, [r7, #4]
	uint8_t i;
	uint8_t j;
	uint32_t *addres;
	uint32_t PutInIDAddress;
	uint8_t PutInID;
	for (j = 0; j < 8; j++) {
 8001a20:	2300      	movs	r3, #0
 8001a22:	75bb      	strb	r3, [r7, #22]
 8001a24:	e038      	b.n	8001a98 <pridaj_kartu+0x80>
		addres = (uint32_t *) 0x08080000 + (0x05) + (j * 0x8);
 8001a26:	7dbb      	ldrb	r3, [r7, #22]
 8001a28:	015b      	lsls	r3, r3, #5
 8001a2a:	461a      	mov	r2, r3
 8001a2c:	4b1e      	ldr	r3, [pc, #120]	; (8001aa8 <pridaj_kartu+0x90>)
 8001a2e:	4413      	add	r3, r2
 8001a30:	613b      	str	r3, [r7, #16]
		PutInID = *addres;
 8001a32:	693b      	ldr	r3, [r7, #16]
 8001a34:	681b      	ldr	r3, [r3, #0]
 8001a36:	73fb      	strb	r3, [r7, #15]
		PutInIDAddress = (uint32_t) (addres);
 8001a38:	693b      	ldr	r3, [r7, #16]
 8001a3a:	60bb      	str	r3, [r7, #8]
		if (0 == PutInID) {
 8001a3c:	7bfb      	ldrb	r3, [r7, #15]
 8001a3e:	2b00      	cmp	r3, #0
 8001a40:	d127      	bne.n	8001a92 <pridaj_kartu+0x7a>
			FLASH_Unlock();
 8001a42:	f7fe fc15 	bl	8000270 <FLASH_Unlock>
			DATA_EEPROM_ProgramByte(PutInIDAddress, 1);
 8001a46:	2101      	movs	r1, #1
 8001a48:	68b8      	ldr	r0, [r7, #8]
 8001a4a:	f7fe fc67 	bl	800031c <DATA_EEPROM_ProgramByte>
			for (i = 0; i < 5; i++) {
 8001a4e:	2300      	movs	r3, #0
 8001a50:	75fb      	strb	r3, [r7, #23]
 8001a52:	e017      	b.n	8001a84 <pridaj_kartu+0x6c>
				addres = (uint32_t *) 0x08080000 + 0x1 * i + j * 0x8;
 8001a54:	7dfb      	ldrb	r3, [r7, #23]
 8001a56:	009b      	lsls	r3, r3, #2
 8001a58:	461a      	mov	r2, r3
 8001a5a:	7dbb      	ldrb	r3, [r7, #22]
 8001a5c:	015b      	lsls	r3, r3, #5
 8001a5e:	4413      	add	r3, r2
 8001a60:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8001a64:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 8001a68:	613b      	str	r3, [r7, #16]
				PutInIDAddress = (uint32_t) (addres);
 8001a6a:	693b      	ldr	r3, [r7, #16]
 8001a6c:	60bb      	str	r3, [r7, #8]
				DATA_EEPROM_ProgramByte(PutInIDAddress, CardID[i]);
 8001a6e:	7dfb      	ldrb	r3, [r7, #23]
 8001a70:	687a      	ldr	r2, [r7, #4]
 8001a72:	4413      	add	r3, r2
 8001a74:	781b      	ldrb	r3, [r3, #0]
 8001a76:	4619      	mov	r1, r3
 8001a78:	68b8      	ldr	r0, [r7, #8]
 8001a7a:	f7fe fc4f 	bl	800031c <DATA_EEPROM_ProgramByte>
		PutInID = *addres;
		PutInIDAddress = (uint32_t) (addres);
		if (0 == PutInID) {
			FLASH_Unlock();
			DATA_EEPROM_ProgramByte(PutInIDAddress, 1);
			for (i = 0; i < 5; i++) {
 8001a7e:	7dfb      	ldrb	r3, [r7, #23]
 8001a80:	3301      	adds	r3, #1
 8001a82:	75fb      	strb	r3, [r7, #23]
 8001a84:	7dfb      	ldrb	r3, [r7, #23]
 8001a86:	2b04      	cmp	r3, #4
 8001a88:	d9e4      	bls.n	8001a54 <pridaj_kartu+0x3c>
				addres = (uint32_t *) 0x08080000 + 0x1 * i + j * 0x8;
				PutInIDAddress = (uint32_t) (addres);
				DATA_EEPROM_ProgramByte(PutInIDAddress, CardID[i]);
			}
			FLASH_Lock();
 8001a8a:	f7fe fc09 	bl	80002a0 <FLASH_Lock>
			return MI_OK;
 8001a8e:	2300      	movs	r3, #0
 8001a90:	e006      	b.n	8001aa0 <pridaj_kartu+0x88>
	uint8_t i;
	uint8_t j;
	uint32_t *addres;
	uint32_t PutInIDAddress;
	uint8_t PutInID;
	for (j = 0; j < 8; j++) {
 8001a92:	7dbb      	ldrb	r3, [r7, #22]
 8001a94:	3301      	adds	r3, #1
 8001a96:	75bb      	strb	r3, [r7, #22]
 8001a98:	7dbb      	ldrb	r3, [r7, #22]
 8001a9a:	2b07      	cmp	r3, #7
 8001a9c:	d9c3      	bls.n	8001a26 <pridaj_kartu+0xe>
			}
			FLASH_Lock();
			return MI_OK;
		}
	}
	return MI_ERR;
 8001a9e:	2302      	movs	r3, #2
}
 8001aa0:	4618      	mov	r0, r3
 8001aa2:	3718      	adds	r7, #24
 8001aa4:	46bd      	mov	sp, r7
 8001aa6:	bd80      	pop	{r7, pc}
 8001aa8:	08080014 	.word	0x08080014

08001aac <odober_kartu>:

TM_MFRC522_Status_t odober_kartu(uint8_t* CardID) {
 8001aac:	b580      	push	{r7, lr}
 8001aae:	b086      	sub	sp, #24
 8001ab0:	af00      	add	r7, sp, #0
 8001ab2:	6078      	str	r0, [r7, #4]
	uint8_t j;
	uint8_t pom;
	uint32_t *addres;
	uint8_t RemoveID;
	uint32_t RemoveIDAddress;
	for (j = 0; j < 8; j++) {
 8001ab4:	2300      	movs	r3, #0
 8001ab6:	757b      	strb	r3, [r7, #21]
 8001ab8:	e053      	b.n	8001b62 <odober_kartu+0xb6>
		pom = 0;
 8001aba:	2300      	movs	r3, #0
 8001abc:	753b      	strb	r3, [r7, #20]
		addres = (uint32_t *) 0x08080000 + (0x05) + (j * 0x8);
 8001abe:	7d7b      	ldrb	r3, [r7, #21]
 8001ac0:	015b      	lsls	r3, r3, #5
 8001ac2:	461a      	mov	r2, r3
 8001ac4:	4b2b      	ldr	r3, [pc, #172]	; (8001b74 <odober_kartu+0xc8>)
 8001ac6:	4413      	add	r3, r2
 8001ac8:	613b      	str	r3, [r7, #16]
		RemoveID = *addres;
 8001aca:	693b      	ldr	r3, [r7, #16]
 8001acc:	681b      	ldr	r3, [r3, #0]
 8001ace:	73fb      	strb	r3, [r7, #15]
		if (1 == RemoveID) {
 8001ad0:	7bfb      	ldrb	r3, [r7, #15]
 8001ad2:	2b01      	cmp	r3, #1
 8001ad4:	d142      	bne.n	8001b5c <odober_kartu+0xb0>
			for (i = 0; i < 5; i++) {
 8001ad6:	2300      	movs	r3, #0
 8001ad8:	75fb      	strb	r3, [r7, #23]
 8001ada:	e01a      	b.n	8001b12 <odober_kartu+0x66>
				addres = (uint32_t *) 0x08080000 + 0x1 * i + j * 0x8;
 8001adc:	7dfb      	ldrb	r3, [r7, #23]
 8001ade:	009b      	lsls	r3, r3, #2
 8001ae0:	461a      	mov	r2, r3
 8001ae2:	7d7b      	ldrb	r3, [r7, #21]
 8001ae4:	015b      	lsls	r3, r3, #5
 8001ae6:	4413      	add	r3, r2
 8001ae8:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8001aec:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 8001af0:	613b      	str	r3, [r7, #16]
				RemoveID = *addres;
 8001af2:	693b      	ldr	r3, [r7, #16]
 8001af4:	681b      	ldr	r3, [r3, #0]
 8001af6:	73fb      	strb	r3, [r7, #15]
				if (CardID[i] == RemoveID) {
 8001af8:	7dfb      	ldrb	r3, [r7, #23]
 8001afa:	687a      	ldr	r2, [r7, #4]
 8001afc:	4413      	add	r3, r2
 8001afe:	781b      	ldrb	r3, [r3, #0]
 8001b00:	7bfa      	ldrb	r2, [r7, #15]
 8001b02:	429a      	cmp	r2, r3
 8001b04:	d102      	bne.n	8001b0c <odober_kartu+0x60>
					pom++;
 8001b06:	7d3b      	ldrb	r3, [r7, #20]
 8001b08:	3301      	adds	r3, #1
 8001b0a:	753b      	strb	r3, [r7, #20]
	for (j = 0; j < 8; j++) {
		pom = 0;
		addres = (uint32_t *) 0x08080000 + (0x05) + (j * 0x8);
		RemoveID = *addres;
		if (1 == RemoveID) {
			for (i = 0; i < 5; i++) {
 8001b0c:	7dfb      	ldrb	r3, [r7, #23]
 8001b0e:	3301      	adds	r3, #1
 8001b10:	75fb      	strb	r3, [r7, #23]
 8001b12:	7dfb      	ldrb	r3, [r7, #23]
 8001b14:	2b04      	cmp	r3, #4
 8001b16:	d9e1      	bls.n	8001adc <odober_kartu+0x30>
				if (CardID[i] == RemoveID) {
					pom++;
				}

			}
			if (pom == 5) {
 8001b18:	7d3b      	ldrb	r3, [r7, #20]
 8001b1a:	2b05      	cmp	r3, #5
 8001b1c:	d11e      	bne.n	8001b5c <odober_kartu+0xb0>
				FLASH_Unlock();
 8001b1e:	f7fe fba7 	bl	8000270 <FLASH_Unlock>
				for (k = 0; k < 8; k++) {
 8001b22:	2300      	movs	r3, #0
 8001b24:	75bb      	strb	r3, [r7, #22]
 8001b26:	e012      	b.n	8001b4e <odober_kartu+0xa2>
					addres = (uint32_t *) 0x08080000 + 0x1 * k + j * 0x8;
 8001b28:	7dbb      	ldrb	r3, [r7, #22]
 8001b2a:	009b      	lsls	r3, r3, #2
 8001b2c:	461a      	mov	r2, r3
 8001b2e:	7d7b      	ldrb	r3, [r7, #21]
 8001b30:	015b      	lsls	r3, r3, #5
 8001b32:	4413      	add	r3, r2
 8001b34:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8001b38:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 8001b3c:	613b      	str	r3, [r7, #16]
					RemoveIDAddress = (uint32_t) (addres);
 8001b3e:	693b      	ldr	r3, [r7, #16]
 8001b40:	60bb      	str	r3, [r7, #8]

					DATA_EEPROM_EraseByte(RemoveIDAddress);
 8001b42:	68b8      	ldr	r0, [r7, #8]
 8001b44:	f7fe fbd2 	bl	80002ec <DATA_EEPROM_EraseByte>
				}

			}
			if (pom == 5) {
				FLASH_Unlock();
				for (k = 0; k < 8; k++) {
 8001b48:	7dbb      	ldrb	r3, [r7, #22]
 8001b4a:	3301      	adds	r3, #1
 8001b4c:	75bb      	strb	r3, [r7, #22]
 8001b4e:	7dbb      	ldrb	r3, [r7, #22]
 8001b50:	2b07      	cmp	r3, #7
 8001b52:	d9e9      	bls.n	8001b28 <odober_kartu+0x7c>
					addres = (uint32_t *) 0x08080000 + 0x1 * k + j * 0x8;
					RemoveIDAddress = (uint32_t) (addres);

					DATA_EEPROM_EraseByte(RemoveIDAddress);
				}
				FLASH_Lock();
 8001b54:	f7fe fba4 	bl	80002a0 <FLASH_Lock>
				return MI_OK;
 8001b58:	2300      	movs	r3, #0
 8001b5a:	e006      	b.n	8001b6a <odober_kartu+0xbe>
	uint8_t j;
	uint8_t pom;
	uint32_t *addres;
	uint8_t RemoveID;
	uint32_t RemoveIDAddress;
	for (j = 0; j < 8; j++) {
 8001b5c:	7d7b      	ldrb	r3, [r7, #21]
 8001b5e:	3301      	adds	r3, #1
 8001b60:	757b      	strb	r3, [r7, #21]
 8001b62:	7d7b      	ldrb	r3, [r7, #21]
 8001b64:	2b07      	cmp	r3, #7
 8001b66:	d9a8      	bls.n	8001aba <odober_kartu+0xe>
				FLASH_Lock();
				return MI_OK;
			}
		}
	}
	return MI_ERR;
 8001b68:	2302      	movs	r3, #2
}
 8001b6a:	4618      	mov	r0, r3
 8001b6c:	3718      	adds	r7, #24
 8001b6e:	46bd      	mov	sp, r7
 8001b70:	bd80      	pop	{r7, pc}
 8001b72:	bf00      	nop
 8001b74:	08080014 	.word	0x08080014

08001b78 <zapis_pristupu>:
 }*/

///////////////////////////////////////////////////////////
// funkcia na zapis poslednych 5 pristupov na adresach
//0x08080500 az 0x080805A0
void zapis_pristupu(uint8_t* CardID) {
 8001b78:	b580      	push	{r7, lr}
 8001b7a:	b086      	sub	sp, #24
 8001b7c:	af00      	add	r7, sp, #0
 8001b7e:	6078      	str	r0, [r7, #4]
	uint8_t k;
	uint8_t i;
	uint32_t TempIDAddres;
	uint8_t TempID;
	uint32_t *addres;
	FLASH_Unlock();
 8001b80:	f7fe fb76 	bl	8000270 <FLASH_Unlock>
	for (i = 24; i > 0; i--) {
 8001b84:	2318      	movs	r3, #24
 8001b86:	757b      	strb	r3, [r7, #21]
 8001b88:	e026      	b.n	8001bd8 <zapis_pristupu+0x60>
		for (j = 0; j < 5; j++) {
 8001b8a:	2300      	movs	r3, #0
 8001b8c:	75fb      	strb	r3, [r7, #23]
 8001b8e:	e01d      	b.n	8001bcc <zapis_pristupu+0x54>
			addres = (uint32_t *) (0x08080500 + (0x4 * j)
 8001b90:	7dfa      	ldrb	r2, [r7, #23]
 8001b92:	4b22      	ldr	r3, [pc, #136]	; (8001c1c <zapis_pristupu+0xa4>)
 8001b94:	4413      	add	r3, r2
					+ ((i - 1) * 0x8 * 0x4));
 8001b96:	7d7a      	ldrb	r2, [r7, #21]
 8001b98:	3a01      	subs	r2, #1
 8001b9a:	00d2      	lsls	r2, r2, #3
 8001b9c:	4413      	add	r3, r2
 8001b9e:	009b      	lsls	r3, r3, #2
	uint8_t TempID;
	uint32_t *addres;
	FLASH_Unlock();
	for (i = 24; i > 0; i--) {
		for (j = 0; j < 5; j++) {
			addres = (uint32_t *) (0x08080500 + (0x4 * j)
 8001ba0:	613b      	str	r3, [r7, #16]
					+ ((i - 1) * 0x8 * 0x4));
			TempID = *addres;
 8001ba2:	693b      	ldr	r3, [r7, #16]
 8001ba4:	681b      	ldr	r3, [r3, #0]
 8001ba6:	73fb      	strb	r3, [r7, #15]
			addres = (uint32_t *) (0x08080500 + (0x4 * j) + ((i) * 0x8 * 0x4));
 8001ba8:	7dfa      	ldrb	r2, [r7, #23]
 8001baa:	4b1c      	ldr	r3, [pc, #112]	; (8001c1c <zapis_pristupu+0xa4>)
 8001bac:	4413      	add	r3, r2
 8001bae:	7d7a      	ldrb	r2, [r7, #21]
 8001bb0:	00d2      	lsls	r2, r2, #3
 8001bb2:	4413      	add	r3, r2
 8001bb4:	009b      	lsls	r3, r3, #2
 8001bb6:	613b      	str	r3, [r7, #16]
			TempIDAddres = (uint32_t) (addres);
 8001bb8:	693b      	ldr	r3, [r7, #16]
 8001bba:	60bb      	str	r3, [r7, #8]
			DATA_EEPROM_ProgramByte(TempIDAddres, TempID);
 8001bbc:	7bfb      	ldrb	r3, [r7, #15]
 8001bbe:	4619      	mov	r1, r3
 8001bc0:	68b8      	ldr	r0, [r7, #8]
 8001bc2:	f7fe fbab 	bl	800031c <DATA_EEPROM_ProgramByte>
	uint32_t TempIDAddres;
	uint8_t TempID;
	uint32_t *addres;
	FLASH_Unlock();
	for (i = 24; i > 0; i--) {
		for (j = 0; j < 5; j++) {
 8001bc6:	7dfb      	ldrb	r3, [r7, #23]
 8001bc8:	3301      	adds	r3, #1
 8001bca:	75fb      	strb	r3, [r7, #23]
 8001bcc:	7dfb      	ldrb	r3, [r7, #23]
 8001bce:	2b04      	cmp	r3, #4
 8001bd0:	d9de      	bls.n	8001b90 <zapis_pristupu+0x18>
	uint8_t i;
	uint32_t TempIDAddres;
	uint8_t TempID;
	uint32_t *addres;
	FLASH_Unlock();
	for (i = 24; i > 0; i--) {
 8001bd2:	7d7b      	ldrb	r3, [r7, #21]
 8001bd4:	3b01      	subs	r3, #1
 8001bd6:	757b      	strb	r3, [r7, #21]
 8001bd8:	7d7b      	ldrb	r3, [r7, #21]
 8001bda:	2b00      	cmp	r3, #0
 8001bdc:	d1d5      	bne.n	8001b8a <zapis_pristupu+0x12>
			addres = (uint32_t *) (0x08080500 + (0x4 * j) + ((i) * 0x8 * 0x4));
			TempIDAddres = (uint32_t) (addres);
			DATA_EEPROM_ProgramByte(TempIDAddres, TempID);
		}
	}
	for (k = 0; k < 5; k++) {
 8001bde:	2300      	movs	r3, #0
 8001be0:	75bb      	strb	r3, [r7, #22]
 8001be2:	e011      	b.n	8001c08 <zapis_pristupu+0x90>
		addres = (uint32_t *) 0x08080500 + 0x1 * k;
 8001be4:	7dbb      	ldrb	r3, [r7, #22]
 8001be6:	009a      	lsls	r2, r3, #2
 8001be8:	4b0d      	ldr	r3, [pc, #52]	; (8001c20 <zapis_pristupu+0xa8>)
 8001bea:	4413      	add	r3, r2
 8001bec:	613b      	str	r3, [r7, #16]
		TempIDAddres = (uint32_t) (addres);
 8001bee:	693b      	ldr	r3, [r7, #16]
 8001bf0:	60bb      	str	r3, [r7, #8]
		DATA_EEPROM_ProgramByte(TempIDAddres, CardID[k]);
 8001bf2:	7dbb      	ldrb	r3, [r7, #22]
 8001bf4:	687a      	ldr	r2, [r7, #4]
 8001bf6:	4413      	add	r3, r2
 8001bf8:	781b      	ldrb	r3, [r3, #0]
 8001bfa:	4619      	mov	r1, r3
 8001bfc:	68b8      	ldr	r0, [r7, #8]
 8001bfe:	f7fe fb8d 	bl	800031c <DATA_EEPROM_ProgramByte>
			addres = (uint32_t *) (0x08080500 + (0x4 * j) + ((i) * 0x8 * 0x4));
			TempIDAddres = (uint32_t) (addres);
			DATA_EEPROM_ProgramByte(TempIDAddres, TempID);
		}
	}
	for (k = 0; k < 5; k++) {
 8001c02:	7dbb      	ldrb	r3, [r7, #22]
 8001c04:	3301      	adds	r3, #1
 8001c06:	75bb      	strb	r3, [r7, #22]
 8001c08:	7dbb      	ldrb	r3, [r7, #22]
 8001c0a:	2b04      	cmp	r3, #4
 8001c0c:	d9ea      	bls.n	8001be4 <zapis_pristupu+0x6c>
		addres = (uint32_t *) 0x08080500 + 0x1 * k;
		TempIDAddres = (uint32_t) (addres);
		DATA_EEPROM_ProgramByte(TempIDAddres, CardID[k]);
	}
	FLASH_Lock();
 8001c0e:	f7fe fb47 	bl	80002a0 <FLASH_Lock>
}
 8001c12:	bf00      	nop
 8001c14:	3718      	adds	r7, #24
 8001c16:	46bd      	mov	sp, r7
 8001c18:	bd80      	pop	{r7, pc}
 8001c1a:	bf00      	nop
 8001c1c:	02020140 	.word	0x02020140
 8001c20:	08080500 	.word	0x08080500

08001c24 <vypis_pristupov>:

void vypis_pristupov(void) {
 8001c24:	b5b0      	push	{r4, r5, r7, lr}
 8001c26:	b092      	sub	sp, #72	; 0x48
 8001c28:	af04      	add	r7, sp, #16
	uint8_t j;
	uint8_t PrintID[5];
	uint32_t *addres;
	char buffer[30];

	zaciatok: pom = 0;
 8001c2a:	2300      	movs	r3, #0
 8001c2c:	637b      	str	r3, [r7, #52]	; 0x34
	lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001c2e:	22ff      	movs	r2, #255	; 0xff
 8001c30:	21ff      	movs	r1, #255	; 0xff
 8001c32:	20ff      	movs	r0, #255	; 0xff
 8001c34:	f000 fe20 	bl	8002878 <decodeRgbValue>
 8001c38:	4603      	mov	r3, r0
 8001c3a:	4618      	mov	r0, r3
 8001c3c:	f000 fb14 	bl	8002268 <lcdClearDisplay>
	sprintf(buffer, "Zoznam poslednych  pristupov %d /5", pom + 1);
 8001c40:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001c42:	1c5a      	adds	r2, r3, #1
 8001c44:	1d3b      	adds	r3, r7, #4
 8001c46:	4997      	ldr	r1, [pc, #604]	; (8001ea4 <vypis_pristupov+0x280>)
 8001c48:	4618      	mov	r0, r3
 8001c4a:	f001 fcd5 	bl	80035f8 <siprintf>
	lcdPutS(buffer, 10, 40, decodeRgbValue(0, 0, 255),
 8001c4e:	22ff      	movs	r2, #255	; 0xff
 8001c50:	2100      	movs	r1, #0
 8001c52:	2000      	movs	r0, #0
 8001c54:	f000 fe10 	bl	8002878 <decodeRgbValue>
 8001c58:	4603      	mov	r3, r0
 8001c5a:	461c      	mov	r4, r3
 8001c5c:	22ff      	movs	r2, #255	; 0xff
 8001c5e:	21ff      	movs	r1, #255	; 0xff
 8001c60:	20ff      	movs	r0, #255	; 0xff
 8001c62:	f000 fe09 	bl	8002878 <decodeRgbValue>
 8001c66:	4603      	mov	r3, r0
 8001c68:	1d38      	adds	r0, r7, #4
 8001c6a:	9300      	str	r3, [sp, #0]
 8001c6c:	4623      	mov	r3, r4
 8001c6e:	2228      	movs	r2, #40	; 0x28
 8001c70:	210a      	movs	r1, #10
 8001c72:	f000 fe1d 	bl	80028b0 <lcdPutS>
			decodeRgbValue(255, 255, 255));
	for (i = 0; i < 5; i++) {
 8001c76:	2300      	movs	r3, #0
 8001c78:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8001c7c:	e057      	b.n	8001d2e <vypis_pristupov+0x10a>
		for (j = 0; j < 5; j++) {
 8001c7e:	2300      	movs	r3, #0
 8001c80:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 8001c84:	e019      	b.n	8001cba <vypis_pristupov+0x96>
			addres = (uint32_t *) 0x08080500 + 0x1 * j + i * 0x8;
 8001c86:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8001c8a:	009b      	lsls	r3, r3, #2
 8001c8c:	461a      	mov	r2, r3
 8001c8e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8001c92:	015b      	lsls	r3, r3, #5
 8001c94:	441a      	add	r2, r3
 8001c96:	4b84      	ldr	r3, [pc, #528]	; (8001ea8 <vypis_pristupov+0x284>)
 8001c98:	4413      	add	r3, r2
 8001c9a:	62fb      	str	r3, [r7, #44]	; 0x2c
			PrintID[j] = *addres;
 8001c9c:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8001ca0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001ca2:	6812      	ldr	r2, [r2, #0]
 8001ca4:	b2d2      	uxtb	r2, r2
 8001ca6:	f107 0138 	add.w	r1, r7, #56	; 0x38
 8001caa:	440b      	add	r3, r1
 8001cac:	f803 2c14 	strb.w	r2, [r3, #-20]
	lcdClearDisplay(decodeRgbValue(255, 255, 255));
	sprintf(buffer, "Zoznam poslednych  pristupov %d /5", pom + 1);
	lcdPutS(buffer, 10, 40, decodeRgbValue(0, 0, 255),
			decodeRgbValue(255, 255, 255));
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 5; j++) {
 8001cb0:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8001cb4:	3301      	adds	r3, #1
 8001cb6:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 8001cba:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8001cbe:	2b04      	cmp	r3, #4
 8001cc0:	d9e1      	bls.n	8001c86 <vypis_pristupov+0x62>
			addres = (uint32_t *) 0x08080500 + 0x1 * j + i * 0x8;
			PrintID[j] = *addres;
		}
		sprintf(buffer, "%x-%x-%x-%x-%x", PrintID[0], PrintID[1], PrintID[2],
 8001cc2:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8001cc6:	461c      	mov	r4, r3
 8001cc8:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 8001ccc:	461d      	mov	r5, r3
 8001cce:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
				PrintID[3], PrintID[4]);
 8001cd2:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8001cd6:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 5; j++) {
			addres = (uint32_t *) 0x08080500 + 0x1 * j + i * 0x8;
			PrintID[j] = *addres;
		}
		sprintf(buffer, "%x-%x-%x-%x-%x", PrintID[0], PrintID[1], PrintID[2],
 8001cda:	1d38      	adds	r0, r7, #4
 8001cdc:	9102      	str	r1, [sp, #8]
 8001cde:	9201      	str	r2, [sp, #4]
 8001ce0:	9300      	str	r3, [sp, #0]
 8001ce2:	462b      	mov	r3, r5
 8001ce4:	4622      	mov	r2, r4
 8001ce6:	4971      	ldr	r1, [pc, #452]	; (8001eac <vypis_pristupov+0x288>)
 8001ce8:	f001 fc86 	bl	80035f8 <siprintf>
				PrintID[3], PrintID[4]);
		lcdPutS(buffer, 10, 67 + 9 * i, decodeRgbValue(0, 0, 255),
 8001cec:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8001cf0:	461a      	mov	r2, r3
 8001cf2:	00d2      	lsls	r2, r2, #3
 8001cf4:	4413      	add	r3, r2
 8001cf6:	b2db      	uxtb	r3, r3
 8001cf8:	3343      	adds	r3, #67	; 0x43
 8001cfa:	b2dc      	uxtb	r4, r3
 8001cfc:	22ff      	movs	r2, #255	; 0xff
 8001cfe:	2100      	movs	r1, #0
 8001d00:	2000      	movs	r0, #0
 8001d02:	f000 fdb9 	bl	8002878 <decodeRgbValue>
 8001d06:	4603      	mov	r3, r0
 8001d08:	461d      	mov	r5, r3
 8001d0a:	22ff      	movs	r2, #255	; 0xff
 8001d0c:	21ff      	movs	r1, #255	; 0xff
 8001d0e:	20ff      	movs	r0, #255	; 0xff
 8001d10:	f000 fdb2 	bl	8002878 <decodeRgbValue>
 8001d14:	4603      	mov	r3, r0
 8001d16:	1d38      	adds	r0, r7, #4
 8001d18:	9300      	str	r3, [sp, #0]
 8001d1a:	462b      	mov	r3, r5
 8001d1c:	4622      	mov	r2, r4
 8001d1e:	210a      	movs	r1, #10
 8001d20:	f000 fdc6 	bl	80028b0 <lcdPutS>
	zaciatok: pom = 0;
	lcdClearDisplay(decodeRgbValue(255, 255, 255));
	sprintf(buffer, "Zoznam poslednych  pristupov %d /5", pom + 1);
	lcdPutS(buffer, 10, 40, decodeRgbValue(0, 0, 255),
			decodeRgbValue(255, 255, 255));
	for (i = 0; i < 5; i++) {
 8001d24:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8001d28:	3301      	adds	r3, #1
 8001d2a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8001d2e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8001d32:	2b04      	cmp	r3, #4
 8001d34:	d9a3      	bls.n	8001c7e <vypis_pristupov+0x5a>
				PrintID[3], PrintID[4]);
		lcdPutS(buffer, 10, 67 + 9 * i, decodeRgbValue(0, 0, 255),
				decodeRgbValue(255, 255, 255));

	}
	Delay_us(1500000);
 8001d36:	485e      	ldr	r0, [pc, #376]	; (8001eb0 <vypis_pristupov+0x28c>)
 8001d38:	f001 f85a 	bl	8002df0 <Delay_us>
	while (1) {
		if (((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8)) + 1) % 2 == 0) {
 8001d3c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001d40:	485c      	ldr	r0, [pc, #368]	; (8001eb4 <vypis_pristupov+0x290>)
 8001d42:	f7fe fbef 	bl	8000524 <GPIO_ReadInputDataBit>
 8001d46:	4603      	mov	r3, r0
 8001d48:	3301      	adds	r3, #1
 8001d4a:	f003 0301 	and.w	r3, r3, #1
 8001d4e:	2b00      	cmp	r3, #0
 8001d50:	f040 8094 	bne.w	8001e7c <vypis_pristupov+0x258>
			pom++;
 8001d54:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001d56:	3301      	adds	r3, #1
 8001d58:	637b      	str	r3, [r7, #52]	; 0x34
			if (pom == 5) {
 8001d5a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001d5c:	2b05      	cmp	r3, #5
 8001d5e:	d100      	bne.n	8001d62 <vypis_pristupov+0x13e>

				goto zaciatok;
 8001d60:	e763      	b.n	8001c2a <vypis_pristupov+0x6>
			}
			lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001d62:	22ff      	movs	r2, #255	; 0xff
 8001d64:	21ff      	movs	r1, #255	; 0xff
 8001d66:	20ff      	movs	r0, #255	; 0xff
 8001d68:	f000 fd86 	bl	8002878 <decodeRgbValue>
 8001d6c:	4603      	mov	r3, r0
 8001d6e:	4618      	mov	r0, r3
 8001d70:	f000 fa7a 	bl	8002268 <lcdClearDisplay>
			sprintf(buffer, "Zoznam poslednych  pristupov %d/5", pom + 1);
 8001d74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001d76:	1c5a      	adds	r2, r3, #1
 8001d78:	1d3b      	adds	r3, r7, #4
 8001d7a:	494f      	ldr	r1, [pc, #316]	; (8001eb8 <vypis_pristupov+0x294>)
 8001d7c:	4618      	mov	r0, r3
 8001d7e:	f001 fc3b 	bl	80035f8 <siprintf>
			lcdPutS(buffer, 10, 40, decodeRgbValue(0, 0, 255),
 8001d82:	22ff      	movs	r2, #255	; 0xff
 8001d84:	2100      	movs	r1, #0
 8001d86:	2000      	movs	r0, #0
 8001d88:	f000 fd76 	bl	8002878 <decodeRgbValue>
 8001d8c:	4603      	mov	r3, r0
 8001d8e:	461c      	mov	r4, r3
 8001d90:	22ff      	movs	r2, #255	; 0xff
 8001d92:	21ff      	movs	r1, #255	; 0xff
 8001d94:	20ff      	movs	r0, #255	; 0xff
 8001d96:	f000 fd6f 	bl	8002878 <decodeRgbValue>
 8001d9a:	4603      	mov	r3, r0
 8001d9c:	1d38      	adds	r0, r7, #4
 8001d9e:	9300      	str	r3, [sp, #0]
 8001da0:	4623      	mov	r3, r4
 8001da2:	2228      	movs	r2, #40	; 0x28
 8001da4:	210a      	movs	r1, #10
 8001da6:	f000 fd83 	bl	80028b0 <lcdPutS>
					decodeRgbValue(255, 255, 255));
			for (i = 0; i < 5; i++) {
 8001daa:	2300      	movs	r3, #0
 8001dac:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8001db0:	e05d      	b.n	8001e6e <vypis_pristupov+0x24a>
				for (j = 0; j < 5; j++) {
 8001db2:	2300      	movs	r3, #0
 8001db4:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 8001db8:	e01f      	b.n	8001dfa <vypis_pristupov+0x1d6>
					addres = (uint32_t *) 0x08080500 + 0x1 * j + i * 0x8
							+ (0x8 * 0x5 * pom);
 8001dba:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8001dbe:	009b      	lsls	r3, r3, #2
 8001dc0:	461a      	mov	r2, r3
 8001dc2:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8001dc6:	015b      	lsls	r3, r3, #5
 8001dc8:	18d1      	adds	r1, r2, r3
 8001dca:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8001dcc:	4613      	mov	r3, r2
 8001dce:	009b      	lsls	r3, r3, #2
 8001dd0:	4413      	add	r3, r2
 8001dd2:	015b      	lsls	r3, r3, #5
 8001dd4:	18ca      	adds	r2, r1, r3
			sprintf(buffer, "Zoznam poslednych  pristupov %d/5", pom + 1);
			lcdPutS(buffer, 10, 40, decodeRgbValue(0, 0, 255),
					decodeRgbValue(255, 255, 255));
			for (i = 0; i < 5; i++) {
				for (j = 0; j < 5; j++) {
					addres = (uint32_t *) 0x08080500 + 0x1 * j + i * 0x8
 8001dd6:	4b34      	ldr	r3, [pc, #208]	; (8001ea8 <vypis_pristupov+0x284>)
 8001dd8:	4413      	add	r3, r2
 8001dda:	62fb      	str	r3, [r7, #44]	; 0x2c
							+ (0x8 * 0x5 * pom);
					PrintID[j] = *addres;
 8001ddc:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8001de0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001de2:	6812      	ldr	r2, [r2, #0]
 8001de4:	b2d2      	uxtb	r2, r2
 8001de6:	f107 0138 	add.w	r1, r7, #56	; 0x38
 8001dea:	440b      	add	r3, r1
 8001dec:	f803 2c14 	strb.w	r2, [r3, #-20]
			lcdClearDisplay(decodeRgbValue(255, 255, 255));
			sprintf(buffer, "Zoznam poslednych  pristupov %d/5", pom + 1);
			lcdPutS(buffer, 10, 40, decodeRgbValue(0, 0, 255),
					decodeRgbValue(255, 255, 255));
			for (i = 0; i < 5; i++) {
				for (j = 0; j < 5; j++) {
 8001df0:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8001df4:	3301      	adds	r3, #1
 8001df6:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 8001dfa:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8001dfe:	2b04      	cmp	r3, #4
 8001e00:	d9db      	bls.n	8001dba <vypis_pristupov+0x196>
					addres = (uint32_t *) 0x08080500 + 0x1 * j + i * 0x8
							+ (0x8 * 0x5 * pom);
					PrintID[j] = *addres;
				}
				sprintf(buffer, "%x-%x-%x-%x-%x", PrintID[0], PrintID[1],
 8001e02:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
 8001e06:	461c      	mov	r4, r3
 8001e08:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 8001e0c:	461d      	mov	r5, r3
						PrintID[2], PrintID[3], PrintID[4]);
 8001e0e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8001e12:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8001e16:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
				for (j = 0; j < 5; j++) {
					addres = (uint32_t *) 0x08080500 + 0x1 * j + i * 0x8
							+ (0x8 * 0x5 * pom);
					PrintID[j] = *addres;
				}
				sprintf(buffer, "%x-%x-%x-%x-%x", PrintID[0], PrintID[1],
 8001e1a:	1d38      	adds	r0, r7, #4
 8001e1c:	9102      	str	r1, [sp, #8]
 8001e1e:	9201      	str	r2, [sp, #4]
 8001e20:	9300      	str	r3, [sp, #0]
 8001e22:	462b      	mov	r3, r5
 8001e24:	4622      	mov	r2, r4
 8001e26:	4921      	ldr	r1, [pc, #132]	; (8001eac <vypis_pristupov+0x288>)
 8001e28:	f001 fbe6 	bl	80035f8 <siprintf>
						PrintID[2], PrintID[3], PrintID[4]);
				lcdPutS(buffer, 10, 67 + 9 * i, decodeRgbValue(0, 0, 255),
 8001e2c:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8001e30:	461a      	mov	r2, r3
 8001e32:	00d2      	lsls	r2, r2, #3
 8001e34:	4413      	add	r3, r2
 8001e36:	b2db      	uxtb	r3, r3
 8001e38:	3343      	adds	r3, #67	; 0x43
 8001e3a:	b2dc      	uxtb	r4, r3
 8001e3c:	22ff      	movs	r2, #255	; 0xff
 8001e3e:	2100      	movs	r1, #0
 8001e40:	2000      	movs	r0, #0
 8001e42:	f000 fd19 	bl	8002878 <decodeRgbValue>
 8001e46:	4603      	mov	r3, r0
 8001e48:	461d      	mov	r5, r3
 8001e4a:	22ff      	movs	r2, #255	; 0xff
 8001e4c:	21ff      	movs	r1, #255	; 0xff
 8001e4e:	20ff      	movs	r0, #255	; 0xff
 8001e50:	f000 fd12 	bl	8002878 <decodeRgbValue>
 8001e54:	4603      	mov	r3, r0
 8001e56:	1d38      	adds	r0, r7, #4
 8001e58:	9300      	str	r3, [sp, #0]
 8001e5a:	462b      	mov	r3, r5
 8001e5c:	4622      	mov	r2, r4
 8001e5e:	210a      	movs	r1, #10
 8001e60:	f000 fd26 	bl	80028b0 <lcdPutS>
			}
			lcdClearDisplay(decodeRgbValue(255, 255, 255));
			sprintf(buffer, "Zoznam poslednych  pristupov %d/5", pom + 1);
			lcdPutS(buffer, 10, 40, decodeRgbValue(0, 0, 255),
					decodeRgbValue(255, 255, 255));
			for (i = 0; i < 5; i++) {
 8001e64:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8001e68:	3301      	adds	r3, #1
 8001e6a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8001e6e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8001e72:	2b04      	cmp	r3, #4
 8001e74:	d99d      	bls.n	8001db2 <vypis_pristupov+0x18e>
						PrintID[2], PrintID[3], PrintID[4]);
				lcdPutS(buffer, 10, 67 + 9 * i, decodeRgbValue(0, 0, 255),
						decodeRgbValue(255, 255, 255));

			}
			Delay(1);
 8001e76:	2001      	movs	r0, #1
 8001e78:	f000 ffa0 	bl	8002dbc <Delay>

		}
		//((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)) + 1) % 2 != 0
		if (((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)) + 1) % 2 == 0) {
 8001e7c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001e80:	480c      	ldr	r0, [pc, #48]	; (8001eb4 <vypis_pristupov+0x290>)
 8001e82:	f7fe fb4f 	bl	8000524 <GPIO_ReadInputDataBit>
 8001e86:	4603      	mov	r3, r0
 8001e88:	3301      	adds	r3, #1
 8001e8a:	f003 0301 	and.w	r3, r3, #1
 8001e8e:	2b00      	cmp	r3, #0
 8001e90:	d000      	beq.n	8001e94 <vypis_pristupov+0x270>
			goto koniec;
		}
	}
 8001e92:	e753      	b.n	8001d3c <vypis_pristupov+0x118>
			Delay(1);

		}
		//((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)) + 1) % 2 != 0
		if (((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)) + 1) % 2 == 0) {
			goto koniec;
 8001e94:	bf00      	nop
		}
	}
	koniec: welcome();
 8001e96:	f000 fd47 	bl	8002928 <welcome>
}
 8001e9a:	bf00      	nop
 8001e9c:	3738      	adds	r7, #56	; 0x38
 8001e9e:	46bd      	mov	sp, r7
 8001ea0:	bdb0      	pop	{r4, r5, r7, pc}
 8001ea2:	bf00      	nop
 8001ea4:	08003824 	.word	0x08003824
 8001ea8:	08080500 	.word	0x08080500
 8001eac:	08003848 	.word	0x08003848
 8001eb0:	0016e360 	.word	0x0016e360
 8001eb4:	40020400 	.word	0x40020400
 8001eb8:	08003858 	.word	0x08003858

08001ebc <kontrola_zoznamu>:

void kontrola_zoznamu(void) {
 8001ebc:	b5b0      	push	{r4, r5, r7, lr}
 8001ebe:	b09c      	sub	sp, #112	; 0x70
 8001ec0:	af02      	add	r7, sp, #8
	int pom = 0;
 8001ec2:	2300      	movs	r3, #0
 8001ec4:	667b      	str	r3, [r7, #100]	; 0x64
	uint8_t TempID;
	uint32_t *addres;
	unsigned char CardID[5];
	char bufferDisplay[76];
	for (uint8_t a = 0; a < 8; a++) {
 8001ec6:	2300      	movs	r3, #0
 8001ec8:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
 8001ecc:	e015      	b.n	8001efa <kontrola_zoznamu+0x3e>
		addres = (uint32_t *) (0x08080000 + (0x4 * a) + (0x5 * 0x4));
 8001ece:	f897 2063 	ldrb.w	r2, [r7, #99]	; 0x63
 8001ed2:	4b4f      	ldr	r3, [pc, #316]	; (8002010 <kontrola_zoznamu+0x154>)
 8001ed4:	4413      	add	r3, r2
 8001ed6:	009b      	lsls	r3, r3, #2
 8001ed8:	65bb      	str	r3, [r7, #88]	; 0x58
		TempID = *addres;
 8001eda:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8001edc:	681b      	ldr	r3, [r3, #0]
 8001ede:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		//addres = (uint32_t *) 0x08080000 + (0x05) + (a * 0x8);
		//TempID = *addres;
		if (TempID == 1) {
 8001ee2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8001ee6:	2b01      	cmp	r3, #1
 8001ee8:	d102      	bne.n	8001ef0 <kontrola_zoznamu+0x34>
			pom++;
 8001eea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001eec:	3301      	adds	r3, #1
 8001eee:	667b      	str	r3, [r7, #100]	; 0x64
	int pom = 0;
	uint8_t TempID;
	uint32_t *addres;
	unsigned char CardID[5];
	char bufferDisplay[76];
	for (uint8_t a = 0; a < 8; a++) {
 8001ef0:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8001ef4:	3301      	adds	r3, #1
 8001ef6:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63
 8001efa:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 8001efe:	2b07      	cmp	r3, #7
 8001f00:	d9e5      	bls.n	8001ece <kontrola_zoznamu+0x12>
		if (TempID == 1) {
			pom++;
		}

	}
	if (pom == 0) {
 8001f02:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001f04:	2b00      	cmp	r3, #0
 8001f06:	d177      	bne.n	8001ff8 <kontrola_zoznamu+0x13c>
		GPIO_SetBits(GPIOA, GPIO_Pin_4);
 8001f08:	2110      	movs	r1, #16
 8001f0a:	4842      	ldr	r0, [pc, #264]	; (8002014 <kontrola_zoznamu+0x158>)
 8001f0c:	f7fe fb26 	bl	800055c <GPIO_SetBits>
		sprintf(bufferDisplay,
 8001f10:	1d3b      	adds	r3, r7, #4
 8001f12:	4a41      	ldr	r2, [pc, #260]	; (8002018 <kontrola_zoznamu+0x15c>)
 8001f14:	4618      	mov	r0, r3
 8001f16:	4611      	mov	r1, r2
 8001f18:	2343      	movs	r3, #67	; 0x43
 8001f1a:	461a      	mov	r2, r3
 8001f1c:	f001 fba8 	bl	8003670 <memcpy>
				"Ziadna karta v     zozname prilozte   kartu na pociatocnezapisanie");
		lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001f20:	22ff      	movs	r2, #255	; 0xff
 8001f22:	21ff      	movs	r1, #255	; 0xff
 8001f24:	20ff      	movs	r0, #255	; 0xff
 8001f26:	f000 fca7 	bl	8002878 <decodeRgbValue>
 8001f2a:	4603      	mov	r3, r0
 8001f2c:	4618      	mov	r0, r3
 8001f2e:	f000 f99b 	bl	8002268 <lcdClearDisplay>
		lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
 8001f32:	22ff      	movs	r2, #255	; 0xff
 8001f34:	2100      	movs	r1, #0
 8001f36:	2000      	movs	r0, #0
 8001f38:	f000 fc9e 	bl	8002878 <decodeRgbValue>
 8001f3c:	4603      	mov	r3, r0
 8001f3e:	461c      	mov	r4, r3
 8001f40:	22ff      	movs	r2, #255	; 0xff
 8001f42:	21ff      	movs	r1, #255	; 0xff
 8001f44:	20ff      	movs	r0, #255	; 0xff
 8001f46:	f000 fc97 	bl	8002878 <decodeRgbValue>
 8001f4a:	4603      	mov	r3, r0
 8001f4c:	1d38      	adds	r0, r7, #4
 8001f4e:	9300      	str	r3, [sp, #0]
 8001f50:	4623      	mov	r3, r4
 8001f52:	2232      	movs	r2, #50	; 0x32
 8001f54:	210a      	movs	r1, #10
 8001f56:	f000 fcab 	bl	80028b0 <lcdPutS>
				decodeRgbValue(255, 255, 255));
	}
	while (pom == 0) {
 8001f5a:	e04d      	b.n	8001ff8 <kontrola_zoznamu+0x13c>

		if (TM_MFRC522_Check(CardID) == MI_OK) {
 8001f5c:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8001f60:	4618      	mov	r0, r3
 8001f62:	f7ff f813 	bl	8000f8c <TM_MFRC522_Check>
 8001f66:	4603      	mov	r3, r0
 8001f68:	2b00      	cmp	r3, #0
 8001f6a:	d142      	bne.n	8001ff2 <kontrola_zoznamu+0x136>
			pridaj_kartu(CardID);
 8001f6c:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8001f70:	4618      	mov	r0, r3
 8001f72:	f7ff fd51 	bl	8001a18 <pridaj_kartu>
			lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8001f76:	22ff      	movs	r2, #255	; 0xff
 8001f78:	21ff      	movs	r1, #255	; 0xff
 8001f7a:	20ff      	movs	r0, #255	; 0xff
 8001f7c:	f000 fc7c 	bl	8002878 <decodeRgbValue>
 8001f80:	4603      	mov	r3, r0
 8001f82:	4618      	mov	r0, r3
 8001f84:	f000 f970 	bl	8002268 <lcdClearDisplay>
			sprintf(bufferDisplay, "Uspesne zapisanie");
 8001f88:	1d3b      	adds	r3, r7, #4
 8001f8a:	4a24      	ldr	r2, [pc, #144]	; (800201c <kontrola_zoznamu+0x160>)
 8001f8c:	461c      	mov	r4, r3
 8001f8e:	4615      	mov	r5, r2
 8001f90:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001f92:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8001f94:	682b      	ldr	r3, [r5, #0]
 8001f96:	8023      	strh	r3, [r4, #0]
			//odober_kartu(newCardID);
			lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
 8001f98:	22ff      	movs	r2, #255	; 0xff
 8001f9a:	2100      	movs	r1, #0
 8001f9c:	2000      	movs	r0, #0
 8001f9e:	f000 fc6b 	bl	8002878 <decodeRgbValue>
 8001fa2:	4603      	mov	r3, r0
 8001fa4:	461c      	mov	r4, r3
 8001fa6:	22ff      	movs	r2, #255	; 0xff
 8001fa8:	21ff      	movs	r1, #255	; 0xff
 8001faa:	20ff      	movs	r0, #255	; 0xff
 8001fac:	f000 fc64 	bl	8002878 <decodeRgbValue>
 8001fb0:	4603      	mov	r3, r0
 8001fb2:	1d38      	adds	r0, r7, #4
 8001fb4:	9300      	str	r3, [sp, #0]
 8001fb6:	4623      	mov	r3, r4
 8001fb8:	2232      	movs	r2, #50	; 0x32
 8001fba:	210a      	movs	r1, #10
 8001fbc:	f000 fc78 	bl	80028b0 <lcdPutS>
					decodeRgbValue(255, 255, 255));

			//vykreslenie OK
			ok();
 8001fc0:	f000 fd28 	bl	8002a14 <ok>
			for (int c = 0; c < 6; c++) {
 8001fc4:	2300      	movs	r3, #0
 8001fc6:	65fb      	str	r3, [r7, #92]	; 0x5c
 8001fc8:	e009      	b.n	8001fde <kontrola_zoznamu+0x122>
				GPIO_ToggleBits(GPIOA, GPIO_Pin_4);
 8001fca:	2110      	movs	r1, #16
 8001fcc:	4811      	ldr	r0, [pc, #68]	; (8002014 <kontrola_zoznamu+0x158>)
 8001fce:	f7fe fae1 	bl	8000594 <GPIO_ToggleBits>
				Delay_us(200000);
 8001fd2:	4813      	ldr	r0, [pc, #76]	; (8002020 <kontrola_zoznamu+0x164>)
 8001fd4:	f000 ff0c 	bl	8002df0 <Delay_us>
			lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
					decodeRgbValue(255, 255, 255));

			//vykreslenie OK
			ok();
			for (int c = 0; c < 6; c++) {
 8001fd8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001fda:	3301      	adds	r3, #1
 8001fdc:	65fb      	str	r3, [r7, #92]	; 0x5c
 8001fde:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001fe0:	2b05      	cmp	r3, #5
 8001fe2:	ddf2      	ble.n	8001fca <kontrola_zoznamu+0x10e>
				GPIO_ToggleBits(GPIOA, GPIO_Pin_4);
				Delay_us(200000);
			}
			Delay(1);
 8001fe4:	2001      	movs	r0, #1
 8001fe6:	f000 fee9 	bl	8002dbc <Delay>

			pom++;
 8001fea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001fec:	3301      	adds	r3, #1
 8001fee:	667b      	str	r3, [r7, #100]	; 0x64
 8001ff0:	e002      	b.n	8001ff8 <kontrola_zoznamu+0x13c>
		} else {
			Delay_us(100000);
 8001ff2:	480c      	ldr	r0, [pc, #48]	; (8002024 <kontrola_zoznamu+0x168>)
 8001ff4:	f000 fefc 	bl	8002df0 <Delay_us>
				"Ziadna karta v     zozname prilozte   kartu na pociatocnezapisanie");
		lcdClearDisplay(decodeRgbValue(255, 255, 255));
		lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
				decodeRgbValue(255, 255, 255));
	}
	while (pom == 0) {
 8001ff8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001ffa:	2b00      	cmp	r3, #0
 8001ffc:	d0ae      	beq.n	8001f5c <kontrola_zoznamu+0xa0>
			pom++;
		} else {
			Delay_us(100000);
		}
	}
	GPIO_ResetBits(GPIOA, GPIO_Pin_4);
 8001ffe:	2110      	movs	r1, #16
 8002000:	4804      	ldr	r0, [pc, #16]	; (8002014 <kontrola_zoznamu+0x158>)
 8002002:	f7fe fab9 	bl	8000578 <GPIO_ResetBits>
}
 8002006:	bf00      	nop
 8002008:	3768      	adds	r7, #104	; 0x68
 800200a:	46bd      	mov	sp, r7
 800200c:	bdb0      	pop	{r4, r5, r7, pc}
 800200e:	bf00      	nop
 8002010:	02020005 	.word	0x02020005
 8002014:	40020000 	.word	0x40020000
 8002018:	0800387c 	.word	0x0800387c
 800201c:	080036f4 	.word	0x080036f4
 8002020:	00030d40 	.word	0x00030d40
 8002024:	000186a0 	.word	0x000186a0

08002028 <lcdReset>:
#include "spi.h"

// Low-level LCD driving functions --------------------------------------------------------------------------

// Reset the LCD hardware
void lcdReset(void) {
 8002028:	b580      	push	{r7, lr}
 800202a:	af00      	add	r7, sp, #0
	// Reset pin is active low (0 = reset, 1 = ready)
	res_reset();
 800202c:	f001 f8dc 	bl	80031e8 <res_reset>
	Delay(1); ///////////////////////////////////
 8002030:	2001      	movs	r0, #1
 8002032:	f000 fec3 	bl	8002dbc <Delay>

	res_set();
 8002036:	f001 f8cb 	bl	80031d0 <res_set>
	Delay(1); //////////////////////////////
 800203a:	2001      	movs	r0, #1
 800203c:	f000 febe 	bl	8002dbc <Delay>
}
 8002040:	bf00      	nop
 8002042:	bd80      	pop	{r7, pc}

08002044 <lcdWriteCommand>:

void lcdWriteCommand(uint8_t address) {
 8002044:	b580      	push	{r7, lr}
 8002046:	b082      	sub	sp, #8
 8002048:	af00      	add	r7, sp, #0
 800204a:	4603      	mov	r3, r0
 800204c:	71fb      	strb	r3, [r7, #7]
	cd_reset();
 800204e:	f001 f895 	bl	800317c <cd_reset>

	readWriteSPI(address);
 8002052:	79fb      	ldrb	r3, [r7, #7]
 8002054:	4618      	mov	r0, r3
 8002056:	f001 f825 	bl	80030a4 <readWriteSPI>
}
 800205a:	bf00      	nop
 800205c:	3708      	adds	r7, #8
 800205e:	46bd      	mov	sp, r7
 8002060:	bd80      	pop	{r7, pc}
 8002062:	bf00      	nop

08002064 <lcdWriteParameter>:

void lcdWriteParameter(uint8_t parameter) {
 8002064:	b580      	push	{r7, lr}
 8002066:	b082      	sub	sp, #8
 8002068:	af00      	add	r7, sp, #0
 800206a:	4603      	mov	r3, r0
 800206c:	71fb      	strb	r3, [r7, #7]
	cd_set();
 800206e:	f001 f879 	bl	8003164 <cd_set>

	readWriteSPI(parameter);
 8002072:	79fb      	ldrb	r3, [r7, #7]
 8002074:	4618      	mov	r0, r3
 8002076:	f001 f815 	bl	80030a4 <readWriteSPI>
}
 800207a:	bf00      	nop
 800207c:	3708      	adds	r7, #8
 800207e:	46bd      	mov	sp, r7
 8002080:	bd80      	pop	{r7, pc}
 8002082:	bf00      	nop

08002084 <lcdWriteData>:

void lcdWriteData(uint8_t dataByte1, uint8_t dataByte2) {
 8002084:	b580      	push	{r7, lr}
 8002086:	b082      	sub	sp, #8
 8002088:	af00      	add	r7, sp, #0
 800208a:	4603      	mov	r3, r0
 800208c:	460a      	mov	r2, r1
 800208e:	71fb      	strb	r3, [r7, #7]
 8002090:	4613      	mov	r3, r2
 8002092:	71bb      	strb	r3, [r7, #6]
	cd_set();
 8002094:	f001 f866 	bl	8003164 <cd_set>

	readWriteSPI(dataByte1);
 8002098:	79fb      	ldrb	r3, [r7, #7]
 800209a:	4618      	mov	r0, r3
 800209c:	f001 f802 	bl	80030a4 <readWriteSPI>
	readWriteSPI(dataByte2);
 80020a0:	79bb      	ldrb	r3, [r7, #6]
 80020a2:	4618      	mov	r0, r3
 80020a4:	f000 fffe 	bl	80030a4 <readWriteSPI>
}
 80020a8:	bf00      	nop
 80020aa:	3708      	adds	r7, #8
 80020ac:	46bd      	mov	sp, r7
 80020ae:	bd80      	pop	{r7, pc}

080020b0 <lcdInitialise>:

// Initialise the display with the require screen orientation
void lcdInitialise(uint8_t orientation) {
 80020b0:	b580      	push	{r7, lr}
 80020b2:	b082      	sub	sp, #8
 80020b4:	af00      	add	r7, sp, #0
 80020b6:	4603      	mov	r3, r0
 80020b8:	71fb      	strb	r3, [r7, #7]
	// Set up the IO ports for communication with the LCD

	// Hardware reset the LCD
	lcdReset();
 80020ba:	f7ff ffb5 	bl	8002028 <lcdReset>

	lcdWriteCommand(EXIT_SLEEP_MODE);
 80020be:	2011      	movs	r0, #17
 80020c0:	f7ff ffc0 	bl	8002044 <lcdWriteCommand>
	Delay(1); // Wait for the screen to wake up
 80020c4:	2001      	movs	r0, #1
 80020c6:	f000 fe79 	bl	8002dbc <Delay>

	lcdWriteCommand(SET_PIXEL_FORMAT);
 80020ca:	203a      	movs	r0, #58	; 0x3a
 80020cc:	f7ff ffba 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x05); // 16 bits per pixel
 80020d0:	2005      	movs	r0, #5
 80020d2:	f7ff ffc7 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(SET_GAMMA_CURVE);
 80020d6:	2026      	movs	r0, #38	; 0x26
 80020d8:	f7ff ffb4 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x04); // Select gamma curve 3
 80020dc:	2004      	movs	r0, #4
 80020de:	f7ff ffc1 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(GAM_R_SEL);
 80020e2:	20f2      	movs	r0, #242	; 0xf2
 80020e4:	f7ff ffae 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x01); // Gamma adjustment enabled
 80020e8:	2001      	movs	r0, #1
 80020ea:	f7ff ffbb 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(POSITIVE_GAMMA_CORRECT);
 80020ee:	20e0      	movs	r0, #224	; 0xe0
 80020f0:	f7ff ffa8 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x3f); // 1st Parameter
 80020f4:	203f      	movs	r0, #63	; 0x3f
 80020f6:	f7ff ffb5 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x25); // 2nd Parameter
 80020fa:	2025      	movs	r0, #37	; 0x25
 80020fc:	f7ff ffb2 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x1c); // 3rd Parameter
 8002100:	201c      	movs	r0, #28
 8002102:	f7ff ffaf 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x1e); // 4th Parameter
 8002106:	201e      	movs	r0, #30
 8002108:	f7ff ffac 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x20); // 5th Parameter
 800210c:	2020      	movs	r0, #32
 800210e:	f7ff ffa9 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x12); // 6th Parameter
 8002112:	2012      	movs	r0, #18
 8002114:	f7ff ffa6 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x2a); // 7th Parameter
 8002118:	202a      	movs	r0, #42	; 0x2a
 800211a:	f7ff ffa3 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x90); // 8th Parameter
 800211e:	2090      	movs	r0, #144	; 0x90
 8002120:	f7ff ffa0 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x24); // 9th Parameter
 8002124:	2024      	movs	r0, #36	; 0x24
 8002126:	f7ff ff9d 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x11); // 10th Parameter
 800212a:	2011      	movs	r0, #17
 800212c:	f7ff ff9a 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00); // 11th Parameter
 8002130:	2000      	movs	r0, #0
 8002132:	f7ff ff97 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00); // 12th Parameter
 8002136:	2000      	movs	r0, #0
 8002138:	f7ff ff94 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00); // 13th Parameter
 800213c:	2000      	movs	r0, #0
 800213e:	f7ff ff91 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00); // 14th Parameter
 8002142:	2000      	movs	r0, #0
 8002144:	f7ff ff8e 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00); // 15th Parameter
 8002148:	2000      	movs	r0, #0
 800214a:	f7ff ff8b 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(NEGATIVE_GAMMA_CORRECT);
 800214e:	20e1      	movs	r0, #225	; 0xe1
 8002150:	f7ff ff78 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x20); // 1st Parameter
 8002154:	2020      	movs	r0, #32
 8002156:	f7ff ff85 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x20); // 2nd Parameter
 800215a:	2020      	movs	r0, #32
 800215c:	f7ff ff82 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x20); // 3rd Parameter
 8002160:	2020      	movs	r0, #32
 8002162:	f7ff ff7f 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x20); // 4th Parameter
 8002166:	2020      	movs	r0, #32
 8002168:	f7ff ff7c 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x05); // 5th Parameter
 800216c:	2005      	movs	r0, #5
 800216e:	f7ff ff79 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00); // 6th Parameter
 8002172:	2000      	movs	r0, #0
 8002174:	f7ff ff76 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x15); // 7th Parameter
 8002178:	2015      	movs	r0, #21
 800217a:	f7ff ff73 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0xa7); // 8th Parameter
 800217e:	20a7      	movs	r0, #167	; 0xa7
 8002180:	f7ff ff70 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x3d); // 9th Parameter
 8002184:	203d      	movs	r0, #61	; 0x3d
 8002186:	f7ff ff6d 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x18); // 10th Parameter
 800218a:	2018      	movs	r0, #24
 800218c:	f7ff ff6a 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x25); // 11th Parameter
 8002190:	2025      	movs	r0, #37	; 0x25
 8002192:	f7ff ff67 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x2a); // 12th Parameter
 8002196:	202a      	movs	r0, #42	; 0x2a
 8002198:	f7ff ff64 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x2b); // 13th Parameter
 800219c:	202b      	movs	r0, #43	; 0x2b
 800219e:	f7ff ff61 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x2b); // 14th Parameter
 80021a2:	202b      	movs	r0, #43	; 0x2b
 80021a4:	f7ff ff5e 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x3a); // 15th Parameter
 80021a8:	203a      	movs	r0, #58	; 0x3a
 80021aa:	f7ff ff5b 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(FRAME_RATE_CONTROL1);
 80021ae:	20b1      	movs	r0, #177	; 0xb1
 80021b0:	f7ff ff48 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x08); // DIVA = 8
 80021b4:	2008      	movs	r0, #8
 80021b6:	f7ff ff55 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x08); // VPA = 8
 80021ba:	2008      	movs	r0, #8
 80021bc:	f7ff ff52 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(DISPLAY_INVERSION);
 80021c0:	20b4      	movs	r0, #180	; 0xb4
 80021c2:	f7ff ff3f 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x07); // NLA = 1, NLB = 1, NLC = 1 (all on Frame Inversion)
 80021c6:	2007      	movs	r0, #7
 80021c8:	f7ff ff4c 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(POWER_CONTROL1);
 80021cc:	20c0      	movs	r0, #192	; 0xc0
 80021ce:	f7ff ff39 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x0a); // VRH = 10:  GVDD = 4.30
 80021d2:	200a      	movs	r0, #10
 80021d4:	f7ff ff46 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x02); // VC = 2: VCI1 = 2.65
 80021d8:	2002      	movs	r0, #2
 80021da:	f7ff ff43 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(POWER_CONTROL2);
 80021de:	20c1      	movs	r0, #193	; 0xc1
 80021e0:	f7ff ff30 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x02); // BT = 2: AVDD = 2xVCI1, VCL = -1xVCI1, VGH = 5xVCI1, VGL = -2xVCI1
 80021e4:	2002      	movs	r0, #2
 80021e6:	f7ff ff3d 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(VCOM_CONTROL1);
 80021ea:	20c5      	movs	r0, #197	; 0xc5
 80021ec:	f7ff ff2a 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x50); // VMH = 80: VCOMH voltage = 4.5
 80021f0:	2050      	movs	r0, #80	; 0x50
 80021f2:	f7ff ff37 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x5b); // VML = 91: VCOML voltage = -0.225
 80021f6:	205b      	movs	r0, #91	; 0x5b
 80021f8:	f7ff ff34 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(VCOM_OFFSET_CONTROL);
 80021fc:	20c7      	movs	r0, #199	; 0xc7
 80021fe:	f7ff ff21 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x40); // nVM = 0, VMF = 64: VCOMH output = VMH, VCOML output = VML
 8002202:	2040      	movs	r0, #64	; 0x40
 8002204:	f7ff ff2e 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(SET_COLUMN_ADDRESS);
 8002208:	202a      	movs	r0, #42	; 0x2a
 800220a:	f7ff ff1b 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00); // XSH
 800220e:	2000      	movs	r0, #0
 8002210:	f7ff ff28 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00); // XSL
 8002214:	2000      	movs	r0, #0
 8002216:	f7ff ff25 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00); // XEH
 800221a:	2000      	movs	r0, #0
 800221c:	f7ff ff22 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x7f); // XEL (128 pixels x)
 8002220:	207f      	movs	r0, #127	; 0x7f
 8002222:	f7ff ff1f 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(SET_PAGE_ADDRESS);
 8002226:	202b      	movs	r0, #43	; 0x2b
 8002228:	f7ff ff0c 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 800222c:	2000      	movs	r0, #0
 800222e:	f7ff ff19 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 8002232:	2000      	movs	r0, #0
 8002234:	f7ff ff16 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 8002238:	2000      	movs	r0, #0
 800223a:	f7ff ff13 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x7f); // 128 pixels y
 800223e:	207f      	movs	r0, #127	; 0x7f
 8002240:	f7ff ff10 	bl	8002064 <lcdWriteParameter>

	// Select display orientation
	lcdWriteCommand(SET_ADDRESS_MODE);
 8002244:	2036      	movs	r0, #54	; 0x36
 8002246:	f7ff fefd 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(orientation);
 800224a:	79fb      	ldrb	r3, [r7, #7]
 800224c:	4618      	mov	r0, r3
 800224e:	f7ff ff09 	bl	8002064 <lcdWriteParameter>

	// Set the display to on
	lcdWriteCommand(SET_DISPLAY_ON);
 8002252:	2029      	movs	r0, #41	; 0x29
 8002254:	f7ff fef6 	bl	8002044 <lcdWriteCommand>
	lcdWriteCommand(WRITE_MEMORY_START);
 8002258:	202c      	movs	r0, #44	; 0x2c
 800225a:	f7ff fef3 	bl	8002044 <lcdWriteCommand>
}
 800225e:	bf00      	nop
 8002260:	3708      	adds	r7, #8
 8002262:	46bd      	mov	sp, r7
 8002264:	bd80      	pop	{r7, pc}
 8002266:	bf00      	nop

08002268 <lcdClearDisplay>:

// LCD graphics functions -----------------------------------------------------------------------------------

void lcdClearDisplay(uint16_t colour) {
 8002268:	b580      	push	{r7, lr}
 800226a:	b084      	sub	sp, #16
 800226c:	af00      	add	r7, sp, #0
 800226e:	4603      	mov	r3, r0
 8002270:	80fb      	strh	r3, [r7, #6]
	uint16_t pixel;

	// Set the column address to 0-127
	lcdWriteCommand(SET_COLUMN_ADDRESS);
 8002272:	202a      	movs	r0, #42	; 0x2a
 8002274:	f7ff fee6 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 8002278:	2000      	movs	r0, #0
 800227a:	f7ff fef3 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 800227e:	2000      	movs	r0, #0
 8002280:	f7ff fef0 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 8002284:	2000      	movs	r0, #0
 8002286:	f7ff feed 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x7f);
 800228a:	207f      	movs	r0, #127	; 0x7f
 800228c:	f7ff feea 	bl	8002064 <lcdWriteParameter>

	// Set the page address to 0-127
	lcdWriteCommand(SET_PAGE_ADDRESS);
 8002290:	202b      	movs	r0, #43	; 0x2b
 8002292:	f7ff fed7 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 8002296:	2000      	movs	r0, #0
 8002298:	f7ff fee4 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 800229c:	2000      	movs	r0, #0
 800229e:	f7ff fee1 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 80022a2:	2000      	movs	r0, #0
 80022a4:	f7ff fede 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x7f);
 80022a8:	207f      	movs	r0, #127	; 0x7f
 80022aa:	f7ff fedb 	bl	8002064 <lcdWriteParameter>

	// Plot the pixels
	lcdWriteCommand(WRITE_MEMORY_START);
 80022ae:	202c      	movs	r0, #44	; 0x2c
 80022b0:	f7ff fec8 	bl	8002044 <lcdWriteCommand>
	for (pixel = 0; pixel < 16385; pixel++)
 80022b4:	2300      	movs	r3, #0
 80022b6:	81fb      	strh	r3, [r7, #14]
 80022b8:	e00c      	b.n	80022d4 <lcdClearDisplay+0x6c>
		lcdWriteData(colour >> 8, colour);
 80022ba:	88fb      	ldrh	r3, [r7, #6]
 80022bc:	0a1b      	lsrs	r3, r3, #8
 80022be:	b29b      	uxth	r3, r3
 80022c0:	b2db      	uxtb	r3, r3
 80022c2:	88fa      	ldrh	r2, [r7, #6]
 80022c4:	b2d2      	uxtb	r2, r2
 80022c6:	4611      	mov	r1, r2
 80022c8:	4618      	mov	r0, r3
 80022ca:	f7ff fedb 	bl	8002084 <lcdWriteData>
	lcdWriteParameter(0x00);
	lcdWriteParameter(0x7f);

	// Plot the pixels
	lcdWriteCommand(WRITE_MEMORY_START);
	for (pixel = 0; pixel < 16385; pixel++)
 80022ce:	89fb      	ldrh	r3, [r7, #14]
 80022d0:	3301      	adds	r3, #1
 80022d2:	81fb      	strh	r3, [r7, #14]
 80022d4:	89fb      	ldrh	r3, [r7, #14]
 80022d6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80022da:	d9ee      	bls.n	80022ba <lcdClearDisplay+0x52>
		lcdWriteData(colour >> 8, colour);
}
 80022dc:	bf00      	nop
 80022de:	3710      	adds	r7, #16
 80022e0:	46bd      	mov	sp, r7
 80022e2:	bd80      	pop	{r7, pc}

080022e4 <lcdPlot>:

void lcdPlot(uint8_t x, uint8_t y, uint16_t colour) {
 80022e4:	b580      	push	{r7, lr}
 80022e6:	b082      	sub	sp, #8
 80022e8:	af00      	add	r7, sp, #0
 80022ea:	4603      	mov	r3, r0
 80022ec:	71fb      	strb	r3, [r7, #7]
 80022ee:	460b      	mov	r3, r1
 80022f0:	71bb      	strb	r3, [r7, #6]
 80022f2:	4613      	mov	r3, r2
 80022f4:	80bb      	strh	r3, [r7, #4]
	// Horizontal Address Start Position
	lcdWriteCommand(SET_COLUMN_ADDRESS);
 80022f6:	202a      	movs	r0, #42	; 0x2a
 80022f8:	f7ff fea4 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 80022fc:	2000      	movs	r0, #0
 80022fe:	f7ff feb1 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(x);
 8002302:	79fb      	ldrb	r3, [r7, #7]
 8002304:	4618      	mov	r0, r3
 8002306:	f7ff fead 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 800230a:	2000      	movs	r0, #0
 800230c:	f7ff feaa 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x7f);
 8002310:	207f      	movs	r0, #127	; 0x7f
 8002312:	f7ff fea7 	bl	8002064 <lcdWriteParameter>

	// Vertical Address end Position
	lcdWriteCommand(SET_PAGE_ADDRESS);
 8002316:	202b      	movs	r0, #43	; 0x2b
 8002318:	f7ff fe94 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 800231c:	2000      	movs	r0, #0
 800231e:	f7ff fea1 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(y);
 8002322:	79bb      	ldrb	r3, [r7, #6]
 8002324:	4618      	mov	r0, r3
 8002326:	f7ff fe9d 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 800232a:	2000      	movs	r0, #0
 800232c:	f7ff fe9a 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x7f); //7f
 8002330:	207f      	movs	r0, #127	; 0x7f
 8002332:	f7ff fe97 	bl	8002064 <lcdWriteParameter>

	// Plot the point
	lcdWriteCommand(WRITE_MEMORY_START);
 8002336:	202c      	movs	r0, #44	; 0x2c
 8002338:	f7ff fe84 	bl	8002044 <lcdWriteCommand>
	lcdWriteData(colour >> 8, colour);
 800233c:	88bb      	ldrh	r3, [r7, #4]
 800233e:	0a1b      	lsrs	r3, r3, #8
 8002340:	b29b      	uxth	r3, r3
 8002342:	b2db      	uxtb	r3, r3
 8002344:	88ba      	ldrh	r2, [r7, #4]
 8002346:	b2d2      	uxtb	r2, r2
 8002348:	4611      	mov	r1, r2
 800234a:	4618      	mov	r0, r3
 800234c:	f7ff fe9a 	bl	8002084 <lcdWriteData>
}
 8002350:	bf00      	nop
 8002352:	3708      	adds	r7, #8
 8002354:	46bd      	mov	sp, r7
 8002356:	bd80      	pop	{r7, pc}

08002358 <lcdLine>:

// Draw a line from x0, y0 to x1, y1
// Note:	This is a version of Bresenham's line drawing algorithm
//			It only draws lines from left to right!
void lcdLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t colour) {
 8002358:	b590      	push	{r4, r7, lr}
 800235a:	b087      	sub	sp, #28
 800235c:	af00      	add	r7, sp, #0
 800235e:	4604      	mov	r4, r0
 8002360:	4608      	mov	r0, r1
 8002362:	4611      	mov	r1, r2
 8002364:	461a      	mov	r2, r3
 8002366:	4623      	mov	r3, r4
 8002368:	80fb      	strh	r3, [r7, #6]
 800236a:	4603      	mov	r3, r0
 800236c:	80bb      	strh	r3, [r7, #4]
 800236e:	460b      	mov	r3, r1
 8002370:	807b      	strh	r3, [r7, #2]
 8002372:	4613      	mov	r3, r2
 8002374:	803b      	strh	r3, [r7, #0]
	int16_t dy = y1 - y0;
 8002376:	883a      	ldrh	r2, [r7, #0]
 8002378:	88bb      	ldrh	r3, [r7, #4]
 800237a:	1ad3      	subs	r3, r2, r3
 800237c:	b29b      	uxth	r3, r3
 800237e:	82fb      	strh	r3, [r7, #22]
	int16_t dx = x1 - x0;
 8002380:	887a      	ldrh	r2, [r7, #2]
 8002382:	88fb      	ldrh	r3, [r7, #6]
 8002384:	1ad3      	subs	r3, r2, r3
 8002386:	b29b      	uxth	r3, r3
 8002388:	82bb      	strh	r3, [r7, #20]
	int16_t stepx, stepy;

	if (dy < 0) {
 800238a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800238e:	2b00      	cmp	r3, #0
 8002390:	da07      	bge.n	80023a2 <lcdLine+0x4a>
		dy = -dy;
 8002392:	8afb      	ldrh	r3, [r7, #22]
 8002394:	425b      	negs	r3, r3
 8002396:	b29b      	uxth	r3, r3
 8002398:	82fb      	strh	r3, [r7, #22]
		stepy = -1;
 800239a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800239e:	823b      	strh	r3, [r7, #16]
 80023a0:	e001      	b.n	80023a6 <lcdLine+0x4e>
	} else
		stepy = 1;
 80023a2:	2301      	movs	r3, #1
 80023a4:	823b      	strh	r3, [r7, #16]

	if (dx < 0) {
 80023a6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80023aa:	2b00      	cmp	r3, #0
 80023ac:	da07      	bge.n	80023be <lcdLine+0x66>
		dx = -dx;
 80023ae:	8abb      	ldrh	r3, [r7, #20]
 80023b0:	425b      	negs	r3, r3
 80023b2:	b29b      	uxth	r3, r3
 80023b4:	82bb      	strh	r3, [r7, #20]
		stepx = -1;
 80023b6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80023ba:	827b      	strh	r3, [r7, #18]
 80023bc:	e001      	b.n	80023c2 <lcdLine+0x6a>
	} else
		stepx = 1;
 80023be:	2301      	movs	r3, #1
 80023c0:	827b      	strh	r3, [r7, #18]

	dy <<= 1; 							// dy is now 2*dy
 80023c2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80023c6:	005b      	lsls	r3, r3, #1
 80023c8:	82fb      	strh	r3, [r7, #22]
	dx <<= 1; 							// dx is now 2*dx
 80023ca:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80023ce:	005b      	lsls	r3, r3, #1
 80023d0:	82bb      	strh	r3, [r7, #20]

	lcdPlot(x0, y0, colour);
 80023d2:	88fb      	ldrh	r3, [r7, #6]
 80023d4:	b2db      	uxtb	r3, r3
 80023d6:	88ba      	ldrh	r2, [r7, #4]
 80023d8:	b2d1      	uxtb	r1, r2
 80023da:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 80023dc:	4618      	mov	r0, r3
 80023de:	f7ff ff81 	bl	80022e4 <lcdPlot>

	if (dx > dy) {
 80023e2:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 80023e6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80023ea:	429a      	cmp	r2, r3
 80023ec:	dd2e      	ble.n	800244c <lcdLine+0xf4>
		int fraction = dy - (dx >> 1);	// same as 2*dy - dx
 80023ee:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80023f2:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 80023f6:	1052      	asrs	r2, r2, #1
 80023f8:	b212      	sxth	r2, r2
 80023fa:	1a9b      	subs	r3, r3, r2
 80023fc:	60fb      	str	r3, [r7, #12]
		while (x0 != x1) {
 80023fe:	e01e      	b.n	800243e <lcdLine+0xe6>
			if (fraction >= 0) {
 8002400:	68fb      	ldr	r3, [r7, #12]
 8002402:	2b00      	cmp	r3, #0
 8002404:	db09      	blt.n	800241a <lcdLine+0xc2>
				y0 += stepy;
 8002406:	88ba      	ldrh	r2, [r7, #4]
 8002408:	8a3b      	ldrh	r3, [r7, #16]
 800240a:	4413      	add	r3, r2
 800240c:	b29b      	uxth	r3, r3
 800240e:	80bb      	strh	r3, [r7, #4]
				fraction -= dx; 		// same as fraction -= 2*dx
 8002410:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8002414:	68fa      	ldr	r2, [r7, #12]
 8002416:	1ad3      	subs	r3, r2, r3
 8002418:	60fb      	str	r3, [r7, #12]
			}

			x0 += stepx;
 800241a:	88fa      	ldrh	r2, [r7, #6]
 800241c:	8a7b      	ldrh	r3, [r7, #18]
 800241e:	4413      	add	r3, r2
 8002420:	b29b      	uxth	r3, r3
 8002422:	80fb      	strh	r3, [r7, #6]
			fraction += dy; 				// same as fraction -= 2*dy
 8002424:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8002428:	68fa      	ldr	r2, [r7, #12]
 800242a:	4413      	add	r3, r2
 800242c:	60fb      	str	r3, [r7, #12]
			lcdPlot(x0, y0, colour);
 800242e:	88fb      	ldrh	r3, [r7, #6]
 8002430:	b2db      	uxtb	r3, r3
 8002432:	88ba      	ldrh	r2, [r7, #4]
 8002434:	b2d1      	uxtb	r1, r2
 8002436:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8002438:	4618      	mov	r0, r3
 800243a:	f7ff ff53 	bl	80022e4 <lcdPlot>

	lcdPlot(x0, y0, colour);

	if (dx > dy) {
		int fraction = dy - (dx >> 1);	// same as 2*dy - dx
		while (x0 != x1) {
 800243e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8002442:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8002446:	429a      	cmp	r2, r3
 8002448:	d1da      	bne.n	8002400 <lcdLine+0xa8>
			y0 += stepy;
			fraction += dx;
			lcdPlot(x0, y0, colour);
		}
	}
}
 800244a:	e02d      	b.n	80024a8 <lcdLine+0x150>
			x0 += stepx;
			fraction += dy; 				// same as fraction -= 2*dy
			lcdPlot(x0, y0, colour);
		}
	} else {
		int fraction = dx - (dy >> 1);
 800244c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8002450:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8002454:	1052      	asrs	r2, r2, #1
 8002456:	b212      	sxth	r2, r2
 8002458:	1a9b      	subs	r3, r3, r2
 800245a:	60bb      	str	r3, [r7, #8]
		while (y0 != y1) {
 800245c:	e01e      	b.n	800249c <lcdLine+0x144>
			if (fraction >= 0) {
 800245e:	68bb      	ldr	r3, [r7, #8]
 8002460:	2b00      	cmp	r3, #0
 8002462:	db09      	blt.n	8002478 <lcdLine+0x120>
				x0 += stepx;
 8002464:	88fa      	ldrh	r2, [r7, #6]
 8002466:	8a7b      	ldrh	r3, [r7, #18]
 8002468:	4413      	add	r3, r2
 800246a:	b29b      	uxth	r3, r3
 800246c:	80fb      	strh	r3, [r7, #6]
				fraction -= dy;
 800246e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8002472:	68ba      	ldr	r2, [r7, #8]
 8002474:	1ad3      	subs	r3, r2, r3
 8002476:	60bb      	str	r3, [r7, #8]
			}

			y0 += stepy;
 8002478:	88ba      	ldrh	r2, [r7, #4]
 800247a:	8a3b      	ldrh	r3, [r7, #16]
 800247c:	4413      	add	r3, r2
 800247e:	b29b      	uxth	r3, r3
 8002480:	80bb      	strh	r3, [r7, #4]
			fraction += dx;
 8002482:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8002486:	68ba      	ldr	r2, [r7, #8]
 8002488:	4413      	add	r3, r2
 800248a:	60bb      	str	r3, [r7, #8]
			lcdPlot(x0, y0, colour);
 800248c:	88fb      	ldrh	r3, [r7, #6]
 800248e:	b2db      	uxtb	r3, r3
 8002490:	88ba      	ldrh	r2, [r7, #4]
 8002492:	b2d1      	uxtb	r1, r2
 8002494:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8002496:	4618      	mov	r0, r3
 8002498:	f7ff ff24 	bl	80022e4 <lcdPlot>
			fraction += dy; 				// same as fraction -= 2*dy
			lcdPlot(x0, y0, colour);
		}
	} else {
		int fraction = dx - (dy >> 1);
		while (y0 != y1) {
 800249c:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 80024a0:	f9b7 3000 	ldrsh.w	r3, [r7]
 80024a4:	429a      	cmp	r2, r3
 80024a6:	d1da      	bne.n	800245e <lcdLine+0x106>
			y0 += stepy;
			fraction += dx;
			lcdPlot(x0, y0, colour);
		}
	}
}
 80024a8:	bf00      	nop
 80024aa:	371c      	adds	r7, #28
 80024ac:	46bd      	mov	sp, r7
 80024ae:	bd90      	pop	{r4, r7, pc}

080024b0 <lcdRectangle>:

// Draw a rectangle between x0, y0 and x1, y1
void lcdRectangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
		uint16_t colour) {
 80024b0:	b590      	push	{r4, r7, lr}
 80024b2:	b085      	sub	sp, #20
 80024b4:	af02      	add	r7, sp, #8
 80024b6:	4604      	mov	r4, r0
 80024b8:	4608      	mov	r0, r1
 80024ba:	4611      	mov	r1, r2
 80024bc:	461a      	mov	r2, r3
 80024be:	4623      	mov	r3, r4
 80024c0:	80fb      	strh	r3, [r7, #6]
 80024c2:	4603      	mov	r3, r0
 80024c4:	80bb      	strh	r3, [r7, #4]
 80024c6:	460b      	mov	r3, r1
 80024c8:	807b      	strh	r3, [r7, #2]
 80024ca:	4613      	mov	r3, r2
 80024cc:	803b      	strh	r3, [r7, #0]
	lcdLine(x0, y0, x0, y1, colour);
 80024ce:	f9b7 4000 	ldrsh.w	r4, [r7]
 80024d2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 80024d6:	f9b7 1004 	ldrsh.w	r1, [r7, #4]
 80024da:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
 80024de:	8b3b      	ldrh	r3, [r7, #24]
 80024e0:	9300      	str	r3, [sp, #0]
 80024e2:	4623      	mov	r3, r4
 80024e4:	f7ff ff38 	bl	8002358 <lcdLine>
	lcdLine(x0, y1, x1, y1, colour);
 80024e8:	f9b7 4000 	ldrsh.w	r4, [r7]
 80024ec:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 80024f0:	f9b7 1000 	ldrsh.w	r1, [r7]
 80024f4:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
 80024f8:	8b3b      	ldrh	r3, [r7, #24]
 80024fa:	9300      	str	r3, [sp, #0]
 80024fc:	4623      	mov	r3, r4
 80024fe:	f7ff ff2b 	bl	8002358 <lcdLine>
	lcdLine(x1, y0, x1, y1, colour);
 8002502:	f9b7 4000 	ldrsh.w	r4, [r7]
 8002506:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 800250a:	f9b7 1004 	ldrsh.w	r1, [r7, #4]
 800250e:	f9b7 0002 	ldrsh.w	r0, [r7, #2]
 8002512:	8b3b      	ldrh	r3, [r7, #24]
 8002514:	9300      	str	r3, [sp, #0]
 8002516:	4623      	mov	r3, r4
 8002518:	f7ff ff1e 	bl	8002358 <lcdLine>
	lcdLine(x0, y0, x1, y0, colour);
 800251c:	f9b7 4004 	ldrsh.w	r4, [r7, #4]
 8002520:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 8002524:	f9b7 1004 	ldrsh.w	r1, [r7, #4]
 8002528:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
 800252c:	8b3b      	ldrh	r3, [r7, #24]
 800252e:	9300      	str	r3, [sp, #0]
 8002530:	4623      	mov	r3, r4
 8002532:	f7ff ff11 	bl	8002358 <lcdLine>
}
 8002536:	bf00      	nop
 8002538:	370c      	adds	r7, #12
 800253a:	46bd      	mov	sp, r7
 800253c:	bd90      	pop	{r4, r7, pc}
 800253e:	bf00      	nop

08002540 <lcdFilledRectangle>:

// Draw a filled rectangle
// Note:	y1 must be greater than y0  and x1 must be greater than x0
//			for this to work
void lcdFilledRectangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
		uint16_t colour) {
 8002540:	b590      	push	{r4, r7, lr}
 8002542:	b085      	sub	sp, #20
 8002544:	af00      	add	r7, sp, #0
 8002546:	4604      	mov	r4, r0
 8002548:	4608      	mov	r0, r1
 800254a:	4611      	mov	r1, r2
 800254c:	461a      	mov	r2, r3
 800254e:	4623      	mov	r3, r4
 8002550:	80fb      	strh	r3, [r7, #6]
 8002552:	4603      	mov	r3, r0
 8002554:	80bb      	strh	r3, [r7, #4]
 8002556:	460b      	mov	r3, r1
 8002558:	807b      	strh	r3, [r7, #2]
 800255a:	4613      	mov	r3, r2
 800255c:	803b      	strh	r3, [r7, #0]

	// To speed up plotting we define a x window with the width of the
	// rectangle and then just output the required number of bytes to
	// fill down to the end point

	lcdWriteCommand(SET_COLUMN_ADDRESS); // Horizontal Address Start Position
 800255e:	202a      	movs	r0, #42	; 0x2a
 8002560:	f7ff fd70 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 8002564:	2000      	movs	r0, #0
 8002566:	f7ff fd7d 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(x0);
 800256a:	88fb      	ldrh	r3, [r7, #6]
 800256c:	b2db      	uxtb	r3, r3
 800256e:	4618      	mov	r0, r3
 8002570:	f7ff fd78 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 8002574:	2000      	movs	r0, #0
 8002576:	f7ff fd75 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(x1);
 800257a:	887b      	ldrh	r3, [r7, #2]
 800257c:	b2db      	uxtb	r3, r3
 800257e:	4618      	mov	r0, r3
 8002580:	f7ff fd70 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(SET_PAGE_ADDRESS); // Vertical Address end Position
 8002584:	202b      	movs	r0, #43	; 0x2b
 8002586:	f7ff fd5d 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 800258a:	2000      	movs	r0, #0
 800258c:	f7ff fd6a 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(y0);
 8002590:	88bb      	ldrh	r3, [r7, #4]
 8002592:	b2db      	uxtb	r3, r3
 8002594:	4618      	mov	r0, r3
 8002596:	f7ff fd65 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 800259a:	2000      	movs	r0, #0
 800259c:	f7ff fd62 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(y1);
 80025a0:	883b      	ldrh	r3, [r7, #0]
 80025a2:	b2db      	uxtb	r3, r3
 80025a4:	4618      	mov	r0, r3
 80025a6:	f7ff fd5d 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(WRITE_MEMORY_START);
 80025aa:	202c      	movs	r0, #44	; 0x2c
 80025ac:	f7ff fd4a 	bl	8002044 <lcdWriteCommand>

	for (pixels = 0; pixels < ((x1 - x0) * (y1 - y0)); pixels++)
 80025b0:	2300      	movs	r3, #0
 80025b2:	81fb      	strh	r3, [r7, #14]
 80025b4:	e00c      	b.n	80025d0 <lcdFilledRectangle+0x90>
		lcdWriteData(colour >> 8, colour);
 80025b6:	8c3b      	ldrh	r3, [r7, #32]
 80025b8:	0a1b      	lsrs	r3, r3, #8
 80025ba:	b29b      	uxth	r3, r3
 80025bc:	b2db      	uxtb	r3, r3
 80025be:	8c3a      	ldrh	r2, [r7, #32]
 80025c0:	b2d2      	uxtb	r2, r2
 80025c2:	4611      	mov	r1, r2
 80025c4:	4618      	mov	r0, r3
 80025c6:	f7ff fd5d 	bl	8002084 <lcdWriteData>
	lcdWriteParameter(0x00);
	lcdWriteParameter(y1);

	lcdWriteCommand(WRITE_MEMORY_START);

	for (pixels = 0; pixels < ((x1 - x0) * (y1 - y0)); pixels++)
 80025ca:	89fb      	ldrh	r3, [r7, #14]
 80025cc:	3301      	adds	r3, #1
 80025ce:	81fb      	strh	r3, [r7, #14]
 80025d0:	89fa      	ldrh	r2, [r7, #14]
 80025d2:	f9b7 1002 	ldrsh.w	r1, [r7, #2]
 80025d6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80025da:	1acb      	subs	r3, r1, r3
 80025dc:	f9b7 0000 	ldrsh.w	r0, [r7]
 80025e0:	f9b7 1004 	ldrsh.w	r1, [r7, #4]
 80025e4:	1a41      	subs	r1, r0, r1
 80025e6:	fb01 f303 	mul.w	r3, r1, r3
 80025ea:	429a      	cmp	r2, r3
 80025ec:	dbe3      	blt.n	80025b6 <lcdFilledRectangle+0x76>
		lcdWriteData(colour >> 8, colour);
	;
}
 80025ee:	bf00      	nop
 80025f0:	3714      	adds	r7, #20
 80025f2:	46bd      	mov	sp, r7
 80025f4:	bd90      	pop	{r4, r7, pc}
 80025f6:	bf00      	nop

080025f8 <lcdCircle>:
// Draw a circle
// Note:	This is another version of Bresenham's line drawing algorithm.
//			There's plenty of documentation on the web if you are curious
//			how this works.
void lcdCircle(int16_t xCentre, int16_t yCentre, int16_t radius,
		uint16_t colour) {
 80025f8:	b590      	push	{r4, r7, lr}
 80025fa:	b085      	sub	sp, #20
 80025fc:	af00      	add	r7, sp, #0
 80025fe:	4604      	mov	r4, r0
 8002600:	4608      	mov	r0, r1
 8002602:	4611      	mov	r1, r2
 8002604:	461a      	mov	r2, r3
 8002606:	4623      	mov	r3, r4
 8002608:	80fb      	strh	r3, [r7, #6]
 800260a:	4603      	mov	r3, r0
 800260c:	80bb      	strh	r3, [r7, #4]
 800260e:	460b      	mov	r3, r1
 8002610:	807b      	strh	r3, [r7, #2]
 8002612:	4613      	mov	r3, r2
 8002614:	803b      	strh	r3, [r7, #0]
	int16_t x = 0, y = radius;
 8002616:	2300      	movs	r3, #0
 8002618:	81fb      	strh	r3, [r7, #14]
 800261a:	887b      	ldrh	r3, [r7, #2]
 800261c:	81bb      	strh	r3, [r7, #12]
	int16_t d = 3 - (2 * radius);
 800261e:	887b      	ldrh	r3, [r7, #2]
 8002620:	005b      	lsls	r3, r3, #1
 8002622:	b29b      	uxth	r3, r3
 8002624:	f1c3 0303 	rsb	r3, r3, #3
 8002628:	b29b      	uxth	r3, r3
 800262a:	817b      	strh	r3, [r7, #10]

	while (x <= y) {
 800262c:	e0a5      	b.n	800277a <lcdCircle+0x182>
		lcdPlot(xCentre + x, yCentre + y, colour);
 800262e:	88fb      	ldrh	r3, [r7, #6]
 8002630:	b2da      	uxtb	r2, r3
 8002632:	89fb      	ldrh	r3, [r7, #14]
 8002634:	b2db      	uxtb	r3, r3
 8002636:	4413      	add	r3, r2
 8002638:	b2d8      	uxtb	r0, r3
 800263a:	88bb      	ldrh	r3, [r7, #4]
 800263c:	b2da      	uxtb	r2, r3
 800263e:	89bb      	ldrh	r3, [r7, #12]
 8002640:	b2db      	uxtb	r3, r3
 8002642:	4413      	add	r3, r2
 8002644:	b2db      	uxtb	r3, r3
 8002646:	883a      	ldrh	r2, [r7, #0]
 8002648:	4619      	mov	r1, r3
 800264a:	f7ff fe4b 	bl	80022e4 <lcdPlot>
		lcdPlot(xCentre + y, yCentre + x, colour);
 800264e:	88fb      	ldrh	r3, [r7, #6]
 8002650:	b2da      	uxtb	r2, r3
 8002652:	89bb      	ldrh	r3, [r7, #12]
 8002654:	b2db      	uxtb	r3, r3
 8002656:	4413      	add	r3, r2
 8002658:	b2d8      	uxtb	r0, r3
 800265a:	88bb      	ldrh	r3, [r7, #4]
 800265c:	b2da      	uxtb	r2, r3
 800265e:	89fb      	ldrh	r3, [r7, #14]
 8002660:	b2db      	uxtb	r3, r3
 8002662:	4413      	add	r3, r2
 8002664:	b2db      	uxtb	r3, r3
 8002666:	883a      	ldrh	r2, [r7, #0]
 8002668:	4619      	mov	r1, r3
 800266a:	f7ff fe3b 	bl	80022e4 <lcdPlot>
		lcdPlot(xCentre - x, yCentre + y, colour);
 800266e:	88fb      	ldrh	r3, [r7, #6]
 8002670:	b2da      	uxtb	r2, r3
 8002672:	89fb      	ldrh	r3, [r7, #14]
 8002674:	b2db      	uxtb	r3, r3
 8002676:	1ad3      	subs	r3, r2, r3
 8002678:	b2d8      	uxtb	r0, r3
 800267a:	88bb      	ldrh	r3, [r7, #4]
 800267c:	b2da      	uxtb	r2, r3
 800267e:	89bb      	ldrh	r3, [r7, #12]
 8002680:	b2db      	uxtb	r3, r3
 8002682:	4413      	add	r3, r2
 8002684:	b2db      	uxtb	r3, r3
 8002686:	883a      	ldrh	r2, [r7, #0]
 8002688:	4619      	mov	r1, r3
 800268a:	f7ff fe2b 	bl	80022e4 <lcdPlot>
		lcdPlot(xCentre + y, yCentre - x, colour);
 800268e:	88fb      	ldrh	r3, [r7, #6]
 8002690:	b2da      	uxtb	r2, r3
 8002692:	89bb      	ldrh	r3, [r7, #12]
 8002694:	b2db      	uxtb	r3, r3
 8002696:	4413      	add	r3, r2
 8002698:	b2d8      	uxtb	r0, r3
 800269a:	88bb      	ldrh	r3, [r7, #4]
 800269c:	b2da      	uxtb	r2, r3
 800269e:	89fb      	ldrh	r3, [r7, #14]
 80026a0:	b2db      	uxtb	r3, r3
 80026a2:	1ad3      	subs	r3, r2, r3
 80026a4:	b2db      	uxtb	r3, r3
 80026a6:	883a      	ldrh	r2, [r7, #0]
 80026a8:	4619      	mov	r1, r3
 80026aa:	f7ff fe1b 	bl	80022e4 <lcdPlot>
		lcdPlot(xCentre - x, yCentre - y, colour);
 80026ae:	88fb      	ldrh	r3, [r7, #6]
 80026b0:	b2da      	uxtb	r2, r3
 80026b2:	89fb      	ldrh	r3, [r7, #14]
 80026b4:	b2db      	uxtb	r3, r3
 80026b6:	1ad3      	subs	r3, r2, r3
 80026b8:	b2d8      	uxtb	r0, r3
 80026ba:	88bb      	ldrh	r3, [r7, #4]
 80026bc:	b2da      	uxtb	r2, r3
 80026be:	89bb      	ldrh	r3, [r7, #12]
 80026c0:	b2db      	uxtb	r3, r3
 80026c2:	1ad3      	subs	r3, r2, r3
 80026c4:	b2db      	uxtb	r3, r3
 80026c6:	883a      	ldrh	r2, [r7, #0]
 80026c8:	4619      	mov	r1, r3
 80026ca:	f7ff fe0b 	bl	80022e4 <lcdPlot>
		lcdPlot(xCentre - y, yCentre - x, colour);
 80026ce:	88fb      	ldrh	r3, [r7, #6]
 80026d0:	b2da      	uxtb	r2, r3
 80026d2:	89bb      	ldrh	r3, [r7, #12]
 80026d4:	b2db      	uxtb	r3, r3
 80026d6:	1ad3      	subs	r3, r2, r3
 80026d8:	b2d8      	uxtb	r0, r3
 80026da:	88bb      	ldrh	r3, [r7, #4]
 80026dc:	b2da      	uxtb	r2, r3
 80026de:	89fb      	ldrh	r3, [r7, #14]
 80026e0:	b2db      	uxtb	r3, r3
 80026e2:	1ad3      	subs	r3, r2, r3
 80026e4:	b2db      	uxtb	r3, r3
 80026e6:	883a      	ldrh	r2, [r7, #0]
 80026e8:	4619      	mov	r1, r3
 80026ea:	f7ff fdfb 	bl	80022e4 <lcdPlot>
		lcdPlot(xCentre + x, yCentre - y, colour);
 80026ee:	88fb      	ldrh	r3, [r7, #6]
 80026f0:	b2da      	uxtb	r2, r3
 80026f2:	89fb      	ldrh	r3, [r7, #14]
 80026f4:	b2db      	uxtb	r3, r3
 80026f6:	4413      	add	r3, r2
 80026f8:	b2d8      	uxtb	r0, r3
 80026fa:	88bb      	ldrh	r3, [r7, #4]
 80026fc:	b2da      	uxtb	r2, r3
 80026fe:	89bb      	ldrh	r3, [r7, #12]
 8002700:	b2db      	uxtb	r3, r3
 8002702:	1ad3      	subs	r3, r2, r3
 8002704:	b2db      	uxtb	r3, r3
 8002706:	883a      	ldrh	r2, [r7, #0]
 8002708:	4619      	mov	r1, r3
 800270a:	f7ff fdeb 	bl	80022e4 <lcdPlot>
		lcdPlot(xCentre - y, yCentre + x, colour);
 800270e:	88fb      	ldrh	r3, [r7, #6]
 8002710:	b2da      	uxtb	r2, r3
 8002712:	89bb      	ldrh	r3, [r7, #12]
 8002714:	b2db      	uxtb	r3, r3
 8002716:	1ad3      	subs	r3, r2, r3
 8002718:	b2d8      	uxtb	r0, r3
 800271a:	88bb      	ldrh	r3, [r7, #4]
 800271c:	b2da      	uxtb	r2, r3
 800271e:	89fb      	ldrh	r3, [r7, #14]
 8002720:	b2db      	uxtb	r3, r3
 8002722:	4413      	add	r3, r2
 8002724:	b2db      	uxtb	r3, r3
 8002726:	883a      	ldrh	r2, [r7, #0]
 8002728:	4619      	mov	r1, r3
 800272a:	f7ff fddb 	bl	80022e4 <lcdPlot>

		if (d < 0)
 800272e:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8002732:	2b00      	cmp	r3, #0
 8002734:	da09      	bge.n	800274a <lcdCircle+0x152>
			d += (4 * x) + 6;
 8002736:	89fb      	ldrh	r3, [r7, #14]
 8002738:	009b      	lsls	r3, r3, #2
 800273a:	b29a      	uxth	r2, r3
 800273c:	897b      	ldrh	r3, [r7, #10]
 800273e:	4413      	add	r3, r2
 8002740:	b29b      	uxth	r3, r3
 8002742:	3306      	adds	r3, #6
 8002744:	b29b      	uxth	r3, r3
 8002746:	817b      	strh	r3, [r7, #10]
 8002748:	e011      	b.n	800276e <lcdCircle+0x176>
		else {
			d += (4 * (x - y)) + 10;
 800274a:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 800274e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8002752:	1ad3      	subs	r3, r2, r3
 8002754:	b29b      	uxth	r3, r3
 8002756:	009b      	lsls	r3, r3, #2
 8002758:	b29a      	uxth	r2, r3
 800275a:	897b      	ldrh	r3, [r7, #10]
 800275c:	4413      	add	r3, r2
 800275e:	b29b      	uxth	r3, r3
 8002760:	330a      	adds	r3, #10
 8002762:	b29b      	uxth	r3, r3
 8002764:	817b      	strh	r3, [r7, #10]
			y -= 1;
 8002766:	89bb      	ldrh	r3, [r7, #12]
 8002768:	3b01      	subs	r3, #1
 800276a:	b29b      	uxth	r3, r3
 800276c:	81bb      	strh	r3, [r7, #12]
		}

		x++;
 800276e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8002772:	b29b      	uxth	r3, r3
 8002774:	3301      	adds	r3, #1
 8002776:	b29b      	uxth	r3, r3
 8002778:	81fb      	strh	r3, [r7, #14]
void lcdCircle(int16_t xCentre, int16_t yCentre, int16_t radius,
		uint16_t colour) {
	int16_t x = 0, y = radius;
	int16_t d = 3 - (2 * radius);

	while (x <= y) {
 800277a:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 800277e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8002782:	429a      	cmp	r2, r3
 8002784:	f77f af53 	ble.w	800262e <lcdCircle+0x36>
			y -= 1;
		}

		x++;
	}
}
 8002788:	bf00      	nop
 800278a:	3714      	adds	r7, #20
 800278c:	46bd      	mov	sp, r7
 800278e:	bd90      	pop	{r4, r7, pc}

08002790 <lcdPutCh>:

// LCD text manipulation functions --------------------------------------------------------------------------
#define pgm_read_byte_near(address_short) (uint16_t)(address_short)
// Plot a character at the specified x, y co-ordinates (top left hand corner of character)
void lcdPutCh(unsigned char character, uint8_t x, uint8_t y, uint16_t fgColour,
		uint16_t bgColour) {
 8002790:	b590      	push	{r4, r7, lr}
 8002792:	b085      	sub	sp, #20
 8002794:	af00      	add	r7, sp, #0
 8002796:	4604      	mov	r4, r0
 8002798:	4608      	mov	r0, r1
 800279a:	4611      	mov	r1, r2
 800279c:	461a      	mov	r2, r3
 800279e:	4623      	mov	r3, r4
 80027a0:	71fb      	strb	r3, [r7, #7]
 80027a2:	4603      	mov	r3, r0
 80027a4:	71bb      	strb	r3, [r7, #6]
 80027a6:	460b      	mov	r3, r1
 80027a8:	717b      	strb	r3, [r7, #5]
 80027aa:	4613      	mov	r3, r2
 80027ac:	807b      	strh	r3, [r7, #2]

	// To speed up plotting we define a x window of 6 pixels and then
	// write out one row at a time.  This means the LCD will correctly
	// update the memory pointer saving us a good few bytes

	lcdWriteCommand(SET_COLUMN_ADDRESS); // Horizontal Address Start Position
 80027ae:	202a      	movs	r0, #42	; 0x2a
 80027b0:	f7ff fc48 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 80027b4:	2000      	movs	r0, #0
 80027b6:	f7ff fc55 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(x);
 80027ba:	79bb      	ldrb	r3, [r7, #6]
 80027bc:	4618      	mov	r0, r3
 80027be:	f7ff fc51 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 80027c2:	2000      	movs	r0, #0
 80027c4:	f7ff fc4e 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(x + 5);
 80027c8:	79bb      	ldrb	r3, [r7, #6]
 80027ca:	3305      	adds	r3, #5
 80027cc:	b2db      	uxtb	r3, r3
 80027ce:	4618      	mov	r0, r3
 80027d0:	f7ff fc48 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(SET_PAGE_ADDRESS); // Vertical Address end Position
 80027d4:	202b      	movs	r0, #43	; 0x2b
 80027d6:	f7ff fc35 	bl	8002044 <lcdWriteCommand>
	lcdWriteParameter(0x00);
 80027da:	2000      	movs	r0, #0
 80027dc:	f7ff fc42 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(y);
 80027e0:	797b      	ldrb	r3, [r7, #5]
 80027e2:	4618      	mov	r0, r3
 80027e4:	f7ff fc3e 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x00);
 80027e8:	2000      	movs	r0, #0
 80027ea:	f7ff fc3b 	bl	8002064 <lcdWriteParameter>
	lcdWriteParameter(0x7f);
 80027ee:	207f      	movs	r0, #127	; 0x7f
 80027f0:	f7ff fc38 	bl	8002064 <lcdWriteParameter>

	lcdWriteCommand(WRITE_MEMORY_START);
 80027f4:	202c      	movs	r0, #44	; 0x2c
 80027f6:	f7ff fc25 	bl	8002044 <lcdWriteCommand>

	// Plot the font data
	for (row = 0; row < 8; row++) {
 80027fa:	2300      	movs	r3, #0
 80027fc:	73fb      	strb	r3, [r7, #15]
 80027fe:	e032      	b.n	8002866 <lcdPutCh+0xd6>
		for (column = 0; column < 6; column++) {
 8002800:	2300      	movs	r3, #0
 8002802:	73bb      	strb	r3, [r7, #14]
 8002804:	e029      	b.n	800285a <lcdPutCh+0xca>
			if ((font5x8[character][column]) & (1 << row))
 8002806:	79fa      	ldrb	r2, [r7, #7]
 8002808:	7bb9      	ldrb	r1, [r7, #14]
 800280a:	481a      	ldr	r0, [pc, #104]	; (8002874 <lcdPutCh+0xe4>)
 800280c:	4613      	mov	r3, r2
 800280e:	005b      	lsls	r3, r3, #1
 8002810:	4413      	add	r3, r2
 8002812:	005b      	lsls	r3, r3, #1
 8002814:	4403      	add	r3, r0
 8002816:	440b      	add	r3, r1
 8002818:	781b      	ldrb	r3, [r3, #0]
 800281a:	461a      	mov	r2, r3
 800281c:	7bfb      	ldrb	r3, [r7, #15]
 800281e:	fa42 f303 	asr.w	r3, r2, r3
 8002822:	f003 0301 	and.w	r3, r3, #1
 8002826:	2b00      	cmp	r3, #0
 8002828:	d00a      	beq.n	8002840 <lcdPutCh+0xb0>
				lcdWriteData(fgColour >> 8, fgColour);
 800282a:	887b      	ldrh	r3, [r7, #2]
 800282c:	0a1b      	lsrs	r3, r3, #8
 800282e:	b29b      	uxth	r3, r3
 8002830:	b2db      	uxtb	r3, r3
 8002832:	887a      	ldrh	r2, [r7, #2]
 8002834:	b2d2      	uxtb	r2, r2
 8002836:	4611      	mov	r1, r2
 8002838:	4618      	mov	r0, r3
 800283a:	f7ff fc23 	bl	8002084 <lcdWriteData>
 800283e:	e009      	b.n	8002854 <lcdPutCh+0xc4>
			else
				lcdWriteData(bgColour >> 8, bgColour);
 8002840:	8c3b      	ldrh	r3, [r7, #32]
 8002842:	0a1b      	lsrs	r3, r3, #8
 8002844:	b29b      	uxth	r3, r3
 8002846:	b2db      	uxtb	r3, r3
 8002848:	8c3a      	ldrh	r2, [r7, #32]
 800284a:	b2d2      	uxtb	r2, r2
 800284c:	4611      	mov	r1, r2
 800284e:	4618      	mov	r0, r3
 8002850:	f7ff fc18 	bl	8002084 <lcdWriteData>

	lcdWriteCommand(WRITE_MEMORY_START);

	// Plot the font data
	for (row = 0; row < 8; row++) {
		for (column = 0; column < 6; column++) {
 8002854:	7bbb      	ldrb	r3, [r7, #14]
 8002856:	3301      	adds	r3, #1
 8002858:	73bb      	strb	r3, [r7, #14]
 800285a:	7bbb      	ldrb	r3, [r7, #14]
 800285c:	2b05      	cmp	r3, #5
 800285e:	d9d2      	bls.n	8002806 <lcdPutCh+0x76>
	lcdWriteParameter(0x7f);

	lcdWriteCommand(WRITE_MEMORY_START);

	// Plot the font data
	for (row = 0; row < 8; row++) {
 8002860:	7bfb      	ldrb	r3, [r7, #15]
 8002862:	3301      	adds	r3, #1
 8002864:	73fb      	strb	r3, [r7, #15]
 8002866:	7bfb      	ldrb	r3, [r7, #15]
 8002868:	2b07      	cmp	r3, #7
 800286a:	d9c9      	bls.n	8002800 <lcdPutCh+0x70>
				lcdWriteData(fgColour >> 8, fgColour);
			else
				lcdWriteData(bgColour >> 8, bgColour);
		}
	}
}
 800286c:	bf00      	nop
 800286e:	3714      	adds	r7, #20
 8002870:	46bd      	mov	sp, r7
 8002872:	bd90      	pop	{r4, r7, pc}
 8002874:	08003958 	.word	0x08003958

08002878 <decodeRgbValue>:

// Translates a 3 byte RGB value into a 2 byte value for the LCD (values should be 0-31)
uint16_t decodeRgbValue(uint8_t r, uint8_t g, uint8_t b) {
 8002878:	b480      	push	{r7}
 800287a:	b083      	sub	sp, #12
 800287c:	af00      	add	r7, sp, #0
 800287e:	4603      	mov	r3, r0
 8002880:	71fb      	strb	r3, [r7, #7]
 8002882:	460b      	mov	r3, r1
 8002884:	71bb      	strb	r3, [r7, #6]
 8002886:	4613      	mov	r3, r2
 8002888:	717b      	strb	r3, [r7, #5]
	return (b << 11) | (g << 6) | (r);
 800288a:	797b      	ldrb	r3, [r7, #5]
 800288c:	02db      	lsls	r3, r3, #11
 800288e:	b21a      	sxth	r2, r3
 8002890:	79bb      	ldrb	r3, [r7, #6]
 8002892:	019b      	lsls	r3, r3, #6
 8002894:	b21b      	sxth	r3, r3
 8002896:	4313      	orrs	r3, r2
 8002898:	b21a      	sxth	r2, r3
 800289a:	79fb      	ldrb	r3, [r7, #7]
 800289c:	b21b      	sxth	r3, r3
 800289e:	4313      	orrs	r3, r2
 80028a0:	b21b      	sxth	r3, r3
 80028a2:	b29b      	uxth	r3, r3
}
 80028a4:	4618      	mov	r0, r3
 80028a6:	370c      	adds	r7, #12
 80028a8:	46bd      	mov	sp, r7
 80028aa:	bc80      	pop	{r7}
 80028ac:	4770      	bx	lr
 80028ae:	bf00      	nop

080028b0 <lcdPutS>:
	return y * 8;
}

// Plot a string of characters to the LCD
void lcdPutS(const char *string, uint8_t x, uint8_t y, uint16_t fgColour,
		uint16_t bgColour) {
 80028b0:	b590      	push	{r4, r7, lr}
 80028b2:	b087      	sub	sp, #28
 80028b4:	af02      	add	r7, sp, #8
 80028b6:	6078      	str	r0, [r7, #4]
 80028b8:	4608      	mov	r0, r1
 80028ba:	4611      	mov	r1, r2
 80028bc:	461a      	mov	r2, r3
 80028be:	4603      	mov	r3, r0
 80028c0:	70fb      	strb	r3, [r7, #3]
 80028c2:	460b      	mov	r3, r1
 80028c4:	70bb      	strb	r3, [r7, #2]
 80028c6:	4613      	mov	r3, r2
 80028c8:	803b      	strh	r3, [r7, #0]
	uint8_t origin = x;
 80028ca:	78fb      	ldrb	r3, [r7, #3]
 80028cc:	73bb      	strb	r3, [r7, #14]
	uint8_t characterNumber;

	for (characterNumber = 0; characterNumber < strlen(string);
 80028ce:	2300      	movs	r3, #0
 80028d0:	73fb      	strb	r3, [r7, #15]
 80028d2:	e01c      	b.n	800290e <lcdPutS+0x5e>
			characterNumber++) {
		// Check if we are out of bounds and move to
		// the next line if we are
		if (x > 121) {
 80028d4:	78fb      	ldrb	r3, [r7, #3]
 80028d6:	2b79      	cmp	r3, #121	; 0x79
 80028d8:	d904      	bls.n	80028e4 <lcdPutS+0x34>
			x = origin;
 80028da:	7bbb      	ldrb	r3, [r7, #14]
 80028dc:	70fb      	strb	r3, [r7, #3]
			y += 8;
 80028de:	78bb      	ldrb	r3, [r7, #2]
 80028e0:	3308      	adds	r3, #8
 80028e2:	70bb      	strb	r3, [r7, #2]
		}

		// If we move past the bottom of the screen just exit
		if (y > 120)
 80028e4:	78bb      	ldrb	r3, [r7, #2]
 80028e6:	2b78      	cmp	r3, #120	; 0x78
 80028e8:	d819      	bhi.n	800291e <lcdPutS+0x6e>
			break;

		// Plot the current character
		lcdPutCh(string[characterNumber], x, y, fgColour, bgColour);
 80028ea:	7bfb      	ldrb	r3, [r7, #15]
 80028ec:	687a      	ldr	r2, [r7, #4]
 80028ee:	4413      	add	r3, r2
 80028f0:	7818      	ldrb	r0, [r3, #0]
 80028f2:	883c      	ldrh	r4, [r7, #0]
 80028f4:	78ba      	ldrb	r2, [r7, #2]
 80028f6:	78f9      	ldrb	r1, [r7, #3]
 80028f8:	8c3b      	ldrh	r3, [r7, #32]
 80028fa:	9300      	str	r3, [sp, #0]
 80028fc:	4623      	mov	r3, r4
 80028fe:	f7ff ff47 	bl	8002790 <lcdPutCh>
		x += 6;
 8002902:	78fb      	ldrb	r3, [r7, #3]
 8002904:	3306      	adds	r3, #6
 8002906:	70fb      	strb	r3, [r7, #3]
		uint16_t bgColour) {
	uint8_t origin = x;
	uint8_t characterNumber;

	for (characterNumber = 0; characterNumber < strlen(string);
			characterNumber++) {
 8002908:	7bfb      	ldrb	r3, [r7, #15]
 800290a:	3301      	adds	r3, #1
 800290c:	73fb      	strb	r3, [r7, #15]
void lcdPutS(const char *string, uint8_t x, uint8_t y, uint16_t fgColour,
		uint16_t bgColour) {
	uint8_t origin = x;
	uint8_t characterNumber;

	for (characterNumber = 0; characterNumber < strlen(string);
 800290e:	7bfc      	ldrb	r4, [r7, #15]
 8002910:	6878      	ldr	r0, [r7, #4]
 8002912:	f7fd fc33 	bl	800017c <strlen>
 8002916:	4603      	mov	r3, r0
 8002918:	429c      	cmp	r4, r3
 800291a:	d3db      	bcc.n	80028d4 <lcdPutS+0x24>

		// Plot the current character
		lcdPutCh(string[characterNumber], x, y, fgColour, bgColour);
		x += 6;
	}
}
 800291c:	e000      	b.n	8002920 <lcdPutS+0x70>
			y += 8;
		}

		// If we move past the bottom of the screen just exit
		if (y > 120)
			break;
 800291e:	bf00      	nop

		// Plot the current character
		lcdPutCh(string[characterNumber], x, y, fgColour, bgColour);
		x += 6;
	}
}
 8002920:	bf00      	nop
 8002922:	3714      	adds	r7, #20
 8002924:	46bd      	mov	sp, r7
 8002926:	bd90      	pop	{r4, r7, pc}

08002928 <welcome>:

void welcome(void) {
 8002928:	b590      	push	{r4, r7, lr}
 800292a:	b087      	sub	sp, #28
 800292c:	af02      	add	r7, sp, #8
	char bufferDisplay[10];
	lcdClearDisplay(decodeRgbValue(255, 255, 255));
 800292e:	22ff      	movs	r2, #255	; 0xff
 8002930:	21ff      	movs	r1, #255	; 0xff
 8002932:	20ff      	movs	r0, #255	; 0xff
 8002934:	f7ff ffa0 	bl	8002878 <decodeRgbValue>
 8002938:	4603      	mov	r3, r0
 800293a:	4618      	mov	r0, r3
 800293c:	f7ff fc94 	bl	8002268 <lcdClearDisplay>
	Delay_us(100000);
 8002940:	4832      	ldr	r0, [pc, #200]	; (8002a0c <welcome+0xe4>)
 8002942:	f000 fa55 	bl	8002df0 <Delay_us>
	sprintf(bufferDisplay, "Prilozte kartu");
 8002946:	1d3b      	adds	r3, r7, #4
 8002948:	4a31      	ldr	r2, [pc, #196]	; (8002a10 <welcome+0xe8>)
 800294a:	461c      	mov	r4, r3
 800294c:	4613      	mov	r3, r2
 800294e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8002950:	c407      	stmia	r4!, {r0, r1, r2}
 8002952:	8023      	strh	r3, [r4, #0]
 8002954:	3402      	adds	r4, #2
 8002956:	0c1b      	lsrs	r3, r3, #16
 8002958:	7023      	strb	r3, [r4, #0]
	lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
 800295a:	22ff      	movs	r2, #255	; 0xff
 800295c:	2100      	movs	r1, #0
 800295e:	2000      	movs	r0, #0
 8002960:	f7ff ff8a 	bl	8002878 <decodeRgbValue>
 8002964:	4603      	mov	r3, r0
 8002966:	461c      	mov	r4, r3
 8002968:	22ff      	movs	r2, #255	; 0xff
 800296a:	21ff      	movs	r1, #255	; 0xff
 800296c:	20ff      	movs	r0, #255	; 0xff
 800296e:	f7ff ff83 	bl	8002878 <decodeRgbValue>
 8002972:	4603      	mov	r3, r0
 8002974:	1d38      	adds	r0, r7, #4
 8002976:	9300      	str	r3, [sp, #0]
 8002978:	4623      	mov	r3, r4
 800297a:	2232      	movs	r2, #50	; 0x32
 800297c:	210a      	movs	r1, #10
 800297e:	f7ff ff97 	bl	80028b0 <lcdPutS>
			decodeRgbValue(255, 255, 255));
	lcdFilledRectangle(52, 68, 76, 122, decodeRgbValue(255, 255, 255));
 8002982:	22ff      	movs	r2, #255	; 0xff
 8002984:	21ff      	movs	r1, #255	; 0xff
 8002986:	20ff      	movs	r0, #255	; 0xff
 8002988:	f7ff ff76 	bl	8002878 <decodeRgbValue>
 800298c:	4603      	mov	r3, r0
 800298e:	9300      	str	r3, [sp, #0]
 8002990:	237a      	movs	r3, #122	; 0x7a
 8002992:	224c      	movs	r2, #76	; 0x4c
 8002994:	2144      	movs	r1, #68	; 0x44
 8002996:	2034      	movs	r0, #52	; 0x34
 8002998:	f7ff fdd2 	bl	8002540 <lcdFilledRectangle>
	lcdRectangle(58, 70, 70, 100, decodeRgbValue(0, 0, 255));
 800299c:	22ff      	movs	r2, #255	; 0xff
 800299e:	2100      	movs	r1, #0
 80029a0:	2000      	movs	r0, #0
 80029a2:	f7ff ff69 	bl	8002878 <decodeRgbValue>
 80029a6:	4603      	mov	r3, r0
 80029a8:	9300      	str	r3, [sp, #0]
 80029aa:	2364      	movs	r3, #100	; 0x64
 80029ac:	2246      	movs	r2, #70	; 0x46
 80029ae:	2146      	movs	r1, #70	; 0x46
 80029b0:	203a      	movs	r0, #58	; 0x3a
 80029b2:	f7ff fd7d 	bl	80024b0 <lcdRectangle>
	lcdLine(54, 100, 74, 100, decodeRgbValue(0, 0, 255));
 80029b6:	22ff      	movs	r2, #255	; 0xff
 80029b8:	2100      	movs	r1, #0
 80029ba:	2000      	movs	r0, #0
 80029bc:	f7ff ff5c 	bl	8002878 <decodeRgbValue>
 80029c0:	4603      	mov	r3, r0
 80029c2:	9300      	str	r3, [sp, #0]
 80029c4:	2364      	movs	r3, #100	; 0x64
 80029c6:	224a      	movs	r2, #74	; 0x4a
 80029c8:	2164      	movs	r1, #100	; 0x64
 80029ca:	2036      	movs	r0, #54	; 0x36
 80029cc:	f7ff fcc4 	bl	8002358 <lcdLine>
	lcdLine(64, 120, 54, 100, decodeRgbValue(0, 0, 255));
 80029d0:	22ff      	movs	r2, #255	; 0xff
 80029d2:	2100      	movs	r1, #0
 80029d4:	2000      	movs	r0, #0
 80029d6:	f7ff ff4f 	bl	8002878 <decodeRgbValue>
 80029da:	4603      	mov	r3, r0
 80029dc:	9300      	str	r3, [sp, #0]
 80029de:	2364      	movs	r3, #100	; 0x64
 80029e0:	2236      	movs	r2, #54	; 0x36
 80029e2:	2178      	movs	r1, #120	; 0x78
 80029e4:	2040      	movs	r0, #64	; 0x40
 80029e6:	f7ff fcb7 	bl	8002358 <lcdLine>
	lcdLine(64, 120, 74, 100, decodeRgbValue(0, 0, 255));
 80029ea:	22ff      	movs	r2, #255	; 0xff
 80029ec:	2100      	movs	r1, #0
 80029ee:	2000      	movs	r0, #0
 80029f0:	f7ff ff42 	bl	8002878 <decodeRgbValue>
 80029f4:	4603      	mov	r3, r0
 80029f6:	9300      	str	r3, [sp, #0]
 80029f8:	2364      	movs	r3, #100	; 0x64
 80029fa:	224a      	movs	r2, #74	; 0x4a
 80029fc:	2178      	movs	r1, #120	; 0x78
 80029fe:	2040      	movs	r0, #64	; 0x40
 8002a00:	f7ff fcaa 	bl	8002358 <lcdLine>
}
 8002a04:	bf00      	nop
 8002a06:	3714      	adds	r7, #20
 8002a08:	46bd      	mov	sp, r7
 8002a0a:	bd90      	pop	{r4, r7, pc}
 8002a0c:	000186a0 	.word	0x000186a0
 8002a10:	080038c0 	.word	0x080038c0

08002a14 <ok>:

void ok(void) {
 8002a14:	b580      	push	{r7, lr}
 8002a16:	b082      	sub	sp, #8
 8002a18:	af02      	add	r7, sp, #8
	lcdCircle(44, 90, 10, decodeRgbValue(0, 255, 0));
 8002a1a:	2200      	movs	r2, #0
 8002a1c:	21ff      	movs	r1, #255	; 0xff
 8002a1e:	2000      	movs	r0, #0
 8002a20:	f7ff ff2a 	bl	8002878 <decodeRgbValue>
 8002a24:	4603      	mov	r3, r0
 8002a26:	220a      	movs	r2, #10
 8002a28:	215a      	movs	r1, #90	; 0x5a
 8002a2a:	202c      	movs	r0, #44	; 0x2c
 8002a2c:	f7ff fde4 	bl	80025f8 <lcdCircle>
	lcdLine(64, 80, 64, 100, decodeRgbValue(0, 255, 0));
 8002a30:	2200      	movs	r2, #0
 8002a32:	21ff      	movs	r1, #255	; 0xff
 8002a34:	2000      	movs	r0, #0
 8002a36:	f7ff ff1f 	bl	8002878 <decodeRgbValue>
 8002a3a:	4603      	mov	r3, r0
 8002a3c:	9300      	str	r3, [sp, #0]
 8002a3e:	2364      	movs	r3, #100	; 0x64
 8002a40:	2240      	movs	r2, #64	; 0x40
 8002a42:	2150      	movs	r1, #80	; 0x50
 8002a44:	2040      	movs	r0, #64	; 0x40
 8002a46:	f7ff fc87 	bl	8002358 <lcdLine>
	lcdLine(64, 90, 74, 80, decodeRgbValue(0, 255, 0));
 8002a4a:	2200      	movs	r2, #0
 8002a4c:	21ff      	movs	r1, #255	; 0xff
 8002a4e:	2000      	movs	r0, #0
 8002a50:	f7ff ff12 	bl	8002878 <decodeRgbValue>
 8002a54:	4603      	mov	r3, r0
 8002a56:	9300      	str	r3, [sp, #0]
 8002a58:	2350      	movs	r3, #80	; 0x50
 8002a5a:	224a      	movs	r2, #74	; 0x4a
 8002a5c:	215a      	movs	r1, #90	; 0x5a
 8002a5e:	2040      	movs	r0, #64	; 0x40
 8002a60:	f7ff fc7a 	bl	8002358 <lcdLine>
	lcdLine(64, 90, 74, 100, decodeRgbValue(0, 255, 0));
 8002a64:	2200      	movs	r2, #0
 8002a66:	21ff      	movs	r1, #255	; 0xff
 8002a68:	2000      	movs	r0, #0
 8002a6a:	f7ff ff05 	bl	8002878 <decodeRgbValue>
 8002a6e:	4603      	mov	r3, r0
 8002a70:	9300      	str	r3, [sp, #0]
 8002a72:	2364      	movs	r3, #100	; 0x64
 8002a74:	224a      	movs	r2, #74	; 0x4a
 8002a76:	215a      	movs	r1, #90	; 0x5a
 8002a78:	2040      	movs	r0, #64	; 0x40
 8002a7a:	f7ff fc6d 	bl	8002358 <lcdLine>
}
 8002a7e:	bf00      	nop
 8002a80:	46bd      	mov	sp, r7
 8002a82:	bd80      	pop	{r7, pc}

08002a84 <vykricnik>:

void vykricnik(void) {
 8002a84:	b580      	push	{r7, lr}
 8002a86:	b084      	sub	sp, #16
 8002a88:	af02      	add	r7, sp, #8
	lcdFilledRectangle(52, 68, 76, 122, decodeRgbValue(255, 255, 255));
 8002a8a:	22ff      	movs	r2, #255	; 0xff
 8002a8c:	21ff      	movs	r1, #255	; 0xff
 8002a8e:	20ff      	movs	r0, #255	; 0xff
 8002a90:	f7ff fef2 	bl	8002878 <decodeRgbValue>
 8002a94:	4603      	mov	r3, r0
 8002a96:	9300      	str	r3, [sp, #0]
 8002a98:	237a      	movs	r3, #122	; 0x7a
 8002a9a:	224c      	movs	r2, #76	; 0x4c
 8002a9c:	2144      	movs	r1, #68	; 0x44
 8002a9e:	2034      	movs	r0, #52	; 0x34
 8002aa0:	f7ff fd4e 	bl	8002540 <lcdFilledRectangle>
	lcdRectangle(58, 70, 70, 100, decodeRgbValue(255, 0, 0));
 8002aa4:	2200      	movs	r2, #0
 8002aa6:	2100      	movs	r1, #0
 8002aa8:	20ff      	movs	r0, #255	; 0xff
 8002aaa:	f7ff fee5 	bl	8002878 <decodeRgbValue>
 8002aae:	4603      	mov	r3, r0
 8002ab0:	9300      	str	r3, [sp, #0]
 8002ab2:	2364      	movs	r3, #100	; 0x64
 8002ab4:	2246      	movs	r2, #70	; 0x46
 8002ab6:	2146      	movs	r1, #70	; 0x46
 8002ab8:	203a      	movs	r0, #58	; 0x3a
 8002aba:	f7ff fcf9 	bl	80024b0 <lcdRectangle>
	lcdRectangle(58, 105, 70, 110, decodeRgbValue(255, 0, 0));
 8002abe:	2200      	movs	r2, #0
 8002ac0:	2100      	movs	r1, #0
 8002ac2:	20ff      	movs	r0, #255	; 0xff
 8002ac4:	f7ff fed8 	bl	8002878 <decodeRgbValue>
 8002ac8:	4603      	mov	r3, r0
 8002aca:	9300      	str	r3, [sp, #0]
 8002acc:	236e      	movs	r3, #110	; 0x6e
 8002ace:	2246      	movs	r2, #70	; 0x46
 8002ad0:	2169      	movs	r1, #105	; 0x69
 8002ad2:	203a      	movs	r0, #58	; 0x3a
 8002ad4:	f7ff fcec 	bl	80024b0 <lcdRectangle>
	for (int c = 0; c < 8; c++) {
 8002ad8:	2300      	movs	r3, #0
 8002ada:	607b      	str	r3, [r7, #4]
 8002adc:	e009      	b.n	8002af2 <vykricnik+0x6e>
		GPIO_ToggleBits(GPIOA, GPIO_Pin_0 | GPIO_Pin_6);
 8002ade:	2141      	movs	r1, #65	; 0x41
 8002ae0:	4807      	ldr	r0, [pc, #28]	; (8002b00 <vykricnik+0x7c>)
 8002ae2:	f7fd fd57 	bl	8000594 <GPIO_ToggleBits>
		Delay_us(500000);
 8002ae6:	4807      	ldr	r0, [pc, #28]	; (8002b04 <vykricnik+0x80>)
 8002ae8:	f000 f982 	bl	8002df0 <Delay_us>

void vykricnik(void) {
	lcdFilledRectangle(52, 68, 76, 122, decodeRgbValue(255, 255, 255));
	lcdRectangle(58, 70, 70, 100, decodeRgbValue(255, 0, 0));
	lcdRectangle(58, 105, 70, 110, decodeRgbValue(255, 0, 0));
	for (int c = 0; c < 8; c++) {
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	3301      	adds	r3, #1
 8002af0:	607b      	str	r3, [r7, #4]
 8002af2:	687b      	ldr	r3, [r7, #4]
 8002af4:	2b07      	cmp	r3, #7
 8002af6:	ddf2      	ble.n	8002ade <vykricnik+0x5a>
		GPIO_ToggleBits(GPIOA, GPIO_Pin_0 | GPIO_Pin_6);
		Delay_us(500000);
	}
}
 8002af8:	bf00      	nop
 8002afa:	3708      	adds	r7, #8
 8002afc:	46bd      	mov	sp, r7
 8002afe:	bd80      	pop	{r7, pc}
 8002b00:	40020000 	.word	0x40020000
 8002b04:	0007a120 	.word	0x0007a120

08002b08 <main>:
void Send_string_uart(const char*);
void Send_char_uart(char);

void USART1_IRQHandler(void);

int main(void) {
 8002b08:	b5b0      	push	{r4, r5, r7, lr}
 8002b0a:	b088      	sub	sp, #32
 8002b0c:	af04      	add	r7, sp, #16
	setLed();
 8002b0e:	f000 fa0d 	bl	8002f2c <setLed>
	unsigned char CardID[5];
	RCC_Configuration();
 8002b12:	f000 f941 	bl	8002d98 <RCC_Configuration>
	/**/
	NVIC_Configuration();
 8002b16:	f000 f99d 	bl	8002e54 <NVIC_Configuration>
	initUART2();
 8002b1a:	f000 f9b3 	bl	8002e84 <initUART2>
	//----RFID-----
	TM_MFRC522_Init();
 8002b1e:	f7fe f8ad 	bl	8000c7c <TM_MFRC522_Init>
	// pre LCD displej
	initSPI();
 8002b22:	f000 fa6f 	bl	8003004 <initSPI>
	initCD_Pin();
 8002b26:	f000 faff 	bl	8003128 <initCD_Pin>
	initCS_Pin();
 8002b2a:	f000 fadf 	bl	80030ec <initCS_Pin>
	initRES_Pin();
 8002b2e:	f000 fb31 	bl	8003194 <initRES_Pin>
	lcdInitialise(LCD_ORIENTATION0);
 8002b32:	2000      	movs	r0, #0
 8002b34:	f7ff fabc 	bl	80020b0 <lcdInitialise>
	lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8002b38:	22ff      	movs	r2, #255	; 0xff
 8002b3a:	21ff      	movs	r1, #255	; 0xff
 8002b3c:	20ff      	movs	r0, #255	; 0xff
 8002b3e:	f7ff fe9b 	bl	8002878 <decodeRgbValue>
 8002b42:	4603      	mov	r3, r0
 8002b44:	4618      	mov	r0, r3
 8002b46:	f7ff fb8f 	bl	8002268 <lcdClearDisplay>

	uint8_t modreTlac = 0;
 8002b4a:	2300      	movs	r3, #0
 8002b4c:	72fb      	strb	r3, [r7, #11]
	uint8_t cerveneTlac = 0;
 8002b4e:	2300      	movs	r3, #0
 8002b50:	72bb      	strb	r3, [r7, #10]

	kontrola_zoznamu();
 8002b52:	f7ff f9b3 	bl	8001ebc <kontrola_zoznamu>

	int pom = 0;
 8002b56:	2300      	movs	r3, #0
 8002b58:	60fb      	str	r3, [r7, #12]
	welcome();
 8002b5a:	f7ff fee5 	bl	8002928 <welcome>
	GPIO_SetBits(GPIOA, GPIO_Pin_0);
 8002b5e:	2101      	movs	r1, #1
 8002b60:	4880      	ldr	r0, [pc, #512]	; (8002d64 <main+0x25c>)
 8002b62:	f7fd fcfb 	bl	800055c <GPIO_SetBits>


	while (1) {

		modreTlac = ((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8)) + 1) % 2;
 8002b66:	f44f 7180 	mov.w	r1, #256	; 0x100
 8002b6a:	487f      	ldr	r0, [pc, #508]	; (8002d68 <main+0x260>)
 8002b6c:	f7fd fcda 	bl	8000524 <GPIO_ReadInputDataBit>
 8002b70:	4603      	mov	r3, r0
 8002b72:	1c5a      	adds	r2, r3, #1
 8002b74:	4b7d      	ldr	r3, [pc, #500]	; (8002d6c <main+0x264>)
 8002b76:	4013      	ands	r3, r2
 8002b78:	2b00      	cmp	r3, #0
 8002b7a:	da03      	bge.n	8002b84 <main+0x7c>
 8002b7c:	3b01      	subs	r3, #1
 8002b7e:	f063 0301 	orn	r3, r3, #1
 8002b82:	3301      	adds	r3, #1
 8002b84:	72fb      	strb	r3, [r7, #11]
		if (modreTlac == 0) {
 8002b86:	7afb      	ldrb	r3, [r7, #11]
 8002b88:	2b00      	cmp	r3, #0
 8002b8a:	d126      	bne.n	8002bda <main+0xd2>
			GPIO_SetBits(GPIOA, GPIO_Pin_4);
 8002b8c:	2110      	movs	r1, #16
 8002b8e:	4875      	ldr	r0, [pc, #468]	; (8002d64 <main+0x25c>)
 8002b90:	f7fd fce4 	bl	800055c <GPIO_SetBits>
			pom=0;
 8002b94:	2300      	movs	r3, #0
 8002b96:	60fb      	str	r3, [r7, #12]
			while (((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8)) + 1) % 2 == 0 && (pom<32))  {
 8002b98:	e005      	b.n	8002ba6 <main+0x9e>
				pom++;
 8002b9a:	68fb      	ldr	r3, [r7, #12]
 8002b9c:	3301      	adds	r3, #1
 8002b9e:	60fb      	str	r3, [r7, #12]
				Delay_us(100000);
 8002ba0:	4873      	ldr	r0, [pc, #460]	; (8002d70 <main+0x268>)
 8002ba2:	f000 f925 	bl	8002df0 <Delay_us>

		modreTlac = ((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8)) + 1) % 2;
		if (modreTlac == 0) {
			GPIO_SetBits(GPIOA, GPIO_Pin_4);
			pom=0;
			while (((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8)) + 1) % 2 == 0 && (pom<32))  {
 8002ba6:	f44f 7180 	mov.w	r1, #256	; 0x100
 8002baa:	486f      	ldr	r0, [pc, #444]	; (8002d68 <main+0x260>)
 8002bac:	f7fd fcba 	bl	8000524 <GPIO_ReadInputDataBit>
 8002bb0:	4603      	mov	r3, r0
 8002bb2:	3301      	adds	r3, #1
 8002bb4:	f003 0301 	and.w	r3, r3, #1
 8002bb8:	2b00      	cmp	r3, #0
 8002bba:	d102      	bne.n	8002bc2 <main+0xba>
 8002bbc:	68fb      	ldr	r3, [r7, #12]
 8002bbe:	2b1f      	cmp	r3, #31
 8002bc0:	ddeb      	ble.n	8002b9a <main+0x92>
				pom++;
				Delay_us(100000);
			}
			if (pom > 30) {
 8002bc2:	68fb      	ldr	r3, [r7, #12]
 8002bc4:	2b1e      	cmp	r3, #30
 8002bc6:	dd02      	ble.n	8002bce <main+0xc6>
				vypis_pristupov();
 8002bc8:	f7ff f82c 	bl	8001c24 <vypis_pristupov>
 8002bcc:	e001      	b.n	8002bd2 <main+0xca>
			} else {

				zapisanie();
 8002bce:	f7fe fb6b 	bl	80012a8 <zapisanie>

			}
			GPIO_ResetBits(GPIOA, GPIO_Pin_4);
 8002bd2:	2110      	movs	r1, #16
 8002bd4:	4863      	ldr	r0, [pc, #396]	; (8002d64 <main+0x25c>)
 8002bd6:	f7fd fccf 	bl	8000578 <GPIO_ResetBits>
		}

		cerveneTlac = ((GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_9)) + 1) % 2;
 8002bda:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002bde:	4862      	ldr	r0, [pc, #392]	; (8002d68 <main+0x260>)
 8002be0:	f7fd fca0 	bl	8000524 <GPIO_ReadInputDataBit>
 8002be4:	4603      	mov	r3, r0
 8002be6:	1c5a      	adds	r2, r3, #1
 8002be8:	4b60      	ldr	r3, [pc, #384]	; (8002d6c <main+0x264>)
 8002bea:	4013      	ands	r3, r2
 8002bec:	2b00      	cmp	r3, #0
 8002bee:	da03      	bge.n	8002bf8 <main+0xf0>
 8002bf0:	3b01      	subs	r3, #1
 8002bf2:	f063 0301 	orn	r3, r3, #1
 8002bf6:	3301      	adds	r3, #1
 8002bf8:	72bb      	strb	r3, [r7, #10]
		if (cerveneTlac == 0) {
 8002bfa:	7abb      	ldrb	r3, [r7, #10]
 8002bfc:	2b00      	cmp	r3, #0
 8002bfe:	d109      	bne.n	8002c14 <main+0x10c>
			GPIO_SetBits(GPIOA, GPIO_Pin_4);
 8002c00:	2110      	movs	r1, #16
 8002c02:	4858      	ldr	r0, [pc, #352]	; (8002d64 <main+0x25c>)
 8002c04:	f7fd fcaa 	bl	800055c <GPIO_SetBits>
			vymazanie();
 8002c08:	f7fe fd18 	bl	800163c <vymazanie>
			//vypis_pristupov();
			GPIO_ResetBits(GPIOA, GPIO_Pin_4);
 8002c0c:	2110      	movs	r1, #16
 8002c0e:	4855      	ldr	r0, [pc, #340]	; (8002d64 <main+0x25c>)
 8002c10:	f7fd fcb2 	bl	8000578 <GPIO_ResetBits>
		}

		//-----------------------------RFID Analayzer------------------------------------------
		if (TM_MFRC522_Check(CardID) == MI_OK) {
 8002c14:	1d3b      	adds	r3, r7, #4
 8002c16:	4618      	mov	r0, r3
 8002c18:	f7fe f9b8 	bl	8000f8c <TM_MFRC522_Check>
 8002c1c:	4603      	mov	r3, r0
 8002c1e:	2b00      	cmp	r3, #0
 8002c20:	f040 8099 	bne.w	8002d56 <main+0x24e>
			zapis_pristupu(CardID);
 8002c24:	1d3b      	adds	r3, r7, #4
 8002c26:	4618      	mov	r0, r3
 8002c28:	f7fe ffa6 	bl	8001b78 <zapis_pristupu>
			sprintf(bufferRFID, "[%x-%x-%x-%x-%x]", CardID[0], CardID[1],
 8002c2c:	793b      	ldrb	r3, [r7, #4]
 8002c2e:	4618      	mov	r0, r3
 8002c30:	797b      	ldrb	r3, [r7, #5]
 8002c32:	461c      	mov	r4, r3
					CardID[2], CardID[3], CardID[4]);
 8002c34:	79bb      	ldrb	r3, [r7, #6]
 8002c36:	79fa      	ldrb	r2, [r7, #7]
 8002c38:	7a39      	ldrb	r1, [r7, #8]
		}

		//-----------------------------RFID Analayzer------------------------------------------
		if (TM_MFRC522_Check(CardID) == MI_OK) {
			zapis_pristupu(CardID);
			sprintf(bufferRFID, "[%x-%x-%x-%x-%x]", CardID[0], CardID[1],
 8002c3a:	9102      	str	r1, [sp, #8]
 8002c3c:	9201      	str	r2, [sp, #4]
 8002c3e:	9300      	str	r3, [sp, #0]
 8002c40:	4623      	mov	r3, r4
 8002c42:	4602      	mov	r2, r0
 8002c44:	494b      	ldr	r1, [pc, #300]	; (8002d74 <main+0x26c>)
 8002c46:	484c      	ldr	r0, [pc, #304]	; (8002d78 <main+0x270>)
 8002c48:	f000 fcd6 	bl	80035f8 <siprintf>
					CardID[2], CardID[3], CardID[4]);
			Send_string_uart(bufferRFID);
 8002c4c:	484a      	ldr	r0, [pc, #296]	; (8002d78 <main+0x270>)
 8002c4e:	f000 f8e1 	bl	8002e14 <Send_string_uart>
			Send_string_uart("\n\r");
 8002c52:	484a      	ldr	r0, [pc, #296]	; (8002d7c <main+0x274>)
 8002c54:	f000 f8de 	bl	8002e14 <Send_string_uart>
			//Check if this is my card
			if (karta_v_zozname(CardID) == MI_OK)
 8002c58:	1d3b      	adds	r3, r7, #4
 8002c5a:	4618      	mov	r0, r3
 8002c5c:	f7fe fe92 	bl	8001984 <karta_v_zozname>
 8002c60:	4603      	mov	r3, r0
 8002c62:	2b00      	cmp	r3, #0
 8002c64:	d145      	bne.n	8002cf2 <main+0x1ea>
			//if (TM_MFRC522_Compare(CardID, MyID) == MI_OK)
					{
				Send_string_uart("Pristup povoleny\n\r");
 8002c66:	4846      	ldr	r0, [pc, #280]	; (8002d80 <main+0x278>)
 8002c68:	f000 f8d4 	bl	8002e14 <Send_string_uart>
				sprintf(bufferDisplay, "Pristup povoleny");
 8002c6c:	4a45      	ldr	r2, [pc, #276]	; (8002d84 <main+0x27c>)
 8002c6e:	4b46      	ldr	r3, [pc, #280]	; (8002d88 <main+0x280>)
 8002c70:	4615      	mov	r5, r2
 8002c72:	461c      	mov	r4, r3
 8002c74:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002c76:	6028      	str	r0, [r5, #0]
 8002c78:	6069      	str	r1, [r5, #4]
 8002c7a:	60aa      	str	r2, [r5, #8]
 8002c7c:	60eb      	str	r3, [r5, #12]
 8002c7e:	7823      	ldrb	r3, [r4, #0]
 8002c80:	742b      	strb	r3, [r5, #16]
				lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8002c82:	22ff      	movs	r2, #255	; 0xff
 8002c84:	21ff      	movs	r1, #255	; 0xff
 8002c86:	20ff      	movs	r0, #255	; 0xff
 8002c88:	f7ff fdf6 	bl	8002878 <decodeRgbValue>
 8002c8c:	4603      	mov	r3, r0
 8002c8e:	4618      	mov	r0, r3
 8002c90:	f7ff faea 	bl	8002268 <lcdClearDisplay>
				lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(0, 0, 255),
 8002c94:	22ff      	movs	r2, #255	; 0xff
 8002c96:	2100      	movs	r1, #0
 8002c98:	2000      	movs	r0, #0
 8002c9a:	f7ff fded 	bl	8002878 <decodeRgbValue>
 8002c9e:	4603      	mov	r3, r0
 8002ca0:	461c      	mov	r4, r3
 8002ca2:	22ff      	movs	r2, #255	; 0xff
 8002ca4:	21ff      	movs	r1, #255	; 0xff
 8002ca6:	20ff      	movs	r0, #255	; 0xff
 8002ca8:	f7ff fde6 	bl	8002878 <decodeRgbValue>
 8002cac:	4603      	mov	r3, r0
 8002cae:	9300      	str	r3, [sp, #0]
 8002cb0:	4623      	mov	r3, r4
 8002cb2:	2232      	movs	r2, #50	; 0x32
 8002cb4:	210a      	movs	r1, #10
 8002cb6:	4833      	ldr	r0, [pc, #204]	; (8002d84 <main+0x27c>)
 8002cb8:	f7ff fdfa 	bl	80028b0 <lcdPutS>
						decodeRgbValue(255, 255, 255));
				//GPIO_SetBits(GPIOB, GPIO_Pin_4);
				//vykreslenie OK
				ok();
 8002cbc:	f7ff feaa 	bl	8002a14 <ok>
				GPIO_ResetBits(GPIOA, GPIO_Pin_0);
 8002cc0:	2101      	movs	r1, #1
 8002cc2:	4828      	ldr	r0, [pc, #160]	; (8002d64 <main+0x25c>)
 8002cc4:	f7fd fc58 	bl	8000578 <GPIO_ResetBits>
				//otvor zamok
				GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_6);
 8002cc8:	2142      	movs	r1, #66	; 0x42
 8002cca:	4826      	ldr	r0, [pc, #152]	; (8002d64 <main+0x25c>)
 8002ccc:	f7fd fc46 	bl	800055c <GPIO_SetBits>
				Delay(5); //cas pre otvoreny zamok [s]
 8002cd0:	2005      	movs	r0, #5
 8002cd2:	f000 f873 	bl	8002dbc <Delay>
				GPIO_ResetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_6);
 8002cd6:	2142      	movs	r1, #66	; 0x42
 8002cd8:	4822      	ldr	r0, [pc, #136]	; (8002d64 <main+0x25c>)
 8002cda:	f7fd fc4d 	bl	8000578 <GPIO_ResetBits>
				Delay(1);
 8002cde:	2001      	movs	r0, #1
 8002ce0:	f000 f86c 	bl	8002dbc <Delay>
				GPIO_SetBits(GPIOA, GPIO_Pin_0);
 8002ce4:	2101      	movs	r1, #1
 8002ce6:	481f      	ldr	r0, [pc, #124]	; (8002d64 <main+0x25c>)
 8002ce8:	f7fd fc38 	bl	800055c <GPIO_SetBits>
				welcome();
 8002cec:	f7ff fe1c 	bl	8002928 <welcome>
 8002cf0:	e031      	b.n	8002d56 <main+0x24e>

			} else {
				Send_string_uart("Pristup zamietnuty\n\r");
 8002cf2:	4826      	ldr	r0, [pc, #152]	; (8002d8c <main+0x284>)
 8002cf4:	f000 f88e 	bl	8002e14 <Send_string_uart>
				sprintf(bufferDisplay, "Pristup zamietnuty");
 8002cf8:	4a22      	ldr	r2, [pc, #136]	; (8002d84 <main+0x27c>)
 8002cfa:	4b25      	ldr	r3, [pc, #148]	; (8002d90 <main+0x288>)
 8002cfc:	4615      	mov	r5, r2
 8002cfe:	461c      	mov	r4, r3
 8002d00:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002d02:	6028      	str	r0, [r5, #0]
 8002d04:	6069      	str	r1, [r5, #4]
 8002d06:	60aa      	str	r2, [r5, #8]
 8002d08:	60eb      	str	r3, [r5, #12]
 8002d0a:	8823      	ldrh	r3, [r4, #0]
 8002d0c:	78a2      	ldrb	r2, [r4, #2]
 8002d0e:	822b      	strh	r3, [r5, #16]
 8002d10:	4613      	mov	r3, r2
 8002d12:	74ab      	strb	r3, [r5, #18]
				lcdClearDisplay(decodeRgbValue(255, 255, 255));
 8002d14:	22ff      	movs	r2, #255	; 0xff
 8002d16:	21ff      	movs	r1, #255	; 0xff
 8002d18:	20ff      	movs	r0, #255	; 0xff
 8002d1a:	f7ff fdad 	bl	8002878 <decodeRgbValue>
 8002d1e:	4603      	mov	r3, r0
 8002d20:	4618      	mov	r0, r3
 8002d22:	f7ff faa1 	bl	8002268 <lcdClearDisplay>
				lcdPutS(bufferDisplay, 10, 50, decodeRgbValue(255, 0, 0),
 8002d26:	2200      	movs	r2, #0
 8002d28:	2100      	movs	r1, #0
 8002d2a:	20ff      	movs	r0, #255	; 0xff
 8002d2c:	f7ff fda4 	bl	8002878 <decodeRgbValue>
 8002d30:	4603      	mov	r3, r0
 8002d32:	461c      	mov	r4, r3
 8002d34:	22ff      	movs	r2, #255	; 0xff
 8002d36:	21ff      	movs	r1, #255	; 0xff
 8002d38:	20ff      	movs	r0, #255	; 0xff
 8002d3a:	f7ff fd9d 	bl	8002878 <decodeRgbValue>
 8002d3e:	4603      	mov	r3, r0
 8002d40:	9300      	str	r3, [sp, #0]
 8002d42:	4623      	mov	r3, r4
 8002d44:	2232      	movs	r2, #50	; 0x32
 8002d46:	210a      	movs	r1, #10
 8002d48:	480e      	ldr	r0, [pc, #56]	; (8002d84 <main+0x27c>)
 8002d4a:	f7ff fdb1 	bl	80028b0 <lcdPutS>
						decodeRgbValue(255, 255, 255));

				//vykreslenie Vykricnika a spustenie buzzera
				vykricnik();
 8002d4e:	f7ff fe99 	bl	8002a84 <vykricnik>
				welcome();
 8002d52:	f7ff fde9 	bl	8002928 <welcome>
			}

		}
		Send_string_uart("Waiting for RFID Card...!\n\r");
 8002d56:	480f      	ldr	r0, [pc, #60]	; (8002d94 <main+0x28c>)
 8002d58:	f000 f85c 	bl	8002e14 <Send_string_uart>

		Delay(1);
 8002d5c:	2001      	movs	r0, #1
 8002d5e:	f000 f82d 	bl	8002dbc <Delay>
	}
 8002d62:	e700      	b.n	8002b66 <main+0x5e>
 8002d64:	40020000 	.word	0x40020000
 8002d68:	40020400 	.word	0x40020400
 8002d6c:	80000001 	.word	0x80000001
 8002d70:	000186a0 	.word	0x000186a0
 8002d74:	080038d0 	.word	0x080038d0
 8002d78:	20000038 	.word	0x20000038
 8002d7c:	080038e4 	.word	0x080038e4
 8002d80:	080038e8 	.word	0x080038e8
 8002d84:	20000070 	.word	0x20000070
 8002d88:	080038fc 	.word	0x080038fc
 8002d8c:	08003910 	.word	0x08003910
 8002d90:	08003928 	.word	0x08003928
 8002d94:	0800393c 	.word	0x0800393c

08002d98 <RCC_Configuration>:
 *************************************************************************************************************************************
 *							  								LOCAL FUNCTIONS															*
 *************************************************************************************************************************************
 */

void RCC_Configuration(void) {
 8002d98:	b580      	push	{r7, lr}
 8002d9a:	af00      	add	r7, sp, #0
	/* Setup the microcontroller system. Initialize the Embedded Flash Interface,
	 initialize the PLL and update the SystemFrequency variable. */
	//SystemInit();
	/* Enable GPIOA B C E and AFIO clocks */
///RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8002d9c:	2101      	movs	r1, #1
 8002d9e:	2002      	movs	r0, #2
 8002da0:	f7fd fd2e 	bl	8000800 <RCC_AHBPeriphClockCmd>
	//RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8002da4:	2101      	movs	r1, #1
 8002da6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8002daa:	f7fd fd65 	bl	8000878 <RCC_APB1PeriphClockCmd>
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
 8002dae:	2101      	movs	r1, #1
 8002db0:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8002db4:	f7fd fd60 	bl	8000878 <RCC_APB1PeriphClockCmd>
	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);
	/**/
	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
}
 8002db8:	bf00      	nop
 8002dba:	bd80      	pop	{r7, pc}

08002dbc <Delay>:
/**
 * @brief  	Inserts a delay time with resolution is 10 milisecond..
 * @param  	nCount: specifies the delay time length.
 * @retval 	None
 */
void Delay(__IO uint32_t num) {
 8002dbc:	b480      	push	{r7}
 8002dbe:	b085      	sub	sp, #20
 8002dc0:	af00      	add	r7, sp, #0
 8002dc2:	6078      	str	r0, [r7, #4]
	__IO uint32_t index = 0;
 8002dc4:	2300      	movs	r3, #0
 8002dc6:	60fb      	str	r3, [r7, #12]

	/* default system clock is 72MHz */
	for (index = (720000 * num); index != 0; index--) {
 8002dc8:	687b      	ldr	r3, [r7, #4]
 8002dca:	4a08      	ldr	r2, [pc, #32]	; (8002dec <Delay+0x30>)
 8002dcc:	fb02 f303 	mul.w	r3, r2, r3
 8002dd0:	60fb      	str	r3, [r7, #12]
 8002dd2:	e002      	b.n	8002dda <Delay+0x1e>
 8002dd4:	68fb      	ldr	r3, [r7, #12]
 8002dd6:	3b01      	subs	r3, #1
 8002dd8:	60fb      	str	r3, [r7, #12]
 8002dda:	68fb      	ldr	r3, [r7, #12]
 8002ddc:	2b00      	cmp	r3, #0
 8002dde:	d1f9      	bne.n	8002dd4 <Delay+0x18>
	}
}
 8002de0:	bf00      	nop
 8002de2:	3714      	adds	r7, #20
 8002de4:	46bd      	mov	sp, r7
 8002de6:	bc80      	pop	{r7}
 8002de8:	4770      	bx	lr
 8002dea:	bf00      	nop
 8002dec:	000afc80 	.word	0x000afc80

08002df0 <Delay_us>:
/**
 * @brief  	Make Delay using Loop CPU
 * @param  	uint32_t Delay in milisecond
 * @retval 	None
 */
void Delay_us(uint32_t us) {
 8002df0:	b480      	push	{r7}
 8002df2:	b085      	sub	sp, #20
 8002df4:	af00      	add	r7, sp, #0
 8002df6:	6078      	str	r0, [r7, #4]
	uint32_t temp;
	temp = us;			// * 6; // cho 24 MHZ
 8002df8:	687b      	ldr	r3, [r7, #4]
 8002dfa:	60fb      	str	r3, [r7, #12]
	while (temp > 0) {
 8002dfc:	e002      	b.n	8002e04 <Delay_us+0x14>
		temp--;
 8002dfe:	68fb      	ldr	r3, [r7, #12]
 8002e00:	3b01      	subs	r3, #1
 8002e02:	60fb      	str	r3, [r7, #12]
 * @retval 	None
 */
void Delay_us(uint32_t us) {
	uint32_t temp;
	temp = us;			// * 6; // cho 24 MHZ
	while (temp > 0) {
 8002e04:	68fb      	ldr	r3, [r7, #12]
 8002e06:	2b00      	cmp	r3, #0
 8002e08:	d1f9      	bne.n	8002dfe <Delay_us+0xe>
		temp--;
	}
}
 8002e0a:	bf00      	nop
 8002e0c:	3714      	adds	r7, #20
 8002e0e:	46bd      	mov	sp, r7
 8002e10:	bc80      	pop	{r7}
 8002e12:	4770      	bx	lr

08002e14 <Send_string_uart>:
	return ((int) (USART2->DR & 0x1FF));
}
/*----------------------------------------------------------------------------
 Send string
 *----------------------------------------------------------------------------*/
void Send_string_uart(const char *str) {
 8002e14:	b580      	push	{r7, lr}
 8002e16:	b082      	sub	sp, #8
 8002e18:	af00      	add	r7, sp, #0
 8002e1a:	6078      	str	r0, [r7, #4]
	while (*str) {
 8002e1c:	e010      	b.n	8002e40 <Send_string_uart+0x2c>
		while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
 8002e1e:	bf00      	nop
 8002e20:	2180      	movs	r1, #128	; 0x80
 8002e22:	480b      	ldr	r0, [pc, #44]	; (8002e50 <Send_string_uart+0x3c>)
 8002e24:	f7fd ff0e 	bl	8000c44 <USART_GetFlagStatus>
 8002e28:	4603      	mov	r3, r0
 8002e2a:	2b00      	cmp	r3, #0
 8002e2c:	d0f8      	beq.n	8002e20 <Send_string_uart+0xc>
			;
		USART_SendData(USART2, *str++);
 8002e2e:	687b      	ldr	r3, [r7, #4]
 8002e30:	1c5a      	adds	r2, r3, #1
 8002e32:	607a      	str	r2, [r7, #4]
 8002e34:	781b      	ldrb	r3, [r3, #0]
 8002e36:	b29b      	uxth	r3, r3
 8002e38:	4619      	mov	r1, r3
 8002e3a:	4805      	ldr	r0, [pc, #20]	; (8002e50 <Send_string_uart+0x3c>)
 8002e3c:	f7fd fea8 	bl	8000b90 <USART_SendData>
}
/*----------------------------------------------------------------------------
 Send string
 *----------------------------------------------------------------------------*/
void Send_string_uart(const char *str) {
	while (*str) {
 8002e40:	687b      	ldr	r3, [r7, #4]
 8002e42:	781b      	ldrb	r3, [r3, #0]
 8002e44:	2b00      	cmp	r3, #0
 8002e46:	d1ea      	bne.n	8002e1e <Send_string_uart+0xa>
		while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
			;
		USART_SendData(USART2, *str++);
	}
}
 8002e48:	bf00      	nop
 8002e4a:	3708      	adds	r7, #8
 8002e4c:	46bd      	mov	sp, r7
 8002e4e:	bd80      	pop	{r7, pc}
 8002e50:	40004400 	.word	0x40004400

08002e54 <NVIC_Configuration>:
/**
 * @brief  Configures the nested vectored interrupt controller.
 * @param  None
 * @retval None
 */
void NVIC_Configuration(void) {
 8002e54:	b580      	push	{r7, lr}
 8002e56:	b082      	sub	sp, #8
 8002e58:	af00      	add	r7, sp, #0
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
 8002e5a:	f44f 60e0 	mov.w	r0, #1792	; 0x700
 8002e5e:	f7fd f995 	bl	800018c <NVIC_PriorityGroupConfig>
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
 8002e62:	2326      	movs	r3, #38	; 0x26
 8002e64:	713b      	strb	r3, [r7, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 8002e66:	2301      	movs	r3, #1
 8002e68:	717b      	strb	r3, [r7, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8002e6a:	2300      	movs	r3, #0
 8002e6c:	71bb      	strb	r3, [r7, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8002e6e:	2301      	movs	r3, #1
 8002e70:	71fb      	strb	r3, [r7, #7]
	NVIC_Init(&NVIC_InitStructure);
 8002e72:	1d3b      	adds	r3, r7, #4
 8002e74:	4618      	mov	r0, r3
 8002e76:	f7fd f99b 	bl	80001b0 <NVIC_Init>
}
 8002e7a:	bf00      	nop
 8002e7c:	3708      	adds	r7, #8
 8002e7e:	46bd      	mov	sp, r7
 8002e80:	bd80      	pop	{r7, pc}
 8002e82:	bf00      	nop

08002e84 <initUART2>:

void initUART2(void) {
 8002e84:	b580      	push	{r7, lr}
 8002e86:	af00      	add	r7, sp, #0

	/* Configure USART pins */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 8002e88:	4b1f      	ldr	r3, [pc, #124]	; (8002f08 <initUART2+0x84>)
 8002e8a:	220c      	movs	r2, #12
 8002e8c:	601a      	str	r2, [r3, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002e8e:	4b1e      	ldr	r3, [pc, #120]	; (8002f08 <initUART2+0x84>)
 8002e90:	2202      	movs	r2, #2
 8002e92:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002e94:	4b1c      	ldr	r3, [pc, #112]	; (8002f08 <initUART2+0x84>)
 8002e96:	2200      	movs	r2, #0
 8002e98:	71da      	strb	r2, [r3, #7]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002e9a:	4b1b      	ldr	r3, [pc, #108]	; (8002f08 <initUART2+0x84>)
 8002e9c:	2200      	movs	r2, #0
 8002e9e:	719a      	strb	r2, [r3, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 8002ea0:	4b19      	ldr	r3, [pc, #100]	; (8002f08 <initUART2+0x84>)
 8002ea2:	2203      	movs	r2, #3
 8002ea4:	715a      	strb	r2, [r3, #5]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002ea6:	4918      	ldr	r1, [pc, #96]	; (8002f08 <initUART2+0x84>)
 8002ea8:	4818      	ldr	r0, [pc, #96]	; (8002f0c <initUART2+0x88>)
 8002eaa:	f7fd faa5 	bl	80003f8 <GPIO_Init>

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
 8002eae:	2207      	movs	r2, #7
 8002eb0:	2102      	movs	r1, #2
 8002eb2:	4816      	ldr	r0, [pc, #88]	; (8002f0c <initUART2+0x88>)
 8002eb4:	f7fd fb82 	bl	80005bc <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
 8002eb8:	2207      	movs	r2, #7
 8002eba:	2103      	movs	r1, #3
 8002ebc:	4813      	ldr	r0, [pc, #76]	; (8002f0c <initUART2+0x88>)
 8002ebe:	f7fd fb7d 	bl	80005bc <GPIO_PinAFConfig>

	USART_InitStructure.USART_BaudRate = 9600;
 8002ec2:	4b13      	ldr	r3, [pc, #76]	; (8002f10 <initUART2+0x8c>)
 8002ec4:	f44f 5216 	mov.w	r2, #9600	; 0x2580
 8002ec8:	601a      	str	r2, [r3, #0]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8002eca:	4b11      	ldr	r3, [pc, #68]	; (8002f10 <initUART2+0x8c>)
 8002ecc:	2200      	movs	r2, #0
 8002ece:	809a      	strh	r2, [r3, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8002ed0:	4b0f      	ldr	r3, [pc, #60]	; (8002f10 <initUART2+0x8c>)
 8002ed2:	2200      	movs	r2, #0
 8002ed4:	80da      	strh	r2, [r3, #6]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8002ed6:	4b0e      	ldr	r3, [pc, #56]	; (8002f10 <initUART2+0x8c>)
 8002ed8:	2200      	movs	r2, #0
 8002eda:	811a      	strh	r2, [r3, #8]
	USART_InitStructure.USART_HardwareFlowControl =
 8002edc:	4b0c      	ldr	r3, [pc, #48]	; (8002f10 <initUART2+0x8c>)
 8002ede:	2200      	movs	r2, #0
 8002ee0:	819a      	strh	r2, [r3, #12]
	USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8002ee2:	4b0b      	ldr	r3, [pc, #44]	; (8002f10 <initUART2+0x8c>)
 8002ee4:	220c      	movs	r2, #12
 8002ee6:	815a      	strh	r2, [r3, #10]
	/* Enable USART2 Receive and Transmit interrupts */
	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
 8002ee8:	2201      	movs	r2, #1
 8002eea:	f240 5125 	movw	r1, #1317	; 0x525
 8002eee:	4809      	ldr	r0, [pc, #36]	; (8002f14 <initUART2+0x90>)
 8002ef0:	f7fd fe60 	bl	8000bb4 <USART_ITConfig>
	//USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
	/* USART configuration */
	USART_Init(USART2, &USART_InitStructure);
 8002ef4:	4906      	ldr	r1, [pc, #24]	; (8002f10 <initUART2+0x8c>)
 8002ef6:	4807      	ldr	r0, [pc, #28]	; (8002f14 <initUART2+0x90>)
 8002ef8:	f7fd fd76 	bl	80009e8 <USART_Init>
	/* Enable USART */
	USART_Cmd(USART2, ENABLE);
 8002efc:	2101      	movs	r1, #1
 8002efe:	4805      	ldr	r0, [pc, #20]	; (8002f14 <initUART2+0x90>)
 8002f00:	f7fd fe26 	bl	8000b50 <USART_Cmd>

}
 8002f04:	bf00      	nop
 8002f06:	bd80      	pop	{r7, pc}
 8002f08:	2000007c 	.word	0x2000007c
 8002f0c:	40020000 	.word	0x40020000
 8002f10:	20000084 	.word	0x20000084
 8002f14:	40004400 	.word	0x40004400

08002f18 <USART2_IRQHandler>:

void USART2_IRQHandler() {
 8002f18:	b580      	push	{r7, lr}
 8002f1a:	af00      	add	r7, sp, #0
	if (USART_GetFlagStatus(USART2, USART_FLAG_RXNE)) {
 8002f1c:	2120      	movs	r1, #32
 8002f1e:	4802      	ldr	r0, [pc, #8]	; (8002f28 <USART2_IRQHandler+0x10>)
 8002f20:	f7fd fe90 	bl	8000c44 <USART_GetFlagStatus>
		//todo nieco
	}
}
 8002f24:	bf00      	nop
 8002f26:	bd80      	pop	{r7, pc}
 8002f28:	40004400 	.word	0x40004400

08002f2c <setLed>:

void setLed(void) {
 8002f2c:	b580      	push	{r7, lr}
 8002f2e:	b082      	sub	sp, #8
 8002f30:	af00      	add	r7, sp, #0
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8002f32:	2101      	movs	r1, #1
 8002f34:	2001      	movs	r0, #1
 8002f36:	f7fd fc63 	bl	8000800 <RCC_AHBPeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8002f3a:	2101      	movs	r1, #1
 8002f3c:	2002      	movs	r0, #2
 8002f3e:	f7fd fc5f 	bl	8000800 <RCC_AHBPeriphClockCmd>
	GPIO_InitTypeDef gpioInitStruc;

	gpioInitStruc.GPIO_Pin = GPIO_Pin_0;
 8002f42:	2301      	movs	r3, #1
 8002f44:	603b      	str	r3, [r7, #0]
	gpioInitStruc.GPIO_Mode = GPIO_Mode_OUT;
 8002f46:	2301      	movs	r3, #1
 8002f48:	713b      	strb	r3, [r7, #4]
	gpioInitStruc.GPIO_OType = GPIO_OType_PP;
 8002f4a:	2300      	movs	r3, #0
 8002f4c:	71bb      	strb	r3, [r7, #6]
	gpioInitStruc.GPIO_PuPd = GPIO_PuPd_UP;
 8002f4e:	2301      	movs	r3, #1
 8002f50:	71fb      	strb	r3, [r7, #7]
	gpioInitStruc.GPIO_Speed = GPIO_Speed_40MHz;
 8002f52:	2303      	movs	r3, #3
 8002f54:	717b      	strb	r3, [r7, #5]
	GPIO_Init(GPIOA, &gpioInitStruc);
 8002f56:	463b      	mov	r3, r7
 8002f58:	4619      	mov	r1, r3
 8002f5a:	4828      	ldr	r0, [pc, #160]	; (8002ffc <setLed+0xd0>)
 8002f5c:	f7fd fa4c 	bl	80003f8 <GPIO_Init>

	gpioInitStruc.GPIO_Pin = GPIO_Pin_1;
 8002f60:	2302      	movs	r3, #2
 8002f62:	603b      	str	r3, [r7, #0]
	gpioInitStruc.GPIO_Mode = GPIO_Mode_OUT;
 8002f64:	2301      	movs	r3, #1
 8002f66:	713b      	strb	r3, [r7, #4]
	gpioInitStruc.GPIO_OType = GPIO_OType_PP;
 8002f68:	2300      	movs	r3, #0
 8002f6a:	71bb      	strb	r3, [r7, #6]
	gpioInitStruc.GPIO_PuPd = GPIO_PuPd_UP;
 8002f6c:	2301      	movs	r3, #1
 8002f6e:	71fb      	strb	r3, [r7, #7]
	gpioInitStruc.GPIO_Speed = GPIO_Speed_40MHz;
 8002f70:	2303      	movs	r3, #3
 8002f72:	717b      	strb	r3, [r7, #5]
	GPIO_Init(GPIOA, &gpioInitStruc);
 8002f74:	463b      	mov	r3, r7
 8002f76:	4619      	mov	r1, r3
 8002f78:	4820      	ldr	r0, [pc, #128]	; (8002ffc <setLed+0xd0>)
 8002f7a:	f7fd fa3d 	bl	80003f8 <GPIO_Init>

	gpioInitStruc.GPIO_Pin = GPIO_Pin_4;
 8002f7e:	2310      	movs	r3, #16
 8002f80:	603b      	str	r3, [r7, #0]
	gpioInitStruc.GPIO_Mode = GPIO_Mode_OUT;
 8002f82:	2301      	movs	r3, #1
 8002f84:	713b      	strb	r3, [r7, #4]
	gpioInitStruc.GPIO_OType = GPIO_OType_PP;
 8002f86:	2300      	movs	r3, #0
 8002f88:	71bb      	strb	r3, [r7, #6]
	gpioInitStruc.GPIO_PuPd = GPIO_PuPd_UP;
 8002f8a:	2301      	movs	r3, #1
 8002f8c:	71fb      	strb	r3, [r7, #7]
	gpioInitStruc.GPIO_Speed = GPIO_Speed_40MHz;
 8002f8e:	2303      	movs	r3, #3
 8002f90:	717b      	strb	r3, [r7, #5]
	GPIO_Init(GPIOA, &gpioInitStruc);
 8002f92:	463b      	mov	r3, r7
 8002f94:	4619      	mov	r1, r3
 8002f96:	4819      	ldr	r0, [pc, #100]	; (8002ffc <setLed+0xd0>)
 8002f98:	f7fd fa2e 	bl	80003f8 <GPIO_Init>

	gpioInitStruc.GPIO_Pin = GPIO_Pin_6;
 8002f9c:	2340      	movs	r3, #64	; 0x40
 8002f9e:	603b      	str	r3, [r7, #0]
	gpioInitStruc.GPIO_Mode = GPIO_Mode_OUT;
 8002fa0:	2301      	movs	r3, #1
 8002fa2:	713b      	strb	r3, [r7, #4]
	gpioInitStruc.GPIO_OType = GPIO_OType_PP;
 8002fa4:	2300      	movs	r3, #0
 8002fa6:	71bb      	strb	r3, [r7, #6]
	gpioInitStruc.GPIO_PuPd = GPIO_PuPd_UP;
 8002fa8:	2301      	movs	r3, #1
 8002faa:	71fb      	strb	r3, [r7, #7]
	gpioInitStruc.GPIO_Speed = GPIO_Speed_40MHz;
 8002fac:	2303      	movs	r3, #3
 8002fae:	717b      	strb	r3, [r7, #5]
	GPIO_Init(GPIOA, &gpioInitStruc);
 8002fb0:	463b      	mov	r3, r7
 8002fb2:	4619      	mov	r1, r3
 8002fb4:	4811      	ldr	r0, [pc, #68]	; (8002ffc <setLed+0xd0>)
 8002fb6:	f7fd fa1f 	bl	80003f8 <GPIO_Init>

	gpioInitStruc.GPIO_Pin = GPIO_Pin_8;
 8002fba:	f44f 7380 	mov.w	r3, #256	; 0x100
 8002fbe:	603b      	str	r3, [r7, #0]
	gpioInitStruc.GPIO_Mode = GPIO_Mode_IN;
 8002fc0:	2300      	movs	r3, #0
 8002fc2:	713b      	strb	r3, [r7, #4]
	gpioInitStruc.GPIO_OType = GPIO_OType_PP;
 8002fc4:	2300      	movs	r3, #0
 8002fc6:	71bb      	strb	r3, [r7, #6]
	gpioInitStruc.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002fc8:	2300      	movs	r3, #0
 8002fca:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOB, &gpioInitStruc);
 8002fcc:	463b      	mov	r3, r7
 8002fce:	4619      	mov	r1, r3
 8002fd0:	480b      	ldr	r0, [pc, #44]	; (8003000 <setLed+0xd4>)
 8002fd2:	f7fd fa11 	bl	80003f8 <GPIO_Init>

	gpioInitStruc.GPIO_Pin = GPIO_Pin_9;
 8002fd6:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002fda:	603b      	str	r3, [r7, #0]
	gpioInitStruc.GPIO_Mode = GPIO_Mode_IN;
 8002fdc:	2300      	movs	r3, #0
 8002fde:	713b      	strb	r3, [r7, #4]
	gpioInitStruc.GPIO_OType = GPIO_OType_PP;
 8002fe0:	2300      	movs	r3, #0
 8002fe2:	71bb      	strb	r3, [r7, #6]
	gpioInitStruc.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002fe4:	2300      	movs	r3, #0
 8002fe6:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOB, &gpioInitStruc);
 8002fe8:	463b      	mov	r3, r7
 8002fea:	4619      	mov	r1, r3
 8002fec:	4804      	ldr	r0, [pc, #16]	; (8003000 <setLed+0xd4>)
 8002fee:	f7fd fa03 	bl	80003f8 <GPIO_Init>
}
 8002ff2:	bf00      	nop
 8002ff4:	3708      	adds	r7, #8
 8002ff6:	46bd      	mov	sp, r7
 8002ff8:	bd80      	pop	{r7, pc}
 8002ffa:	bf00      	nop
 8002ffc:	40020000 	.word	0x40020000
 8003000:	40020400 	.word	0x40020400

08003004 <initSPI>:
#include <stddef.h>
#include "stm32l1xx.h"

//TODO rework to STM32L mcu's

void initSPI(void) {
 8003004:	b580      	push	{r7, lr}
 8003006:	b088      	sub	sp, #32
 8003008:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 800300a:	2101      	movs	r1, #1
 800300c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8003010:	f7fd fc14 	bl	800083c <RCC_APB2PeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8003014:	2101      	movs	r1, #1
 8003016:	2002      	movs	r0, #2
 8003018:	f7fd fbf2 	bl	8000800 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800301c:	2302      	movs	r3, #2
 800301e:	773b      	strb	r3, [r7, #28]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003020:	2300      	movs	r3, #0
 8003022:	77bb      	strb	r3, [r7, #30]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 8003024:	2303      	movs	r3, #3
 8003026:	777b      	strb	r3, [r7, #29]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003028:	2300      	movs	r3, #0
 800302a:	77fb      	strb	r3, [r7, #31]
	//PA8 - A0
	//+3.3V - LED
	//GND - GND
	//+5V - VCC

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
 800302c:	2338      	movs	r3, #56	; 0x38
 800302e:	61bb      	str	r3, [r7, #24]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8003030:	f107 0318 	add.w	r3, r7, #24
 8003034:	4619      	mov	r1, r3
 8003036:	4819      	ldr	r0, [pc, #100]	; (800309c <initSPI+0x98>)
 8003038:	f7fd f9de 	bl	80003f8 <GPIO_Init>

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_SPI1);
 800303c:	2205      	movs	r2, #5
 800303e:	2103      	movs	r1, #3
 8003040:	4816      	ldr	r0, [pc, #88]	; (800309c <initSPI+0x98>)
 8003042:	f7fd fabb 	bl	80005bc <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_SPI1);
 8003046:	2205      	movs	r2, #5
 8003048:	2104      	movs	r1, #4
 800304a:	4814      	ldr	r0, [pc, #80]	; (800309c <initSPI+0x98>)
 800304c:	f7fd fab6 	bl	80005bc <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_SPI1);
 8003050:	2205      	movs	r2, #5
 8003052:	2105      	movs	r1, #5
 8003054:	4811      	ldr	r0, [pc, #68]	; (800309c <initSPI+0x98>)
 8003056:	f7fd fab1 	bl	80005bc <GPIO_PinAFConfig>

	SPI_InitTypeDef SPI_InitStructure;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 800305a:	2300      	movs	r3, #0
 800305c:	823b      	strh	r3, [r7, #16]
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 800305e:	2300      	movs	r3, #0
 8003060:	81bb      	strh	r3, [r7, #12]
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8003062:	2300      	movs	r3, #0
 8003064:	817b      	strh	r3, [r7, #10]
	SPI_InitStructure.SPI_CRCPolynomial = SPI_CRC_Rx;
 8003066:	2301      	movs	r3, #1
 8003068:	82bb      	strh	r3, [r7, #20]
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 800306a:	2300      	movs	r3, #0
 800306c:	813b      	strh	r3, [r7, #8]
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 800306e:	2300      	movs	r3, #0
 8003070:	80bb      	strh	r3, [r7, #4]
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 8003072:	2300      	movs	r3, #0
 8003074:	827b      	strh	r3, [r7, #18]
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8003076:	f44f 7382 	mov.w	r3, #260	; 0x104
 800307a:	80fb      	strh	r3, [r7, #6]
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 800307c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003080:	81fb      	strh	r3, [r7, #14]

	/* Apply SPI configuration after enabling it */
	SPI_Init(SPI1, &SPI_InitStructure);
 8003082:	1d3b      	adds	r3, r7, #4
 8003084:	4619      	mov	r1, r3
 8003086:	4806      	ldr	r0, [pc, #24]	; (80030a0 <initSPI+0x9c>)
 8003088:	f7fd fc14 	bl	80008b4 <SPI_Init>
	/* SPI Peripheral Enable */
	SPI_Cmd(SPI1, ENABLE);
 800308c:	2101      	movs	r1, #1
 800308e:	4804      	ldr	r0, [pc, #16]	; (80030a0 <initSPI+0x9c>)
 8003090:	f7fd fc54 	bl	800093c <SPI_Cmd>
}
 8003094:	bf00      	nop
 8003096:	3720      	adds	r7, #32
 8003098:	46bd      	mov	sp, r7
 800309a:	bd80      	pop	{r7, pc}
 800309c:	40020400 	.word	0x40020400
 80030a0:	40013000 	.word	0x40013000

080030a4 <readWriteSPI>:

unsigned char readWriteSPI(unsigned char txData) {
 80030a4:	b580      	push	{r7, lr}
 80030a6:	b084      	sub	sp, #16
 80030a8:	af00      	add	r7, sp, #0
 80030aa:	4603      	mov	r3, r0
 80030ac:	71fb      	strb	r3, [r7, #7]
	unsigned char rxData;

	SPI1->DR = txData;
 80030ae:	4b0e      	ldr	r3, [pc, #56]	; (80030e8 <readWriteSPI+0x44>)
 80030b0:	79fa      	ldrb	r2, [r7, #7]
 80030b2:	b292      	uxth	r2, r2
 80030b4:	819a      	strh	r2, [r3, #12]
	// wait until TXE = 1
	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != SET)
 80030b6:	bf00      	nop
 80030b8:	2102      	movs	r1, #2
 80030ba:	480b      	ldr	r0, [pc, #44]	; (80030e8 <readWriteSPI+0x44>)
 80030bc:	f7fd fc78 	bl	80009b0 <SPI_I2S_GetFlagStatus>
 80030c0:	4603      	mov	r3, r0
 80030c2:	2b01      	cmp	r3, #1
 80030c4:	d1f8      	bne.n	80030b8 <readWriteSPI+0x14>
		;
	// wait until RXNE = 1
	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) != SET)
 80030c6:	bf00      	nop
 80030c8:	2101      	movs	r1, #1
 80030ca:	4807      	ldr	r0, [pc, #28]	; (80030e8 <readWriteSPI+0x44>)
 80030cc:	f7fd fc70 	bl	80009b0 <SPI_I2S_GetFlagStatus>
 80030d0:	4603      	mov	r3, r0
 80030d2:	2b01      	cmp	r3, #1
 80030d4:	d1f8      	bne.n	80030c8 <readWriteSPI+0x24>
		;
	// read the rx buff to clear the RXNE flag (garbage)
	rxData = SPI1->DR;
 80030d6:	4b04      	ldr	r3, [pc, #16]	; (80030e8 <readWriteSPI+0x44>)
 80030d8:	899b      	ldrh	r3, [r3, #12]
 80030da:	b29b      	uxth	r3, r3
 80030dc:	73fb      	strb	r3, [r7, #15]

	return rxData;
 80030de:	7bfb      	ldrb	r3, [r7, #15]
}
 80030e0:	4618      	mov	r0, r3
 80030e2:	3710      	adds	r7, #16
 80030e4:	46bd      	mov	sp, r7
 80030e6:	bd80      	pop	{r7, pc}
 80030e8:	40013000 	.word	0x40013000

080030ec <initCS_Pin>:

void initCS_Pin(void) {
 80030ec:	b580      	push	{r7, lr}
 80030ee:	b082      	sub	sp, #8
 80030f0:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 80030f2:	2101      	movs	r1, #1
 80030f4:	2002      	movs	r0, #2
 80030f6:	f7fd fb83 	bl	8000800 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80030fa:	2300      	movs	r3, #0
 80030fc:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 80030fe:	2303      	movs	r3, #3
 8003100:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003102:	2300      	movs	r3, #0
 8003104:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 8003106:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800310a:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800310c:	2301      	movs	r3, #1
 800310e:	713b      	strb	r3, [r7, #4]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8003110:	463b      	mov	r3, r7
 8003112:	4619      	mov	r1, r3
 8003114:	4803      	ldr	r0, [pc, #12]	; (8003124 <initCS_Pin+0x38>)
 8003116:	f7fd f96f 	bl	80003f8 <GPIO_Init>
}
 800311a:	bf00      	nop
 800311c:	3708      	adds	r7, #8
 800311e:	46bd      	mov	sp, r7
 8003120:	bd80      	pop	{r7, pc}
 8003122:	bf00      	nop
 8003124:	40020400 	.word	0x40020400

08003128 <initCD_Pin>:

void initCD_Pin(void) {
 8003128:	b580      	push	{r7, lr}
 800312a:	b082      	sub	sp, #8
 800312c:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 800312e:	2101      	movs	r1, #1
 8003130:	2001      	movs	r0, #1
 8003132:	f7fd fb65 	bl	8000800 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8003136:	2300      	movs	r3, #0
 8003138:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 800313a:	2303      	movs	r3, #3
 800313c:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800313e:	2300      	movs	r3, #0
 8003140:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 8003142:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003146:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8003148:	2301      	movs	r3, #1
 800314a:	713b      	strb	r3, [r7, #4]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800314c:	463b      	mov	r3, r7
 800314e:	4619      	mov	r1, r3
 8003150:	4803      	ldr	r0, [pc, #12]	; (8003160 <initCD_Pin+0x38>)
 8003152:	f7fd f951 	bl	80003f8 <GPIO_Init>
}
 8003156:	bf00      	nop
 8003158:	3708      	adds	r7, #8
 800315a:	46bd      	mov	sp, r7
 800315c:	bd80      	pop	{r7, pc}
 800315e:	bf00      	nop
 8003160:	40020000 	.word	0x40020000

08003164 <cd_set>:

void cd_set(void) {
 8003164:	b480      	push	{r7}
 8003166:	af00      	add	r7, sp, #0
	GPIOA->BSRRL = GPIO_Pin_8;
 8003168:	4b03      	ldr	r3, [pc, #12]	; (8003178 <cd_set+0x14>)
 800316a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800316e:	831a      	strh	r2, [r3, #24]
}
 8003170:	bf00      	nop
 8003172:	46bd      	mov	sp, r7
 8003174:	bc80      	pop	{r7}
 8003176:	4770      	bx	lr
 8003178:	40020000 	.word	0x40020000

0800317c <cd_reset>:

void cd_reset(void) {
 800317c:	b480      	push	{r7}
 800317e:	af00      	add	r7, sp, #0
	GPIOA->BSRRH = GPIO_Pin_8;
 8003180:	4b03      	ldr	r3, [pc, #12]	; (8003190 <cd_reset+0x14>)
 8003182:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003186:	835a      	strh	r2, [r3, #26]
}
 8003188:	bf00      	nop
 800318a:	46bd      	mov	sp, r7
 800318c:	bc80      	pop	{r7}
 800318e:	4770      	bx	lr
 8003190:	40020000 	.word	0x40020000

08003194 <initRES_Pin>:

void initRES_Pin(void) {
 8003194:	b580      	push	{r7, lr}
 8003196:	b082      	sub	sp, #8
 8003198:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 800319a:	2101      	movs	r1, #1
 800319c:	2001      	movs	r0, #1
 800319e:	f7fd fb2f 	bl	8000800 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80031a2:	2300      	movs	r3, #0
 80031a4:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 80031a6:	2303      	movs	r3, #3
 80031a8:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80031aa:	2300      	movs	r3, #0
 80031ac:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 80031ae:	f44f 7300 	mov.w	r3, #512	; 0x200
 80031b2:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80031b4:	2301      	movs	r3, #1
 80031b6:	713b      	strb	r3, [r7, #4]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80031b8:	463b      	mov	r3, r7
 80031ba:	4619      	mov	r1, r3
 80031bc:	4803      	ldr	r0, [pc, #12]	; (80031cc <initRES_Pin+0x38>)
 80031be:	f7fd f91b 	bl	80003f8 <GPIO_Init>
}
 80031c2:	bf00      	nop
 80031c4:	3708      	adds	r7, #8
 80031c6:	46bd      	mov	sp, r7
 80031c8:	bd80      	pop	{r7, pc}
 80031ca:	bf00      	nop
 80031cc:	40020000 	.word	0x40020000

080031d0 <res_set>:

void res_set(void) {
 80031d0:	b480      	push	{r7}
 80031d2:	af00      	add	r7, sp, #0
	GPIOA->BSRRL = GPIO_Pin_9;
 80031d4:	4b03      	ldr	r3, [pc, #12]	; (80031e4 <res_set+0x14>)
 80031d6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80031da:	831a      	strh	r2, [r3, #24]
}
 80031dc:	bf00      	nop
 80031de:	46bd      	mov	sp, r7
 80031e0:	bc80      	pop	{r7}
 80031e2:	4770      	bx	lr
 80031e4:	40020000 	.word	0x40020000

080031e8 <res_reset>:

void res_reset(void) {
 80031e8:	b480      	push	{r7}
 80031ea:	af00      	add	r7, sp, #0
	GPIOA->BSRRH = GPIO_Pin_9;
 80031ec:	4b03      	ldr	r3, [pc, #12]	; (80031fc <res_reset+0x14>)
 80031ee:	f44f 7200 	mov.w	r2, #512	; 0x200
 80031f2:	835a      	strh	r2, [r3, #26]
}
 80031f4:	bf00      	nop
 80031f6:	46bd      	mov	sp, r7
 80031f8:	bc80      	pop	{r7}
 80031fa:	4770      	bx	lr
 80031fc:	40020000 	.word	0x40020000

08003200 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8003200:	f8df d034 	ldr.w	sp, [pc, #52]	; 8003238 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 8003204:	2100      	movs	r1, #0
  b LoopCopyDataInit
 8003206:	e003      	b.n	8003210 <LoopCopyDataInit>

08003208 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8003208:	4b0c      	ldr	r3, [pc, #48]	; (800323c <LoopFillZerobss+0x18>)
  ldr r3, [r3, r1]
 800320a:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 800320c:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 800320e:	3104      	adds	r1, #4

08003210 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8003210:	480b      	ldr	r0, [pc, #44]	; (8003240 <LoopFillZerobss+0x1c>)
  ldr r3, =_edata
 8003212:	4b0c      	ldr	r3, [pc, #48]	; (8003244 <LoopFillZerobss+0x20>)
  adds r2, r0, r1
 8003214:	1842      	adds	r2, r0, r1
  cmp r2, r3
 8003216:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8003218:	d3f6      	bcc.n	8003208 <CopyDataInit>
  ldr r2, =_sbss
 800321a:	4a0b      	ldr	r2, [pc, #44]	; (8003248 <LoopFillZerobss+0x24>)
  b LoopFillZerobss
 800321c:	e002      	b.n	8003224 <LoopFillZerobss>

0800321e <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 800321e:	2300      	movs	r3, #0
  str r3, [r2], #4
 8003220:	f842 3b04 	str.w	r3, [r2], #4

08003224 <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 8003224:	4b09      	ldr	r3, [pc, #36]	; (800324c <LoopFillZerobss+0x28>)
  cmp r2, r3
 8003226:	429a      	cmp	r2, r3
  bcc FillZerobss
 8003228:	d3f9      	bcc.n	800321e <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800322a:	f000 f841 	bl	80032b0 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800322e:	f000 f9f9 	bl	8003624 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8003232:	f7ff fc69 	bl	8002b08 <main>
  bx lr
 8003236:	4770      	bx	lr

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8003238:	20014000 	.word	0x20014000
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r3, =_sidata
 800323c:	08003f60 	.word	0x08003f60
  ldr r3, [r3, r1]
  str r3, [r0, r1]
  adds r1, r1, #4

LoopCopyDataInit:
  ldr r0, =_sdata
 8003240:	20000000 	.word	0x20000000
  ldr r3, =_edata
 8003244:	2000001c 	.word	0x2000001c
  adds r2, r0, r1
  cmp r2, r3
  bcc CopyDataInit
  ldr r2, =_sbss
 8003248:	2000001c 	.word	0x2000001c
FillZerobss:
  movs r3, #0
  str r3, [r2], #4

LoopFillZerobss:
  ldr r3, = _ebss
 800324c:	200000a0 	.word	0x200000a0

08003250 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8003250:	e7fe      	b.n	8003250 <ADC1_IRQHandler>
	...

08003254 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8003254:	b480      	push	{r7}
 8003256:	af00      	add	r7, sp, #0
}
 8003258:	bf00      	nop
 800325a:	46bd      	mov	sp, r7
 800325c:	bc80      	pop	{r7}
 800325e:	4770      	bx	lr

08003260 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8003260:	b480      	push	{r7}
 8003262:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
 8003264:	e7fe      	b.n	8003264 <HardFault_Handler+0x4>
 8003266:	bf00      	nop

08003268 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8003268:	b480      	push	{r7}
 800326a:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
 800326c:	e7fe      	b.n	800326c <MemManage_Handler+0x4>
 800326e:	bf00      	nop

08003270 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8003270:	b480      	push	{r7}
 8003272:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 8003274:	e7fe      	b.n	8003274 <BusFault_Handler+0x4>
 8003276:	bf00      	nop

08003278 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8003278:	b480      	push	{r7}
 800327a:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 800327c:	e7fe      	b.n	800327c <UsageFault_Handler+0x4>
 800327e:	bf00      	nop

08003280 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 8003280:	b480      	push	{r7}
 8003282:	af00      	add	r7, sp, #0
}
 8003284:	bf00      	nop
 8003286:	46bd      	mov	sp, r7
 8003288:	bc80      	pop	{r7}
 800328a:	4770      	bx	lr

0800328c <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 800328c:	b480      	push	{r7}
 800328e:	af00      	add	r7, sp, #0
}
 8003290:	bf00      	nop
 8003292:	46bd      	mov	sp, r7
 8003294:	bc80      	pop	{r7}
 8003296:	4770      	bx	lr

08003298 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8003298:	b480      	push	{r7}
 800329a:	af00      	add	r7, sp, #0
}
 800329c:	bf00      	nop
 800329e:	46bd      	mov	sp, r7
 80032a0:	bc80      	pop	{r7}
 80032a2:	4770      	bx	lr

080032a4 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 80032a4:	b480      	push	{r7}
 80032a6:	af00      	add	r7, sp, #0
	/*  TimingDelay_Decrement(); */
#ifdef USE_STM32L_DISCOVERY
  TimingDelay_Decrement();
#endif
}
 80032a8:	bf00      	nop
 80032aa:	46bd      	mov	sp, r7
 80032ac:	bc80      	pop	{r7}
 80032ae:	4770      	bx	lr

080032b0 <SystemInit>:
  *         SystemCoreClock variable.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 80032b0:	b580      	push	{r7, lr}
 80032b2:	af00      	add	r7, sp, #0
  /*!< Set MSION bit */
  RCC->CR |= (uint32_t)0x00000100;
 80032b4:	4a15      	ldr	r2, [pc, #84]	; (800330c <SystemInit+0x5c>)
 80032b6:	4b15      	ldr	r3, [pc, #84]	; (800330c <SystemInit+0x5c>)
 80032b8:	681b      	ldr	r3, [r3, #0]
 80032ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80032be:	6013      	str	r3, [r2, #0]

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t)0x88FFC00C;
 80032c0:	4912      	ldr	r1, [pc, #72]	; (800330c <SystemInit+0x5c>)
 80032c2:	4b12      	ldr	r3, [pc, #72]	; (800330c <SystemInit+0x5c>)
 80032c4:	689a      	ldr	r2, [r3, #8]
 80032c6:	4b12      	ldr	r3, [pc, #72]	; (8003310 <SystemInit+0x60>)
 80032c8:	4013      	ands	r3, r2
 80032ca:	608b      	str	r3, [r1, #8]
  
  /*!< Reset HSION, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xEEFEFFFE;
 80032cc:	4a0f      	ldr	r2, [pc, #60]	; (800330c <SystemInit+0x5c>)
 80032ce:	4b0f      	ldr	r3, [pc, #60]	; (800330c <SystemInit+0x5c>)
 80032d0:	681b      	ldr	r3, [r3, #0]
 80032d2:	f023 5388 	bic.w	r3, r3, #285212672	; 0x11000000
 80032d6:	f023 1301 	bic.w	r3, r3, #65537	; 0x10001
 80032da:	6013      	str	r3, [r2, #0]

  /*!< Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80032dc:	4a0b      	ldr	r2, [pc, #44]	; (800330c <SystemInit+0x5c>)
 80032de:	4b0b      	ldr	r3, [pc, #44]	; (800330c <SystemInit+0x5c>)
 80032e0:	681b      	ldr	r3, [r3, #0]
 80032e2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80032e6:	6013      	str	r3, [r2, #0]

  /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
  RCC->CFGR &= (uint32_t)0xFF02FFFF;
 80032e8:	4a08      	ldr	r2, [pc, #32]	; (800330c <SystemInit+0x5c>)
 80032ea:	4b08      	ldr	r3, [pc, #32]	; (800330c <SystemInit+0x5c>)
 80032ec:	689b      	ldr	r3, [r3, #8]
 80032ee:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 80032f2:	6093      	str	r3, [r2, #8]

  /*!< Disable all interrupts */
  RCC->CIR = 0x00000000;
 80032f4:	4b05      	ldr	r3, [pc, #20]	; (800330c <SystemInit+0x5c>)
 80032f6:	2200      	movs	r2, #0
 80032f8:	60da      	str	r2, [r3, #12]
#ifdef DATA_IN_ExtSRAM
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
    
  /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
  SetSysClock();
 80032fa:	f000 f80d 	bl	8003318 <SetSysClock>

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 80032fe:	4b05      	ldr	r3, [pc, #20]	; (8003314 <SystemInit+0x64>)
 8003300:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8003304:	609a      	str	r2, [r3, #8]
#endif
}
 8003306:	bf00      	nop
 8003308:	bd80      	pop	{r7, pc}
 800330a:	bf00      	nop
 800330c:	40023800 	.word	0x40023800
 8003310:	88ffc00c 	.word	0x88ffc00c
 8003314:	e000ed00 	.word	0xe000ed00

08003318 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8003318:	b480      	push	{r7}
 800331a:	b083      	sub	sp, #12
 800331c:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800331e:	2300      	movs	r3, #0
 8003320:	607b      	str	r3, [r7, #4]
 8003322:	2300      	movs	r3, #0
 8003324:	603b      	str	r3, [r7, #0]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8003326:	4a41      	ldr	r2, [pc, #260]	; (800342c <SetSysClock+0x114>)
 8003328:	4b40      	ldr	r3, [pc, #256]	; (800342c <SetSysClock+0x114>)
 800332a:	681b      	ldr	r3, [r3, #0]
 800332c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003330:	6013      	str	r3, [r2, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8003332:	4b3e      	ldr	r3, [pc, #248]	; (800342c <SetSysClock+0x114>)
 8003334:	681b      	ldr	r3, [r3, #0]
 8003336:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800333a:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 800333c:	687b      	ldr	r3, [r7, #4]
 800333e:	3301      	adds	r3, #1
 8003340:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8003342:	683b      	ldr	r3, [r7, #0]
 8003344:	2b00      	cmp	r3, #0
 8003346:	d103      	bne.n	8003350 <SetSysClock+0x38>
 8003348:	687b      	ldr	r3, [r7, #4]
 800334a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800334e:	d1f0      	bne.n	8003332 <SetSysClock+0x1a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8003350:	4b36      	ldr	r3, [pc, #216]	; (800342c <SetSysClock+0x114>)
 8003352:	681b      	ldr	r3, [r3, #0]
 8003354:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003358:	2b00      	cmp	r3, #0
 800335a:	d002      	beq.n	8003362 <SetSysClock+0x4a>
  {
    HSEStatus = (uint32_t)0x01;
 800335c:	2301      	movs	r3, #1
 800335e:	603b      	str	r3, [r7, #0]
 8003360:	e001      	b.n	8003366 <SetSysClock+0x4e>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8003362:	2300      	movs	r3, #0
 8003364:	603b      	str	r3, [r7, #0]
  }
  
  if (HSEStatus == (uint32_t)0x01)
 8003366:	683b      	ldr	r3, [r7, #0]
 8003368:	2b01      	cmp	r3, #1
 800336a:	d15a      	bne.n	8003422 <SetSysClock+0x10a>
  {
    /* Enable 64-bit access */
    FLASH->ACR |= FLASH_ACR_ACC64;
 800336c:	4a30      	ldr	r2, [pc, #192]	; (8003430 <SetSysClock+0x118>)
 800336e:	4b30      	ldr	r3, [pc, #192]	; (8003430 <SetSysClock+0x118>)
 8003370:	681b      	ldr	r3, [r3, #0]
 8003372:	f043 0304 	orr.w	r3, r3, #4
 8003376:	6013      	str	r3, [r2, #0]
    
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8003378:	4a2d      	ldr	r2, [pc, #180]	; (8003430 <SetSysClock+0x118>)
 800337a:	4b2d      	ldr	r3, [pc, #180]	; (8003430 <SetSysClock+0x118>)
 800337c:	681b      	ldr	r3, [r3, #0]
 800337e:	f043 0302 	orr.w	r3, r3, #2
 8003382:	6013      	str	r3, [r2, #0]

    /* Flash 1 wait state */
    FLASH->ACR |= FLASH_ACR_LATENCY;
 8003384:	4a2a      	ldr	r2, [pc, #168]	; (8003430 <SetSysClock+0x118>)
 8003386:	4b2a      	ldr	r3, [pc, #168]	; (8003430 <SetSysClock+0x118>)
 8003388:	681b      	ldr	r3, [r3, #0]
 800338a:	f043 0301 	orr.w	r3, r3, #1
 800338e:	6013      	str	r3, [r2, #0]
    
    /* Power enable */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8003390:	4a26      	ldr	r2, [pc, #152]	; (800342c <SetSysClock+0x114>)
 8003392:	4b26      	ldr	r3, [pc, #152]	; (800342c <SetSysClock+0x114>)
 8003394:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003396:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800339a:	6253      	str	r3, [r2, #36]	; 0x24
  
    /* Select the Voltage Range 1 (1.8 V) */
    PWR->CR = PWR_CR_VOS_0;
 800339c:	4b25      	ldr	r3, [pc, #148]	; (8003434 <SetSysClock+0x11c>)
 800339e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80033a2:	601a      	str	r2, [r3, #0]
  
    /* Wait Until the Voltage Regulator is ready */
    while((PWR->CSR & PWR_CSR_VOSF) != RESET)
 80033a4:	bf00      	nop
 80033a6:	4b23      	ldr	r3, [pc, #140]	; (8003434 <SetSysClock+0x11c>)
 80033a8:	685b      	ldr	r3, [r3, #4]
 80033aa:	f003 0310 	and.w	r3, r3, #16
 80033ae:	2b00      	cmp	r3, #0
 80033b0:	d1f9      	bne.n	80033a6 <SetSysClock+0x8e>
    {
    }
        
    /* HCLK = SYSCLK /1*/
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 80033b2:	4a1e      	ldr	r2, [pc, #120]	; (800342c <SetSysClock+0x114>)
 80033b4:	4b1d      	ldr	r3, [pc, #116]	; (800342c <SetSysClock+0x114>)
 80033b6:	689b      	ldr	r3, [r3, #8]
 80033b8:	6093      	str	r3, [r2, #8]
  
    /* PCLK2 = HCLK /1*/
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 80033ba:	4a1c      	ldr	r2, [pc, #112]	; (800342c <SetSysClock+0x114>)
 80033bc:	4b1b      	ldr	r3, [pc, #108]	; (800342c <SetSysClock+0x114>)
 80033be:	689b      	ldr	r3, [r3, #8]
 80033c0:	6093      	str	r3, [r2, #8]
    
    /* PCLK1 = HCLK /1*/
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
 80033c2:	4a1a      	ldr	r2, [pc, #104]	; (800342c <SetSysClock+0x114>)
 80033c4:	4b19      	ldr	r3, [pc, #100]	; (800342c <SetSysClock+0x114>)
 80033c6:	689b      	ldr	r3, [r3, #8]
 80033c8:	6093      	str	r3, [r2, #8]
    
    /*  PLL configuration */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL |
 80033ca:	4a18      	ldr	r2, [pc, #96]	; (800342c <SetSysClock+0x114>)
 80033cc:	4b17      	ldr	r3, [pc, #92]	; (800342c <SetSysClock+0x114>)
 80033ce:	689b      	ldr	r3, [r3, #8]
 80033d0:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 80033d4:	6093      	str	r3, [r2, #8]
                                        RCC_CFGR_PLLDIV));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMUL12 | RCC_CFGR_PLLDIV3);
 80033d6:	4a15      	ldr	r2, [pc, #84]	; (800342c <SetSysClock+0x114>)
 80033d8:	4b14      	ldr	r3, [pc, #80]	; (800342c <SetSysClock+0x114>)
 80033da:	689b      	ldr	r3, [r3, #8]
 80033dc:	f443 0311 	orr.w	r3, r3, #9502720	; 0x910000
 80033e0:	6093      	str	r3, [r2, #8]

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 80033e2:	4a12      	ldr	r2, [pc, #72]	; (800342c <SetSysClock+0x114>)
 80033e4:	4b11      	ldr	r3, [pc, #68]	; (800342c <SetSysClock+0x114>)
 80033e6:	681b      	ldr	r3, [r3, #0]
 80033e8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80033ec:	6013      	str	r3, [r2, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 80033ee:	bf00      	nop
 80033f0:	4b0e      	ldr	r3, [pc, #56]	; (800342c <SetSysClock+0x114>)
 80033f2:	681b      	ldr	r3, [r3, #0]
 80033f4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80033f8:	2b00      	cmp	r3, #0
 80033fa:	d0f9      	beq.n	80033f0 <SetSysClock+0xd8>
    {
    }
        
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80033fc:	4a0b      	ldr	r2, [pc, #44]	; (800342c <SetSysClock+0x114>)
 80033fe:	4b0b      	ldr	r3, [pc, #44]	; (800342c <SetSysClock+0x114>)
 8003400:	689b      	ldr	r3, [r3, #8]
 8003402:	f023 0303 	bic.w	r3, r3, #3
 8003406:	6093      	str	r3, [r2, #8]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
 8003408:	4a08      	ldr	r2, [pc, #32]	; (800342c <SetSysClock+0x114>)
 800340a:	4b08      	ldr	r3, [pc, #32]	; (800342c <SetSysClock+0x114>)
 800340c:	689b      	ldr	r3, [r3, #8]
 800340e:	f043 0303 	orr.w	r3, r3, #3
 8003412:	6093      	str	r3, [r2, #8]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
 8003414:	bf00      	nop
 8003416:	4b05      	ldr	r3, [pc, #20]	; (800342c <SetSysClock+0x114>)
 8003418:	689b      	ldr	r3, [r3, #8]
 800341a:	f003 030c 	and.w	r3, r3, #12
 800341e:	2b0c      	cmp	r3, #12
 8003420:	d1f9      	bne.n	8003416 <SetSysClock+0xfe>
  else
  {
    /* If HSE fails to start-up, the application will have wrong clock
       configuration. User can add here some code to deal with this error */
  }
}
 8003422:	bf00      	nop
 8003424:	370c      	adds	r7, #12
 8003426:	46bd      	mov	sp, r7
 8003428:	bc80      	pop	{r7}
 800342a:	4770      	bx	lr
 800342c:	40023800 	.word	0x40023800
 8003430:	40023c00 	.word	0x40023c00
 8003434:	40007000 	.word	0x40007000

08003438 <ts_itoa>:
**  Abstract: Convert integer to ascii
**  Returns:  void
**---------------------------------------------------------------------------
*/
void ts_itoa(char **buf, unsigned int d, int base)
{
 8003438:	b480      	push	{r7}
 800343a:	b087      	sub	sp, #28
 800343c:	af00      	add	r7, sp, #0
 800343e:	60f8      	str	r0, [r7, #12]
 8003440:	60b9      	str	r1, [r7, #8]
 8003442:	607a      	str	r2, [r7, #4]
	int div = 1;
 8003444:	2301      	movs	r3, #1
 8003446:	617b      	str	r3, [r7, #20]
	while (d/div >= base)
 8003448:	e004      	b.n	8003454 <ts_itoa+0x1c>
		div *= base;
 800344a:	697b      	ldr	r3, [r7, #20]
 800344c:	687a      	ldr	r2, [r7, #4]
 800344e:	fb02 f303 	mul.w	r3, r2, r3
 8003452:	617b      	str	r3, [r7, #20]
**---------------------------------------------------------------------------
*/
void ts_itoa(char **buf, unsigned int d, int base)
{
	int div = 1;
	while (d/div >= base)
 8003454:	697b      	ldr	r3, [r7, #20]
 8003456:	68ba      	ldr	r2, [r7, #8]
 8003458:	fbb2 f2f3 	udiv	r2, r2, r3
 800345c:	687b      	ldr	r3, [r7, #4]
 800345e:	429a      	cmp	r2, r3
 8003460:	d2f3      	bcs.n	800344a <ts_itoa+0x12>
		div *= base;

	while (div != 0)
 8003462:	e029      	b.n	80034b8 <ts_itoa+0x80>
	{
		int num = d/div;
 8003464:	697b      	ldr	r3, [r7, #20]
 8003466:	68ba      	ldr	r2, [r7, #8]
 8003468:	fbb2 f3f3 	udiv	r3, r2, r3
 800346c:	613b      	str	r3, [r7, #16]
		d = d%div;
 800346e:	697a      	ldr	r2, [r7, #20]
 8003470:	68bb      	ldr	r3, [r7, #8]
 8003472:	fbb3 f1f2 	udiv	r1, r3, r2
 8003476:	fb02 f201 	mul.w	r2, r2, r1
 800347a:	1a9b      	subs	r3, r3, r2
 800347c:	60bb      	str	r3, [r7, #8]
		div /= base;
 800347e:	697a      	ldr	r2, [r7, #20]
 8003480:	687b      	ldr	r3, [r7, #4]
 8003482:	fb92 f3f3 	sdiv	r3, r2, r3
 8003486:	617b      	str	r3, [r7, #20]
		if (num > 9)
 8003488:	693b      	ldr	r3, [r7, #16]
 800348a:	2b09      	cmp	r3, #9
 800348c:	dd0a      	ble.n	80034a4 <ts_itoa+0x6c>
			*((*buf)++) = (num-10) + 'A';
 800348e:	68fb      	ldr	r3, [r7, #12]
 8003490:	681b      	ldr	r3, [r3, #0]
 8003492:	1c59      	adds	r1, r3, #1
 8003494:	68fa      	ldr	r2, [r7, #12]
 8003496:	6011      	str	r1, [r2, #0]
 8003498:	693a      	ldr	r2, [r7, #16]
 800349a:	b2d2      	uxtb	r2, r2
 800349c:	3237      	adds	r2, #55	; 0x37
 800349e:	b2d2      	uxtb	r2, r2
 80034a0:	701a      	strb	r2, [r3, #0]
 80034a2:	e009      	b.n	80034b8 <ts_itoa+0x80>
		else
			*((*buf)++) = num + '0';
 80034a4:	68fb      	ldr	r3, [r7, #12]
 80034a6:	681b      	ldr	r3, [r3, #0]
 80034a8:	1c59      	adds	r1, r3, #1
 80034aa:	68fa      	ldr	r2, [r7, #12]
 80034ac:	6011      	str	r1, [r2, #0]
 80034ae:	693a      	ldr	r2, [r7, #16]
 80034b0:	b2d2      	uxtb	r2, r2
 80034b2:	3230      	adds	r2, #48	; 0x30
 80034b4:	b2d2      	uxtb	r2, r2
 80034b6:	701a      	strb	r2, [r3, #0]
{
	int div = 1;
	while (d/div >= base)
		div *= base;

	while (div != 0)
 80034b8:	697b      	ldr	r3, [r7, #20]
 80034ba:	2b00      	cmp	r3, #0
 80034bc:	d1d2      	bne.n	8003464 <ts_itoa+0x2c>
		if (num > 9)
			*((*buf)++) = (num-10) + 'A';
		else
			*((*buf)++) = num + '0';
	}
}
 80034be:	bf00      	nop
 80034c0:	371c      	adds	r7, #28
 80034c2:	46bd      	mov	sp, r7
 80034c4:	bc80      	pop	{r7}
 80034c6:	4770      	bx	lr

080034c8 <ts_formatstring>:
**  Abstract: Writes arguments va to buffer buf according to format fmt
**  Returns:  Length of string
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
{
 80034c8:	b580      	push	{r7, lr}
 80034ca:	b088      	sub	sp, #32
 80034cc:	af00      	add	r7, sp, #0
 80034ce:	60f8      	str	r0, [r7, #12]
 80034d0:	60b9      	str	r1, [r7, #8]
 80034d2:	607a      	str	r2, [r7, #4]
	char *start_buf = buf;
 80034d4:	68fb      	ldr	r3, [r7, #12]
 80034d6:	617b      	str	r3, [r7, #20]
	while(*fmt)
 80034d8:	e07d      	b.n	80035d6 <ts_formatstring+0x10e>
	{
		/* Character needs formating? */
		if (*fmt == '%')
 80034da:	68bb      	ldr	r3, [r7, #8]
 80034dc:	781b      	ldrb	r3, [r3, #0]
 80034de:	2b25      	cmp	r3, #37	; 0x25
 80034e0:	d171      	bne.n	80035c6 <ts_formatstring+0xfe>
		{
			switch (*(++fmt))
 80034e2:	68bb      	ldr	r3, [r7, #8]
 80034e4:	3301      	adds	r3, #1
 80034e6:	60bb      	str	r3, [r7, #8]
 80034e8:	68bb      	ldr	r3, [r7, #8]
 80034ea:	781b      	ldrb	r3, [r3, #0]
 80034ec:	2b64      	cmp	r3, #100	; 0x64
 80034ee:	d01e      	beq.n	800352e <ts_formatstring+0x66>
 80034f0:	2b64      	cmp	r3, #100	; 0x64
 80034f2:	dc06      	bgt.n	8003502 <ts_formatstring+0x3a>
 80034f4:	2b58      	cmp	r3, #88	; 0x58
 80034f6:	d050      	beq.n	800359a <ts_formatstring+0xd2>
 80034f8:	2b63      	cmp	r3, #99	; 0x63
 80034fa:	d00e      	beq.n	800351a <ts_formatstring+0x52>
 80034fc:	2b25      	cmp	r3, #37	; 0x25
 80034fe:	d058      	beq.n	80035b2 <ts_formatstring+0xea>
 8003500:	e05d      	b.n	80035be <ts_formatstring+0xf6>
 8003502:	2b73      	cmp	r3, #115	; 0x73
 8003504:	d02b      	beq.n	800355e <ts_formatstring+0x96>
 8003506:	2b73      	cmp	r3, #115	; 0x73
 8003508:	dc02      	bgt.n	8003510 <ts_formatstring+0x48>
 800350a:	2b69      	cmp	r3, #105	; 0x69
 800350c:	d00f      	beq.n	800352e <ts_formatstring+0x66>
 800350e:	e056      	b.n	80035be <ts_formatstring+0xf6>
 8003510:	2b75      	cmp	r3, #117	; 0x75
 8003512:	d037      	beq.n	8003584 <ts_formatstring+0xbc>
 8003514:	2b78      	cmp	r3, #120	; 0x78
 8003516:	d040      	beq.n	800359a <ts_formatstring+0xd2>
 8003518:	e051      	b.n	80035be <ts_formatstring+0xf6>
			{
			  case 'c':
				*buf++ = va_arg(va, int);
 800351a:	68fb      	ldr	r3, [r7, #12]
 800351c:	1c5a      	adds	r2, r3, #1
 800351e:	60fa      	str	r2, [r7, #12]
 8003520:	687a      	ldr	r2, [r7, #4]
 8003522:	1d11      	adds	r1, r2, #4
 8003524:	6079      	str	r1, [r7, #4]
 8003526:	6812      	ldr	r2, [r2, #0]
 8003528:	b2d2      	uxtb	r2, r2
 800352a:	701a      	strb	r2, [r3, #0]
				break;
 800352c:	e047      	b.n	80035be <ts_formatstring+0xf6>
			  case 'd':
			  case 'i':
				{
					signed int val = va_arg(va, signed int);
 800352e:	687b      	ldr	r3, [r7, #4]
 8003530:	1d1a      	adds	r2, r3, #4
 8003532:	607a      	str	r2, [r7, #4]
 8003534:	681b      	ldr	r3, [r3, #0]
 8003536:	61fb      	str	r3, [r7, #28]
					if (val < 0)
 8003538:	69fb      	ldr	r3, [r7, #28]
 800353a:	2b00      	cmp	r3, #0
 800353c:	da07      	bge.n	800354e <ts_formatstring+0x86>
					{
						val *= -1;
 800353e:	69fb      	ldr	r3, [r7, #28]
 8003540:	425b      	negs	r3, r3
 8003542:	61fb      	str	r3, [r7, #28]
						*buf++ = '-';
 8003544:	68fb      	ldr	r3, [r7, #12]
 8003546:	1c5a      	adds	r2, r3, #1
 8003548:	60fa      	str	r2, [r7, #12]
 800354a:	222d      	movs	r2, #45	; 0x2d
 800354c:	701a      	strb	r2, [r3, #0]
					}
					ts_itoa(&buf, val, 10);
 800354e:	69f9      	ldr	r1, [r7, #28]
 8003550:	f107 030c 	add.w	r3, r7, #12
 8003554:	220a      	movs	r2, #10
 8003556:	4618      	mov	r0, r3
 8003558:	f7ff ff6e 	bl	8003438 <ts_itoa>
				}
				break;
 800355c:	e02f      	b.n	80035be <ts_formatstring+0xf6>
			  case 's':
				{
					char * arg = va_arg(va, char *);
 800355e:	687b      	ldr	r3, [r7, #4]
 8003560:	1d1a      	adds	r2, r3, #4
 8003562:	607a      	str	r2, [r7, #4]
 8003564:	681b      	ldr	r3, [r3, #0]
 8003566:	61bb      	str	r3, [r7, #24]
					while (*arg)
 8003568:	e007      	b.n	800357a <ts_formatstring+0xb2>
					{
						*buf++ = *arg++;
 800356a:	68fb      	ldr	r3, [r7, #12]
 800356c:	1c5a      	adds	r2, r3, #1
 800356e:	60fa      	str	r2, [r7, #12]
 8003570:	69ba      	ldr	r2, [r7, #24]
 8003572:	1c51      	adds	r1, r2, #1
 8003574:	61b9      	str	r1, [r7, #24]
 8003576:	7812      	ldrb	r2, [r2, #0]
 8003578:	701a      	strb	r2, [r3, #0]
				}
				break;
			  case 's':
				{
					char * arg = va_arg(va, char *);
					while (*arg)
 800357a:	69bb      	ldr	r3, [r7, #24]
 800357c:	781b      	ldrb	r3, [r3, #0]
 800357e:	2b00      	cmp	r3, #0
 8003580:	d1f3      	bne.n	800356a <ts_formatstring+0xa2>
					{
						*buf++ = *arg++;
					}
				}
				break;
 8003582:	e01c      	b.n	80035be <ts_formatstring+0xf6>
			  case 'u':
					ts_itoa(&buf, va_arg(va, unsigned int), 10);
 8003584:	687b      	ldr	r3, [r7, #4]
 8003586:	1d1a      	adds	r2, r3, #4
 8003588:	607a      	str	r2, [r7, #4]
 800358a:	6819      	ldr	r1, [r3, #0]
 800358c:	f107 030c 	add.w	r3, r7, #12
 8003590:	220a      	movs	r2, #10
 8003592:	4618      	mov	r0, r3
 8003594:	f7ff ff50 	bl	8003438 <ts_itoa>
				break;
 8003598:	e011      	b.n	80035be <ts_formatstring+0xf6>
			  case 'x':
			  case 'X':
					ts_itoa(&buf, va_arg(va, int), 16);
 800359a:	687b      	ldr	r3, [r7, #4]
 800359c:	1d1a      	adds	r2, r3, #4
 800359e:	607a      	str	r2, [r7, #4]
 80035a0:	681b      	ldr	r3, [r3, #0]
 80035a2:	4619      	mov	r1, r3
 80035a4:	f107 030c 	add.w	r3, r7, #12
 80035a8:	2210      	movs	r2, #16
 80035aa:	4618      	mov	r0, r3
 80035ac:	f7ff ff44 	bl	8003438 <ts_itoa>
				break;
 80035b0:	e005      	b.n	80035be <ts_formatstring+0xf6>
			  case '%':
				  *buf++ = '%';
 80035b2:	68fb      	ldr	r3, [r7, #12]
 80035b4:	1c5a      	adds	r2, r3, #1
 80035b6:	60fa      	str	r2, [r7, #12]
 80035b8:	2225      	movs	r2, #37	; 0x25
 80035ba:	701a      	strb	r2, [r3, #0]
				  break;
 80035bc:	bf00      	nop
			}
			fmt++;
 80035be:	68bb      	ldr	r3, [r7, #8]
 80035c0:	3301      	adds	r3, #1
 80035c2:	60bb      	str	r3, [r7, #8]
 80035c4:	e007      	b.n	80035d6 <ts_formatstring+0x10e>
		}
		/* Else just copy */
		else
		{
			*buf++ = *fmt++;
 80035c6:	68fb      	ldr	r3, [r7, #12]
 80035c8:	1c5a      	adds	r2, r3, #1
 80035ca:	60fa      	str	r2, [r7, #12]
 80035cc:	68ba      	ldr	r2, [r7, #8]
 80035ce:	1c51      	adds	r1, r2, #1
 80035d0:	60b9      	str	r1, [r7, #8]
 80035d2:	7812      	ldrb	r2, [r2, #0]
 80035d4:	701a      	strb	r2, [r3, #0]
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
{
	char *start_buf = buf;
	while(*fmt)
 80035d6:	68bb      	ldr	r3, [r7, #8]
 80035d8:	781b      	ldrb	r3, [r3, #0]
 80035da:	2b00      	cmp	r3, #0
 80035dc:	f47f af7d 	bne.w	80034da <ts_formatstring+0x12>
		else
		{
			*buf++ = *fmt++;
		}
	}
	*buf = 0;
 80035e0:	68fb      	ldr	r3, [r7, #12]
 80035e2:	2200      	movs	r2, #0
 80035e4:	701a      	strb	r2, [r3, #0]

	return (int)(buf - start_buf);
 80035e6:	68fb      	ldr	r3, [r7, #12]
 80035e8:	461a      	mov	r2, r3
 80035ea:	697b      	ldr	r3, [r7, #20]
 80035ec:	1ad3      	subs	r3, r2, r3
}
 80035ee:	4618      	mov	r0, r3
 80035f0:	3720      	adds	r7, #32
 80035f2:	46bd      	mov	sp, r7
 80035f4:	bd80      	pop	{r7, pc}
 80035f6:	bf00      	nop

080035f8 <siprintf>:
**            given character string according to the format parameter.
**  Returns:  Number of bytes written
**===========================================================================
*/
int siprintf(char *buf, const char *fmt, ...)
{
 80035f8:	b40e      	push	{r1, r2, r3}
 80035fa:	b580      	push	{r7, lr}
 80035fc:	b085      	sub	sp, #20
 80035fe:	af00      	add	r7, sp, #0
 8003600:	6078      	str	r0, [r7, #4]
	int length;
	va_list va;
	va_start(va, fmt);
 8003602:	f107 0320 	add.w	r3, r7, #32
 8003606:	60bb      	str	r3, [r7, #8]
	length = ts_formatstring(buf, fmt, va);
 8003608:	68ba      	ldr	r2, [r7, #8]
 800360a:	69f9      	ldr	r1, [r7, #28]
 800360c:	6878      	ldr	r0, [r7, #4]
 800360e:	f7ff ff5b 	bl	80034c8 <ts_formatstring>
 8003612:	60f8      	str	r0, [r7, #12]
	va_end(va);
	return length;
 8003614:	68fb      	ldr	r3, [r7, #12]
}
 8003616:	4618      	mov	r0, r3
 8003618:	3714      	adds	r7, #20
 800361a:	46bd      	mov	sp, r7
 800361c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8003620:	b003      	add	sp, #12
 8003622:	4770      	bx	lr

08003624 <__libc_init_array>:
 8003624:	4b0e      	ldr	r3, [pc, #56]	; (8003660 <__libc_init_array+0x3c>)
 8003626:	b570      	push	{r4, r5, r6, lr}
 8003628:	461e      	mov	r6, r3
 800362a:	4c0e      	ldr	r4, [pc, #56]	; (8003664 <__libc_init_array+0x40>)
 800362c:	2500      	movs	r5, #0
 800362e:	1ae4      	subs	r4, r4, r3
 8003630:	10a4      	asrs	r4, r4, #2
 8003632:	42a5      	cmp	r5, r4
 8003634:	d004      	beq.n	8003640 <__libc_init_array+0x1c>
 8003636:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800363a:	4798      	blx	r3
 800363c:	3501      	adds	r5, #1
 800363e:	e7f8      	b.n	8003632 <__libc_init_array+0xe>
 8003640:	f000 f822 	bl	8003688 <_init>
 8003644:	4b08      	ldr	r3, [pc, #32]	; (8003668 <__libc_init_array+0x44>)
 8003646:	4c09      	ldr	r4, [pc, #36]	; (800366c <__libc_init_array+0x48>)
 8003648:	461e      	mov	r6, r3
 800364a:	1ae4      	subs	r4, r4, r3
 800364c:	10a4      	asrs	r4, r4, #2
 800364e:	2500      	movs	r5, #0
 8003650:	42a5      	cmp	r5, r4
 8003652:	d004      	beq.n	800365e <__libc_init_array+0x3a>
 8003654:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8003658:	4798      	blx	r3
 800365a:	3501      	adds	r5, #1
 800365c:	e7f8      	b.n	8003650 <__libc_init_array+0x2c>
 800365e:	bd70      	pop	{r4, r5, r6, pc}
 8003660:	08003f58 	.word	0x08003f58
 8003664:	08003f58 	.word	0x08003f58
 8003668:	08003f58 	.word	0x08003f58
 800366c:	08003f5c 	.word	0x08003f5c

08003670 <memcpy>:
 8003670:	b510      	push	{r4, lr}
 8003672:	1e43      	subs	r3, r0, #1
 8003674:	440a      	add	r2, r1
 8003676:	4291      	cmp	r1, r2
 8003678:	d004      	beq.n	8003684 <memcpy+0x14>
 800367a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800367e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8003682:	e7f8      	b.n	8003676 <memcpy+0x6>
 8003684:	bd10      	pop	{r4, pc}
	...

08003688 <_init>:
 8003688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800368a:	bf00      	nop
 800368c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800368e:	bc08      	pop	{r3}
 8003690:	469e      	mov	lr, r3
 8003692:	4770      	bx	lr

08003694 <_fini>:
 8003694:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003696:	bf00      	nop
 8003698:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800369a:	bc08      	pop	{r3}
 800369c:	469e      	mov	lr, r3
 800369e:	4770      	bx	lr
